<!doctype html>



 <html class="no-js"> 

  <head>
    <title>saul - goodman</title>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">

    <meta name="description" content="taicang">
    <meta name="google-site-verification" content="_kDN7uZlq3Uv5yjsjP5vA1I-u5_Vifz2XkAOla4l0hY">

    <link rel="shortcut icon" type="image/png" href="https://gniqizeuy.github.io//img/favicon.png" />
 
    <link rel="stylesheet" href="https://gniqizeuy.github.io//css/bootstrap.min.css">
    <link rel="stylesheet" href="https://gniqizeuy.github.io//css/main.css">
    <link href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/vs2015.min.css" rel="stylesheet">
  </head>

  <body>

    <a href="https://github.com/gniqizeuy" class="hidden-xs">
      <img style="position: absolute; top: 0; right: 0; border: 0; z-index: 10000;" src="https://gniqizeuy.github.io//img/fockme.png" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png">
    </a>
<div id="top"></div>

<div class="header">
  <div class="hidden-xs stars_1"></div>
  <div class="hidden-xs stars_2"></div>

  <nav class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <a class="navbar-brand" href="#">taicang</a>
    </div>
  </nav>

  <div class="container">
    <div class="row">
      <div class="col-xs-12">
       
        
          
           <h1>gniqizeuy blog</h1>
 <p>do my best</p>
 
        

      </div>
      <div class="col-xs-12">
        <span class="pull-right links">
          <ul>
            <li>
              <a href="https://github.com/gohugoio/hugo/releases/tag/v0.10"><img height=24 src="https://gniqizeuy.github.io//img/download.png">HUGO v0.10</a>
            </li>
            <li>
              <a href="https://github.com/checkmyws/yslow-rules"><img width=24 src="https://gniqizeuy.github.io//img/yslow.png">yslow-rules</a>
            </li>
          </ul>
        </span>
      </div>
    </div>
  </div>
</div>

<nav class="navbar navbar-default" role="navigation">
  <div class="container">
    <ul class="nav navbar-nav">
      <li>
        <a onclick="clickTag('all');">All</a>
      </li>
      
      <li>
        <a onclick="clickTag('css');">Css</a>
      </li>
      
      <li>
        <a onclick="clickTag('design');">Design</a>
      </li>
      
      <li>
        <a onclick="clickTag('java');">Java</a>
      </li>
      
      <li>
        <a onclick="clickTag('js');">Js</a>
      </li>
      
      <li>
        <a onclick="clickTag('linux');">Linux</a>
      </li>
      
      <li>
        <a onclick="clickTag('other');">Other</a>
      </li>
      
      <li>
        <a onclick="clickTag('python');">Python</a>
      </li>
      
      <li>
        <a onclick="clickTag('redis');">Redis</a>
      </li>
      
      <li>
        <a onclick="clickTag('spring');">Spring</a>
      </li>
      
    </ul>

    <ul class="nav navbar-nav navbar-right">
      <li>
        <a href="https://gniqizeuy.github.io/en">
          <img src="https://gniqizeuy.github.io//css/blank.gif" class="flag flag-us" alt="English" />
        </a>
      </li>
      <li>
        <a href="https://gniqizeuy.github.io/fr">
          <img src="https://gniqizeuy.github.io//css/blank.gif" class="flag flag-fr" alt="Français" />
        </a>
      </li>
      <li>
        <a href="https://gniqizeuy.github.io/es">
          <img src="https://gniqizeuy.github.io//css/blank.gif" class="flag flag-es" alt="Espanõl" />
        </a>
      </li>
    </ul>
  </div>
</nav>

<div class="container intro">
  <div class="row">
    <div class="col-xs-12">
      
        
        <p style="font-size: 16px;">
    博客由HUGO搭建，使用yshow主题，HUGO版本为0.10。以下博客内容摘录于书籍以及平时学习过程
</p>
      
    </div>
  </div>
</div>


<div class="container">
  <div class="row">
    <div class="col-xs-12">
      <div class="summary hidden-xs">
        <ol>
          
          <li class="rule tag-java ">
            <a href="#java_primitive">Java Primitive</a>
          </li>
          
          <li class="rule tag-java ">
            <a href="#java_file">Java try with res</a>
          </li>
          
          <li class="rule tag-js ">
            <a href="#java_collections">Java collections</a>
          </li>
          
          <li class="rule tag-Java ">
            <a href="#java_list">Java list</a>
          </li>
          
          <li class="rule tag-python ">
            <a href="#py_dict">Python Dict</a>
          </li>
          
          <li class="rule tag-python ">
            <a href="#py_summary">Python Summary</a>
          </li>
          
          <li class="rule tag-python ">
            <a href="#py_set">Python Set</a>
          </li>
          
          <li class="rule tag-js ">
            <a href="#js_websocket">Js WebSocket</a>
          </li>
          
          <li class="rule tag-js ">
            <a href="#js_module">Js Module</a>
          </li>
          
          <li class="rule tag-js ">
            <a href="#js_storage">Js Storage</a>
          </li>
          
          <li class="rule tag-spring ">
            <a href="#spring_test">Spring Test</a>
          </li>
          
          <li class="rule tag-spring ">
            <a href="#spring_transactional">Spring transactional</a>
          </li>
          
          <li class="rule tag-spring ">
            <a href="#spring_yml">Spring YML</a>
          </li>
          
          <li class="rule tag-spring ">
            <a href="#spring_swagger">Spring Swagger</a>
          </li>
          
          <li class="rule tag-linux ">
            <a href="#linux%20%e6%96%87%e4%bb%b6%e4%b8%8e%e7%9b%ae%e5%bd%95%e6%9d%83%e9%99%90">Linux permissions</a>
          </li>
          
          <li class="rule tag-redis ">
            <a href="#redis_string">Redis String</a>
          </li>
          
          <li class="rule tag-redis ">
            <a href="#redis_clients">Redis Client API</a>
          </li>
          
          <li class="rule tag-redis ">
            <a href="#redis_cmd">Redis Command</a>
          </li>
          
          <li class="rule tag-redis ">
            <a href="#redis_config">Redis Config</a>
          </li>
          
          <li class="rule tag-redis ">
            <a href="#redis_list">Redis List</a>
          </li>
          
          <li class="rule tag-redis ">
            <a href="#redis_memory">Redis Memory</a>
          </li>
          
          <li class="rule tag-java ">
            <a href="#java_sort">java Sort</a>
          </li>
          
          <li class="rule tag-design ">
            <a href="#abstract_factory">Abstract Factory</a>
          </li>
          
          <li class="rule tag-design ">
            <a href="#design_pattern">Design Pattern</a>
          </li>
          
          <li class="rule tag-css ">
            <a href="#css_bg%26bd">CSS background border</a>
          </li>
          
          <li class="rule tag-other ">
            <a href="#mac">MAC adr</a>
          </li>
          
        </ol>
      </div>
      <div class="summary-small visible-xs">
        <ol>
          
          <li class="rule tag-js ">
            <a href="#java_collections">Java collections</a>
          </li>
          
          <li class="rule tag-java ">
            <a href="#java_file">Java try with res</a>
          </li>
          
          <li class="rule tag-Java ">
            <a href="#java_list">Java list</a>
          </li>
          
          <li class="rule tag-java ">
            <a href="#java_primitive">Java Primitive</a>
          </li>
          
          <li class="rule tag-python ">
            <a href="#py_summary">Python Summary</a>
          </li>
          
          <li class="rule tag-python ">
            <a href="#py_dict">Python Dict</a>
          </li>
          
          <li class="rule tag-python ">
            <a href="#py_set">Python Set</a>
          </li>
          
          <li class="rule tag-js ">
            <a href="#js_websocket">Js WebSocket</a>
          </li>
          
          <li class="rule tag-js ">
            <a href="#js_module">Js Module</a>
          </li>
          
          <li class="rule tag-js ">
            <a href="#js_storage">Js Storage</a>
          </li>
          
          <li class="rule tag-spring ">
            <a href="#spring_swagger">Spring Swagger</a>
          </li>
          
          <li class="rule tag-spring ">
            <a href="#spring_test">Spring Test</a>
          </li>
          
          <li class="rule tag-spring ">
            <a href="#spring_transactional">Spring transactional</a>
          </li>
          
          <li class="rule tag-spring ">
            <a href="#spring_yml">Spring YML</a>
          </li>
          
          <li class="rule tag-linux ">
            <a href="#linux%20%e6%96%87%e4%bb%b6%e4%b8%8e%e7%9b%ae%e5%bd%95%e6%9d%83%e9%99%90">Linux permissions</a>
          </li>
          
          <li class="rule tag-redis ">
            <a href="#redis_string">Redis String</a>
          </li>
          
          <li class="rule tag-redis ">
            <a href="#redis_clients">Redis Client API</a>
          </li>
          
          <li class="rule tag-redis ">
            <a href="#redis_cmd">Redis Command</a>
          </li>
          
          <li class="rule tag-redis ">
            <a href="#redis_config">Redis Config</a>
          </li>
          
          <li class="rule tag-redis ">
            <a href="#redis_list">Redis List</a>
          </li>
          
          <li class="rule tag-redis ">
            <a href="#redis_memory">Redis Memory</a>
          </li>
          
          <li class="rule tag-java ">
            <a href="#java_sort">java Sort</a>
          </li>
          
          <li class="rule tag-design ">
            <a href="#abstract_factory">Abstract Factory</a>
          </li>
          
          <li class="rule tag-design ">
            <a href="#design_pattern">Design Pattern</a>
          </li>
          
          <li class="rule tag-css ">
            <a href="#css_bg%26bd">CSS background border</a>
          </li>
          
          <li class="rule tag-other ">
            <a href="#mac">MAC adr</a>
          </li>
          
        </ol>
      </div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-Java " style="padding-bottom:1em;">

        <div id="java_list"></div>
        <span class="hidden" itemprop="alternateName">java_list</span>

        <h2>
            <a itemprop="url" href="#java_list">
                <span itemprop="name">Java list</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/java_list.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">Java</span>
        

        <div itemprop="description">
            

<h3 id="toc_0">抽象数据类型</h3>

<p>　　抽象数据类型（abstract data type，ADT）是带有<strong>一组操作的一些对象的集合</strong></p>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-java " style="padding-bottom:1em;">

        <div id="java_file"></div>
        <span class="hidden" itemprop="alternateName">java_file</span>

        <h2>
            <a itemprop="url" href="#java_file">
                <span itemprop="name">Java try with res</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/java_file.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">java</span>
        

        <div itemprop="description">
            

<h3 id="toc_0">try-with-resources 优先于 try-finally</h3>

<p>java7 中引入了 try-with-resources语句。要使用这个构造的资源，必须先实现 <strong>AutoCloseable</strong> 接口，其中包含了单个返回 void 的 close 方法。java 类库与第三方类库中许多类和接口，现在都实现或扩展了 AutoCloseable 接口。如果编写了一个类，它代表的是必须被关闭的资源，那么这个类也应该实现 AutoCloseable。</p>

<p>范例1：</p>

<pre><code class="java">static String firstLineOfFile(String path) throws IOException {
    try (BufferedReader br = new BufferReader(new FileReader(path))) {
        return br.readLine();
    }
}
</code></pre>

<p>范例2：</p>

<pre><code class="java">static void copy(String src, String dst) throws IOException {
    try (
        InputStream in = new FileInputStream(src);
        OutputStream out = new FileOutputStream(dst)
    ) {
        byte[] buf = new byte[BUFFER_SIZE];
        int n;
        while ((n = in.read(buf)) &gt;= 0)
            out.write(buf, 0, n);
    }
}
</code></pre>

<p>使用 try-with-resources 不仅使代码变得简洁易懂，也更容易诊断。以 firstLineOfFile 方法为例，如果调用 readline 和（不可见）close 方法都抛出异常，后一个异常就会被禁止，以保留第一个异常。事实上，为了保留你想看到的那个异常，即便多个异常都可以被禁止。这些被禁止的异常并不是简单地被抛弃了，而是会被打印在堆栈轨迹中，并注明它们是被禁止的异常。通过编程调用 getSuppressed 方法还可以访问到它们，getSuppressed 方法也添加在 java 7  的 Throwable 中</p>

<p>在 try-with-resources 语句中还可以使用 catch 子句，和 try-finally 语句一样。这样既可以处理异常，又不需要再套用一层代码。</p>

<pre><code class="java">static String firstLineOfFile(String path, String defaultVal) {
    try (BufferedReader br = new BufferedReader(new FileReader(path))) {
        return br.readLine();
    } catch (IOException e) {
        return dafaultVal
    }
}
</code></pre>

<p>firstLineOfFile 方法没有抛出异常，但是如果它无法打开文件，或者无法从中读取，就会返回一个默认值。在处理必须关闭的资源时，始终要优先考虑用try-with-resources，而不是用 try-finally。这样得到的代码将更加简洁、清晰、产生的异常也更有价值。</p>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-java " style="padding-bottom:1em;">

        <div id="java_primitive"></div>
        <span class="hidden" itemprop="alternateName">java_primitive</span>

        <h2>
            <a itemprop="url" href="#java_primitive">
                <span itemprop="name">Java Primitive</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/java_primitive.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">java</span>
        

        <div itemprop="description">
            

<h3 id="toc_0">基本类型优于装箱基本类型</h3>

<p>Java 中有一个类型系统由两部分组成，基本类型（primitive）以及引用类型（reference type）。每个基本类型都有一个对位的引用类型，称作装箱基本类型（boxed primitive）。</p>

<p>自动装箱（autoboxing）和自动拆箱（auto-unboxing）模糊了但并没有完全抹去基本类型和装箱基本类型之间的区别。</p>

<p>两者有三个主要区别：</p>

<ol>
<li>基本类型只有值，而装箱基本类型则具有与它们的值不同的同一性。即两个装箱基本类型可以具有相同的值和不同的同一性。</li>
<li>基本类型<strong>只有函数值</strong>，而每个装箱基本类型则<strong>都有一个非函数值</strong>，除了它对应的基本类型的所有函数值之外，还有个null。</li>
<li>基本类型通常比装箱基本类型更节省时间和空间。</li>
</ol>

<h4 id="toc_1">问题一：比较</h4>

<p>以下示例被用来表示 Integer 值的递增数字顺序。</p>

<pre><code class="java">Comparator&lt;Integer&gt; naturalOrder = (i, j) -&gt; (i &lt; j) ? -1: (i == j ? 0 ： 1);
</code></pre>

<p>上述比较器有严重的缺陷，打印 naturalOrder.Compare(new Integer(42), new Integer(42)) 时，实际输出的是 1 不是 0，表明第一个Integer值大于第二个</p>

<p>原因在于对表达式 i &lt; j 执行计算会导致 i 和 j 引用的 Integer 实例被自动拆箱；从而对值进行比较，但在执行表达式 i == j 时，执行的其实是*同一性比较*（identity comparision）。</p>

<p>对代码修改实现如下：(先拆箱再比较)</p>

<pre><code class="java">Comparator&lt;Integer&gt; naturalOrder = (iBoxed, jBoxedBoxed) -&gt; {
    int i = iBoxed, j = jBoxed;
    return i &lt; j ? -1 : (i == j ? 0 : 1);
}
</code></pre>

<p>如果需要比较器描述一个类型的自然顺序，使用 Comparator.naturalOrder() 即可，自己编写比较器，则应该使用比较器构造方法，或者在基本类型上使用静态比较方法。</p>

<p>以下小程序会导致 <em>NullPointerException</em> 异常</p>

<pre><code class="java">public Class Unbelievable {
    static Integer i;
    
    public static void main(String[] args) {
        if (i == 42)
            System.out.println(&quot;Unbelievable&quot;);
    }
}
</code></pre>

<p>i 是个 Integer 与所有的对象引用域一样，它的初始值为 null。当程序计算表达式 (i == 42) 时，他会将 Integer 与 int 进行比较，混用基本类型和装箱基本类型时，<strong>装箱基本类型会自动拆箱</strong>。如果 null 对象引用被自动拆箱，就会抛出一个 <em>NullPointerException</em> 异常。</p>

<h4 id="toc_2">问题二：性能</h4>

<pre><code class="java">public static void main(String[] args) {
    long sum = 0L;
    for (long i = 0; i &lt; Integer.MAX_VALUE; i++)
        sum += 1;
    System.out.println(sum);
}
</code></pre>

<p>此程序运行起来与预计的要慢一些，因为它将一个局部变量（sum）声明为时装箱类型 Long，而不是基本类型 long。程序编译起来没有错误或警告，变量被反复地拆箱和装箱，导致明显的性能下降。</p>

<h4 id="toc_3">什么时候应该使用装箱基本类型：</h4>

<ol>
<li>作为集合中得元素、键和值。集合中不能存放基本类型，因此必须使用装箱基本类型。</li>
<li>在参数化类型和方法中，必须使用装箱基本类型作为类型参数，因为 Java 不允许使用基本类型。例 ThreadLocal&lt;Integer&gt;</li>
<li>在进行反射得方法调用时，必须使用装箱基本类型。</li>
</ol>

<p>当可以选择的时候，基本类型要优于装箱基本类型。基本类型更加简单，也更加快速。使用装箱基本类型时，要特别小心，<strong>自动装箱减少了使用装箱基本类型的烦琐性，但是并没有减少它的风险</strong>。当程序用 == 操作符比较两个装箱基本类型时，它做了统一性比较，这也许并不是你想要的。当程序进行设计装箱和拆箱基本类型的混合类型计算时，它会进行拆箱，当程序进行拆箱时，会抛出 <em>NullPointerException</em> 异常。最后，当程序装箱了基本类型值时，会导致较高的资源消耗和不必要的对象创建。</p>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-js " style="padding-bottom:1em;">

        <div id="java_collections"></div>
        <span class="hidden" itemprop="alternateName">java_collections</span>

        <h2>
            <a itemprop="url" href="#java_collections">
                <span itemprop="name">Java collections</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/java_collections.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">js</span>
        

        <div itemprop="description">
            

<h3 id="toc_0">标准库中的集合与映射</h3>

<h4 id="toc_1">关于 Set 接口</h4>

<p>Set 接口代表不允许重复元的 Collection。由接口 SortedSet 给出的一种特殊类型的 Set 保证其中的各项处于有序的状态。因为一个</p>

<p>Set IS-A Collection，所以用于访问继承 Collection 的 List 的项的方法也对 Set 有效。</p>

<p>由 Set 所要求的一些特殊的操作是一些插入，删除以及（有效地）执行基本查找的能力。对于 Set，add 方法如果执行成功则返回 true，否则返回 false，因为被添加的项已经存在。保持各项以有序状态的 Set 的实现是 TreeSet。TreeSet 类的基本操作花费对数最坏情形时间。</p>

<p>默认情况下，排序假设 TreeSet 中的项实现 Comparable 接口。另一种排序可以通过用 Comparator 实例化 TreeSet 来确定。例如，可以创建一个存储 String 对象的 TreeSet，通过使用 CaseInsensitiveCompare 函数对象忽略大小写。下面代码中，Set s 大小为1。</p>

<pre><code class="java">Class CaseInsensitiveCompare implements Comparator&lt;String&gt; {
    public int compare(String lhs, String rhs) {
        return lhs.compareToIgnoreCase(rhs);
    }
}

Set&lt;String&gt; s = new TreeSet&lt;&gt;(new CaseInsensitiveCompare());
s.add(&quot;Hello&quot;);
s.add(&quot;HeLLo&quot;);
System.out.print(&quot;The size is: &quot; + s.size());
</code></pre>

<h4 id="toc_2">关于 Map 接口</h4>

<p>Map 是一个接口，代表由键以及值组成的一些项的集合。键唯一。在 SortedMap 接口中，映射中的关键字保持逻辑上有序状态。SortedMap 接口的一种实现是 TreeMap 类。Map的基本操作包括诸如 isEmpty、clear、size 等方法，而且最重要的是包含以下方法：</p>

<pre><code class="java">boolean containsKey(keyType key);
ValueType get(keyType key);
ValueType put(KeyType key, ValueType value);
</code></pre>

<p>get 返回 Map 中与 key 相关的值，或当 key 不存在时返回 null。如果在 Map 中不存在 null 值，那么由 get 返回的值可以用来确定 key 是否存在 Map 中。然而，如果存在 null，那么必须使用 containsKey。方法 put 把键值对置入 Map 中，或者返回 null，或者返回与key 相联系的值。</p>

<p>通过一个 Map 进行迭代要比 Collection 复杂，因为 Map 不提供迭代器，而是根据 3 种方法，将 Map 对象的视图作为 Collection 对象返回。由于这些视图本身就是 Collection，因此它们可以被迭代。所提供的 3 种方法如下：</p>

<pre><code class="java">Set&lt;KeyType&gt; keySet();
Collection&lt;ValueType&gt; values();
Set&lt;Map.Entry&lt;KeyType, ValueType&gt;&gt; entrySet()
</code></pre>

<p>方法 keySet 和 values 返回简单的集合（键不包含重复元，因此以一个 Set 对象的形式返回）。entrySet 方法是作为一些项而形成的 Set 对象被返回的（由于键唯一，因此不存在重复项）。每一项均由被嵌套的接口 Map.Entry 表示。对于类型 Map.Entry 的对象，其现有的方法包含访问键、键的值、以及改变键对应的值：</p>

<pre><code class="java">KeyType getKey();
ValueType getValue();
ValueType setValue(ValueType newValue);
</code></pre>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-python " style="padding-bottom:1em;">

        <div id="py_dict"></div>
        <span class="hidden" itemprop="alternateName">py_dict</span>

        <h2>
            <a itemprop="url" href="#py_dict">
                <span itemprop="name">Python Dict</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/py_dict.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">python</span>
        

        <div itemprop="description">
            

<p><font color=red>散列表</font>是字典类型性能出众的根本原因</p>

<p>字典提供了多种构造函数 点击<a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict">Built-in Types</a> 有例子说明创建字典的不同形式</p>

<pre><code class="python">&gt;&gt;&gt; a = dict(one=1, two=2, three=3)
&gt;&gt;&gt; b = {'one': 1, 'two': 2, 'three': 3}
&gt;&gt;&gt; c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
&gt;&gt;&gt; d = dict([('two', 2), ('one', 1), ('three', 3)])
&gt;&gt;&gt; e = dict({'three': 3, 'one': 1, 'two': 2})
&gt;&gt;&gt; a == b == c == d == e
True
</code></pre>

<h5 id="toc_0">字典推导</h5>

<p>自python 2.7以来，列表和生成器表达式的概念移植到字典上,从而有个字典推导（后面还会看到集合推到）</p>

<p>字典推导（dictcomp）可以从<font color=red>任何以键值对作为元素的可选迭代对象</font>中构建字典</p>

<p>下例展示利用字典推导可以把一个装满元组的列表变成两个不同的字典。</p>

<pre><code class="python">&gt;&gt;&gt; simple_list = [
    (1, 'a'),
    (2, 'b'),
    (3, 'c'),
    (4, 'd'),
    (5, 'e'),
    (6, 'f'),
    (7, 'g'),
]

&gt;&gt;&gt; res = {num: char for char num in simple_list}
&gt;&gt;&gt; res
{'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7}

&gt;&gt;&gt; {num: char.upper() for char, code in res.items() if num &lt; 4}
{1: 'a', 2: 'b', 3: 'c'}
</code></pre>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-python " style="padding-bottom:1em;">

        <div id="py_summary"></div>
        <span class="hidden" itemprop="alternateName">py_summary</span>

        <h2>
            <a itemprop="url" href="#py_summary">
                <span itemprop="name">Python Summary</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/py_summary.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">python</span>
        

        <div itemprop="description">
            

<h4 id="toc_0">字面量与构造方法</h4>

<h5 id="toc_1">1. 字典</h5>

<p>（1）字面量</p>

<pre><code class="python">lover = {'name': 'zxl', 'age': 18}
</code></pre>

<p>（2）构造方法
~~~python
lover = dict(&lsquo;name&rsquo;=&lsquo;zxl&rsquo;, &lsquo;age&rsquo;=18)
      = dict(zip([&lsquo;name&rsquo;, &lsquo;age&rsquo;,], [&lsquo;zxl&rsquo;, 18]))
      = dict([(&lsquo;name&rsquo;, &lsquo;zxl&rsquo;), (&lsquo;age&rsquo;, 18)])
      = dict({&lsquo;name&rsquo;: &lsquo;zxl&rsquo;, &lsquo;age&rsquo;: 18})
~~~</p>

<h5 id="toc_2">2. 集合</h5>

<p>（1）字面量(set)</p>

<pre><code class="python">fav_player = {'kobe', 'lebra'}
</code></pre>

<p>（2）构造方法</p>

<pre><code class="python">fav_player = set({'kobe', 'lebra'})
</code></pre>

<p>frozenset没有字面量句法</p>

<pre><code class="python">fav_player = frozenset({'kobe', 'lebra'})
</code></pre>

<p>空集合必须写成 set()，{}只会表示为空字典</p>

<pre><code class="python">empty_set = set()
</code></pre>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-python " style="padding-bottom:1em;">

        <div id="py_set"></div>
        <span class="hidden" itemprop="alternateName">py_set</span>

        <h2>
            <a itemprop="url" href="#py_set">
                <span itemprop="name">Python Set</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/py_set.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">python</span>
        

        <div itemprop="description">
            

<p>&ldquo;集&rdquo; 这个概念在Pyhton中算是比较年轻的，同时使用率也较低。set和它的不可变姊妹类型frozenset直到Pyhton2.3才首次以模块的形式出现，然后在Python2.6中它们升级成为内置类型</p>

<p>集合的本质是<font color=red>许多唯一对象</font>的集合。因此，集合可以去重：</p>

<pre><code class="python">&gt;&gt;&gt; l = ['spam', 'spam', 'eggs', 'spam']
&gt;&gt;&gt; set(l)
&gt;&gt;&gt; {'eggs', 'spam'}
&gt;&gt;&gt; list(set(l))
&gt;&gt;&gt; ['eggs', 'spam']
</code></pre>

<p>集合中的元素必须是<font color=red>可散列</font>的，set类型本身是不可散列的，但是frozenset可以。因此可以创建一个包含不同frozenset的set。</p>

<p>除了保证唯一性，集合还实现了很多基础的中缀运算符。给定两个集合a和b, <strong>a|b</strong> 返回的是它们的<strong>合集</strong>，</p>

<p><strong>a &amp; b</strong>得到的是<strong>交集</strong>，而a - b得到的是<strong>差集</strong>。合理地利用这些操作，可使代码行数变少，还能减少Python程序的运行时间。亦可使代码更易读，从而更容易判断程序的正确性，因为利用这些运算符可以省去不必要的循环和逻辑操作。</p>

<p>例1：needles中元素在haystack里出现次数，两个变量都是set类型。</p>

<pre><code class="python">found = len(needles &amp; haystack)
</code></pre>

<p>例2：for循环实现。</p>

<pre><code class="python">found =  0
for n in needles
    if n in haystack
        found += 1
</code></pre>

<p>例1比例2速度要快一些，另一方面，例2可以用在任何可迭代对象上，例1则要求两者皆为集合。若没有集合，可随时建立集合，如例3所示。</p>

<p>例3：转化为set进行交集操作</p>

<pre><code class="python">found = len(set(needles) &amp; set(haystack))
</code></pre>

<p>另一种写法</p>

<pre><code class="python">found = len(set(needles).intersection(haystack))
</code></pre>

<p>例3写法会牵制到把对象转化为集合的成本，不过如果 needles 或 haystack 中任一为集合，那么例3的方案比例2更高效。</p>

<p>以上所有例子的运行时间都能在3毫秒左右，在含有10000000个元素的haystack里搜索1000个值，算下来大概时每个元素3微妙。</p>

<p>除了速度极快的查找功能（这归功于背后的散列表），内置的 set 和 frozenset 提供了丰富的功能和操作，不但让创建集合的方式丰富多彩，且对于 set 来讲，我们还可以对集合里已有的元素进行修改。在讨论操作之前，先看下相关的句法。</p>

<h3 id="toc_0">集合字面量</h3>

<p>除空集之外，集合的字面量——{1}、{1, 2}，等到——看起来与数学形式一摸一样。若是空集，则必须写成set()的形式</p>

<p>tip：创建空集，必须使用不带任何参数的构造方法 set()，如果只写成 {} 的形式，跟以前一样，你创建的其实是个空字典</p>

<p>在python3中，除了空集，集合的字符串表示形式总是以 {&hellip;} 的形式出现。</p>

<p>字面量句法 {1, 2, 3} 相比构造方法 (set([1, 2, 3])) 要更快更易读，后者的速度要慢一些，因为Pyhton 必须先从这个名字来查询构造方法，然后新建一个列表，最后再把这个列表传入到构造方法中，但如果是字面量的形式，Python会利用一个专门的叫做 BUILD_SET 的字节码来创建集合。</p>

<p>​</p>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-js " style="padding-bottom:1em;">

        <div id="js_websocket"></div>
        <span class="hidden" itemprop="alternateName">js_websocket</span>

        <h2>
            <a itemprop="url" href="#js_websocket">
                <span itemprop="name">Js WebSocket</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/js_websocket.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">js</span>
        

        <div itemprop="description">
            

<p>web socket（套接字）的目标是通过一个长时连接实现与服务器全双工、双向的通信。在js中创建web socket时，一个HTTP请求会发送到服务器以初始化连接。服务器响应后，连接使用HTTP的Upgrade头部从HTTP协议切换到Web Socket协议。这意味着Web Socket不能通过标准Http服务器实现，而必须使用支持该协议的专有服务器。</p>

<p>因为Web Socket使用了自定义协议，所以URL方案（scheme）稍有变化：不能再使用http://或https://，而要使用ws://和wss://。前者是不安全的连接，后者是安全连接。在指定 Web Socket  URL时，必须包含URL方案，因为将来有可能支持其他方案。</p>

<p>使用自定义协议而非HTTP协议的好处是，客户端与服务器之间可以发送非常少的数据，不会对HTTP造成任何负担。使用更小的数据包让Web Socket非常适合带宽和延迟问题比较明显的移动应用。缺点是，定义协议的时间比定义Javascript API要长。Web Socket得到了所有浏览器的支持。</p>

<h3 id="toc_0">API</h3>

<p>创建一个新的 Web Socket，就要实例化一个WebSocket 对象并传入提供连接的URL</p>

<pre><code class="javascript">let socket = new WebSocket(&quot;ws://www.example.con/server.php&quot;)
</code></pre>

<p>　　tip: 必须给WebSocket构造函数传入一个绝对URL。同源策略不适用于WebSocket，因此可以打开到任意站点的连接。至于是否与特定源的页面通信，则完全取决于服务器（在握手阶段就可以确定请求来自哪里）</p>

<p>浏览器会在初始化 WebSocket 对象之后立即创建连接。与XHR类似，WebSocket 也有一个readyState 属性表示当前状态。不过，这个值与XHR中的值不一样。</p>

<ul>
<li>WebSocket.OPENING（0）：连接正在建立。</li>
<li>WebSocket.OPEN（1）：连接已经建立。</li>
<li>WebSokket.CLOSING（2）：连接正在关闭。</li>
<li>WebSocket.CLOSE（3）：连接已经关闭。</li>
</ul>

<p>WebSocket 对象没有 readystatechange 事件，而是有与上述不同状态对应的其他事件。readyState值从0开始。</p>

<p>任何时候都可以调用 close() 方法关闭Web Socket连接：</p>

<pre><code class="javascript">socket.close()
</code></pre>

<h3 id="toc_1">发送和接受数据</h3>

<p>打开Web Socket 之后，可通过连接发送和接收数据。要向服务器发送数据，使用send() 方法并传入一个字符串、ArrayBuffer 或 Blob，如下所示：</p>

<pre><code class="javascript">let socket = new WebSocket(&quot;ws://www.example.con/server.php&quot;)

let stringData = &quot;Hello World!&quot;
let arrayBufferData = Uint8Array.from['f', 'o', 'o']
let blobData = new Blob(['f', 'o', 'o'])

socket.send(stringData)
socket.send(arrayBufferData.buffer)
socket.send(blobData)
</code></pre>

<p>服务器向客户端发送消息时，WebSocket 对象上会触发message事件。这个message事件与其他消息协议类似，可以通过event.data属性访问到有效载荷：</p>

<pre><code class="javascript">socket.onmessage = function(event) {
    let data = event.data
    // 对数据执行某些操作
}
</code></pre>

<p>与通过send()方法发送的数据类似，event.data返回的数据也可能是ArrayBuffer 或 Blob。这由 WebSocket 对象的 binaryType 属性决定，该属性可能是&rdquo;blob&rdquo;或&rdquo;arraybuffer&rdquo;。</p>

<h5 id="toc_2">其他事件</h5>

<p>websocket 对象在连接周期中可能触发3个其他事件。
- open：在连接成功建立时触发。
- error：在发生错误时触发。连接无法续存。
- close：在连接关闭时触发。</p>

<p>WebSocket 对象不支持 DOM Level 2事件监听器，因此需要使用DOM Level 0风格的事件处理程序来监听这些事件：</p>

<pre><code class="javascript">let socket = new WebSocket(&quot;ws://www.example.con/server.php&quot;)
socket.onopen = function() {
    alert(&quot;Connection established.&quot;)
}
socket.onerror = function() {
    alert(&quot;Connection error.&quot;)
}
socket.oncloes = function() {
    alert(&quot;Connection closed.&quot;)
}
</code></pre>

<p>在这些事件中，只有 close 事件的 event 对象上有额外信息。此对象上有3个额外属性：wasClean、code 和 reason。其中，weaClean 是一个布尔值，表示连接是否干净地关闭；code 是一个来自服务器的数值状态码；reason 是一个字符串，包含服务器发来的消息。可以将这些信息显示给用户或记录到日志:</p>

<pre><code class="javascript">socket.onclose = function(event) {
    console.log('as clean? $(event.wasClean) code=${event.code) Rason = ${event.reason}')
}
</code></pre>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-js " style="padding-bottom:1em;">

        <div id="js_module"></div>
        <span class="hidden" itemprop="alternateName">js_module</span>

        <h2>
            <a itemprop="url" href="#js_module">
                <span itemprop="name">Js Module</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/js_module.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">js</span>
        

        <div itemprop="description">
            

<h3 id="toc_0">使用ES6模块</h3>

<p>ES6 最大的一个改进就是引入模块规范，这个规范全方位简化了之前出现的模块加载器，原生浏览器都支持意味着加载器及其他预处理都不再必要。从很多方面看，ES6 模块系统是集 AMD 和 CommonJS 之大成者。</p>

<h4 id="toc_1">模块标签及定义</h4>

<p>ECMAScript 6 模块是作为一整块 JavaScript 代码而存在的。带有 type=&ldquo;module&rdquo; 属性的 &lt;script&gt; 标签会告诉浏览器相关代码应该作为模块执行，而不是作为传统的脚本执行。模块可以嵌入在网页中，也可以作为外部文件引入：</p>

<pre><code class="javascript">&lt;script type=&quot;module&quot;&gt;
  // 模块代码
&lt;/script&gt;

&lt;script type=&quot;module&quot; src=&quot;path/to/myModule.js&quot;&gt;&lt;/script&gt;
</code></pre>

<p>即使与常规的 JavaScript 文件处理方式不同，Javascript 模块文件也没有专门的内容类型。</p>

<p>与传统脚本不同，所有模块都会像 &lt;script defer&gt; 加载的脚本一样按顺序执行。解析到 &lt;script type=&ldquo;module&rdquo;&gt; 标签后会立即下载模块文件，但执行会延迟到文档解析完成。无论对嵌入的模块代码，还是引入的外部模块文件，都是这样。&lt;script type=&ldquo;module&rdquo;&gt; 在页面中出现的顺序就是它们的执行顺序。与 &lt;script defer&gt; 一样，修改模块标签的位置，无论是在 &lt;head&gt; 还是在 &lt;body&gt; 中，只会影响文件什么时候加载，而不会影响模块什么时候加载。</p>

<p>下面演示了嵌入模块代码的执行顺序：</p>

<pre><code class="javascript">&lt;!-- 第二个执行 --&gt;
&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;

&lt;!-- 第三个执行 --&gt;
&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;

&lt;!-- 第一个执行 --&gt;
&lt;script&gt;&lt;/script&gt;
</code></pre>

<p>另外，可以改为外部 JS 模块定义：</p>

<pre><code class="javascript">&lt;!-- 第二个执行 --&gt;
&lt;script type=&quot;module&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;

&lt;!-- 第三个执行 --&gt;
&lt;script type=&quot;module&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;

&lt;!-- 第一个执行 --&gt;
&lt;script&gt;&lt;/script&gt;
</code></pre>

<p>也可以给模块标签添加 async 属性。这样影响就是双重的；不仅模块执行顺序不在与 &lt;script&gt; 标签在页面中的顺序绑定，模块也不会等待文档完成解析才执行。不过，入口模块仍必须等待其他依赖加载完成。</p>

<p>与 &lt;script type=&ldquo;module&rdquo;&gt; 标签关联的 ES6 模块被认为是模块图中的入口模块。一个页面上有多少个入口模块没有限制，吃哦宁国府加载同一个模块也没有限制。同一个模块无论在一个页面中被加载多少次，也不管它是如何加载的，实际上都只会加载一次。</p>

<pre><code class="javascript">&lt;-- moduleA 在这个页面只会被加载一次 --&gt;

&lt;script type=&quot;module&quot;&gt;
  improt './moduleA.js'
&lt;/script&gt;
&lt;script type=&quot;module&quot;&gt;
  improt './moduleA.js'
&lt;/script&gt;
&lt;script type=&quot;module&quot; src=&quot;./moduleA.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;module&quot; src=&quot;./moduleA.js&quot;&gt;&lt;/script&gt;
</code></pre>

<p>嵌入的模块定义代码不能使用 import 加载到其他模块。只有通过外部文件加载的模块才可以使用 import 加载。因此，嵌入模块只适合作为入口模块。</p>

<h4 id="toc_2">模块加载</h4>

<p>ESMAScript6 模块的独特之处在于，既可以通过浏览器原生加载，也可以与第三方加载器和构建工具一起加载。有点浏览器还没有原生支持 ES6 模块，因此可能还需要第三方工具。事实上，很多时候使用第三方工具可能会更方便。</p>

<p>完全支持 ESMAScript6 模块的浏览器可以从顶级模块加载整个依赖图，且是异步完成的。浏览器会解析入口模块。确定依赖。并发送对依赖模块的请求，这些文件通过网络返回后，浏览器就会解析它们的内容、确定它们的依赖、如果这些耳机依赖还没有加载，则会发送更多请求。这个异步递归加载过程会持续到整个应用程序的依赖图都解析完成。解析完依赖图，应用程序就可以正式加载模块了。</p>

<h3 id="toc_3">模块行为</h3>

<p>ESMAScript6 模块借用了 CommanJS 和 AMD 的很多优秀特征。下面简单列举一些</p>

<ul>
<li>模块代码只在加载后执行。</li>
<li>模块只能加载一次。</li>
<li>模块是单例。</li>
<li>模块可以定义公共接口，其他模块可以基于这个公共接口观察和交互。</li>
<li>模块可以请求加载其他模块。</li>
<li>支持循环依赖。</li>
</ul>

<p>ES6 模块系统也增加了一些新行为。</p>

<ul>
<li>ES6 模块默认在严格模式下执行。</li>
<li>ES6 模块不共享命名空间。</li>
<li>模块顶级 this 的值是 undefined（常规脚本中是 window）。</li>
<li>模块中的 var 声明不会添加到 window 对象。</li>
<li>ES6 模块是异步加载和执行的。</li>
</ul>

<p>浏览器运行时在知道应该把某个文件当成模块，会有条件地按照 ESMAScript6 模块行为来施加限制。与&lt;script type=&ldquo;module&rdquo;&gt;关联或者通过 import 语句加载的 JavaStript 文件会被认定为模块。</p>

<h3 id="toc_4">模块导出</h3>

<p>ES6 模块的公共导出系统与 CommonJS 非常相似。控制模块的哪些行为对外部可见的是 export 关键字。ES6 模块支持两种导出：命名导出和默认导出。不同的导出方式对应不同的导入方式。</p>

<p>export 关键字用于声明一个值为命名导出。导出语句必须在模块顶级，不能嵌套在某个块中：</p>

<pre><code class="javascript">// 允许
export ...

// 不允许
if (condition) {
    export ...
}
</code></pre>

<p>导出值对模块内部 JavaScript 的执行没有直接影响，因此 export 语句与导出值的相对位置或者 export 关键字在模块中出现的顺序没有限制。export 语句甚至可以出现在它要导出的值之前：</p>

<pre><code class="javascript">// 允许
const foo = 'foo'
export { foo }

// 允许
export const foo = 'foo'

// 允许，但应该避免
export { foo }
const foo = 'foo'
</code></pre>

<p>命名导出（named export）就好像模块是被导出值得容器。行内命名导出，即可以在同一行执行变量声明。下面展示了一个声明变量同时又导出变量得例子。外部模块可以导入这个模块，而 foo 将称为这个导入模块的一个属性</p>

<pre><code class="javascript">export const foo = 'foo'
</code></pre>

<p>变量声明跟导出可以不在同一行。可以在 export 子句中执行声明并将标识符导出到模块的其他地方：</p>

<pre><code class="javascript">export { foo }
const foo = 'foo'
</code></pre>

<p>导出时也可以提供别名，别名必须在 export 子句的大括号语法中指定。因此，声明值、导出值和为导出值提供别名不能在一行完成。在下面例子中，导入这个模块的外部模块可以使用 myFoo 访问导出的值：</p>

<pre><code class="javascript">const foo = 'foo'
export { foo as myFoo }
</code></pre>

<p>因为 ES6 命名导出可以将模块做为容器，所以可以在一个模块中声明多个命名导出。导出的值可以在导出语句中声明，也可以在导出之前声明：</p>

<pre><code class="javascript">export const foo = 'foo'
export const bar = 'bar'
export const baz = 'baz'
</code></pre>

<p>ES6 模块也支持对导出声明分组，可以同时为部分或全部导出值指定别名：</p>

<pre><code class="javascript">const foo = 'foo'
const bar = 'bar'
const baz = 'baz'
export { foo, bar as myBar, baz}
</code></pre>

<p><strong>默认导出</strong>（default export）就好像模块与被导出的值时一回事。默认导出使用 default 关键字将一个值声明为默认导出，每个模块只能有一个默认导出。重复的默认导出会导致 SyntaxError</p>

<p>下面定义一个默认导出，外部模块可以导入这个模块，而这个模块本身就是 foo 的值：</p>

<pre><code class="javascript">const foo = 'foo'
export default foo
</code></pre>

<p>另外，ES6 模块会识别作为别名提供的 default 关键字。此时，虽然对应的值是使用命名语句导出的，实际上则会成为默认导出：</p>

<pre><code class="javascript">const foo = 'foo'

// 等同于 export default foo
export { foo as default }
</code></pre>

<p>因为命名导出和默认导出不会冲突，所以 ES6 支持在一个模块中同时定义这两种导出：</p>

<pre><code class="javascript">const foo = 'foo'
const bar = 'bar'

export { bar }
export default foo
</code></pre>

<p>这连个 export 语句可以组合为一行：</p>

<pre><code class="javascript">const foo = 'foo'
const bar = 'bar'

export { foo as default, bar }
</code></pre>

<p>ES6 规范对不同形式的 export 语句中可以使用什么不可以使用什么规范了限制。某些形式允许声明和赋值，某些形式只允许表达式，而某些形式则只允许简单标识符。注意，有的形式使用了分号，有的则没有：</p>

<pre><code class="javascript">// 命名行内导出
export const baz = 'baz'
export const foo = 'foo', bar = 'bar'
export function foo() {}
export function* foo() {}
export class Foo {}

// 命名子句导出
export { foo }
export { foo, bar }
export { foo as myFoo, bar }

// 默认导出
export default 'baz'
export default { foo: 'foo'}
export default { foo, bar as default }
export default foo
export default function() {}
export default function foo() {}
export default function*() {}
export default class {}

// 会导致错误的不同形式：

// 行内默认导出中不能出现变量声明
export default const foo = 'bar'

// 只有标识符可以出现在 export 子句中出现
export { 123 as foo }

// 别名只能在 export 子句中出现
export const foo = 'foo' as myFoo
</code></pre>

<p>注意：什么可以或不可以与 export 关键字出现在同一行可能很难记住。一般来说，声明、赋值和导出标识符最好分开。这样就不容易搞错了，同时也可以让 export 语句集中在一起。</p>

<h3 id="toc_5">模块导入</h3>

<p>模块可以通过使用 import 关键字使用其他模块导出的值。与 export 类似，import 必须出现在模块的顶级：</p>

<pre><code class="javascript">// 允许
import ...

// 不允许
if (condition) {
    import ...
}
</code></pre>

<p>import 语句被提升到模块顶部。因此，与 export 关键字类似，import 语句与使用导入值得语句的相对位置并不重要。不过，还是推荐把导入语句放在模块顶部</p>

<pre><code class="javascript">// 允许
import { foo } from './fooModule,js'
console.log(foo) // 'foo'

// 允许，但应该避免
console.log(foo) // foo
import { foo } from './fooModule,js'
</code></pre>

<p>模块标识符可以是相对于当前模块的相对路径，也可以是指向模块文件的绝对路径。它必须是纯字符串，不能是动态计算的结果。例如：不能是拼接的字符串。</p>

<p>如果在浏览器中通过标识符原生加载模块，则文件必须带有 .js 扩展名，不然可能无法正确解析。不过，如果是通过构建工具或第三方模块加载器打包或解析的 ES6 模块，则可能不需要包含文件扩展名。</p>

<pre><code class="javascript">// 解析为 /components/bar.js
import ... from './bar.js'

// 解析为 /bar.js
import ... from '../bar.js'

// 解析为 /bar.js
import ... from '/bar.js'
</code></pre>

<p>不是必须通过导出的成员才能导入模块。如果不需要模块的特定导出，但仍想加载和执行模块以利用其副作用，可以只通过路径加载它：</p>

<pre><code class="javascript">import './foo.js'
</code></pre>

<p>导入对模块而言是只读的，实际上相当于 const 声明的变量。</p>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-js " style="padding-bottom:1em;">

        <div id="js_storage"></div>
        <span class="hidden" itemprop="alternateName">js_storage</span>

        <h2>
            <a itemprop="url" href="#js_storage">
                <span itemprop="name">Js Storage</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/js_storage.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">js</span>
        

        <div itemprop="description">
            

<p>cookie、浏览器存储API，IndexedDB</p>

<h4 id="toc_0">背景：</h4>

<p>直接在客户端存储用户信息出于用户想要将与自身有关的信息保存在用户的机器上。无聊是登录信息、个人偏好，还是其他数据。Web应用程序提供者需要将它们保存在用户的机器上。对此第一个解决方案就是cookie。cookie是古老的网景公司发明，由一份名为 <em>Persistent Client State: HTTP Cookies</em> 的规范定义。今天 cookie 只是在客户端存储数据的一个选项。</p>

<h4 id="toc_1">1. cookie</h4>

<p>HTTP cookie 通常也叫做 cookie，最初用于在客户端存储会话信息。这个规范要求服务器在响应 HTTP 请求时，通过发送 Set-Cookie HTTP 头部包含会话信息。例下面是包含这个头部的一个 HTTP 响应：</p>

<pre><code>HTTP/1.1 200 OK
Content-type: text/html
Set-Cookie: name=value
Other-header: other-header-value
</code></pre>

<p>这个 HTTP 响应会设置一个名为&rdquo;name&rdquo;，值为&rdquo;value&rdquo;的 cookie。键和值在发送时都会经过 URL 编码。浏览器会存储这些会话信息，并在之后的每个请求中都会通过 HTTP 头部 cookie 再将它们发回服务器，比如：</p>

<pre><code>GET /index.js HTTP/1.1
Cookie: name=value
Other-header: other-header-value
</code></pre>

<p>这些发送回服务器的额外信息可用于唯一标识发送请求的客户端。</p>

<h4 id="toc_2">2. 限制</h4>

<p>cookie 是与特定域绑定的。设置 cookie 后，它会与请求一起发送到创建它的域。这个限制能保证 cookie 中存储的信息只对认可的接收者开放，不被其他域访问。</p>

<p>因为 cookie 存储在客户端机器上，所以为保证它不会被恶意利用，浏览器会施加限制。同时，cookie 也不会占用太多磁盘空间。通常，只要遵守以下大致的限制，就不会在任何浏览器中碰到问题</p>

<ul>
<li>不超过 300 个 cookie；</li>
<li>每个 cookie 不超过 4096 字节；</li>
<li>每个域不超过 20 个 cookie；</li>
<li>每个域不超过 81920 字节。</li>
<li>每个域能设置的 cookie 总数也是受限的，但不同浏览器的限制不同</li>
</ul>

<p>Safari 和 Chrome 对每个域的 cookie 数没有硬性限制。</p>

<p>如果 cookie 总数超过单个域的上限，浏览器就会删除之前设置的 cookie。</p>

<h3 id="toc_3">Web Storage</h3>

<p>Web Storage 的目的是解决通过客户端存储不需要频繁发送回服务器的数据时使用 cookie 的问题。</p>

<p>Web Storage 规范最新的版本是第2版，这一版规范主要有两个目标：</p>

<ul>
<li><p>提供在 cookie 之外的存储会话数据的途径；</p></li>

<li><p>提供跨会话持久化存储大量数据的机制。</p></li>
</ul>

<p>web storage 的第2版定义了两个对象：localStorage 和 sessionStorage。localStorage 是 <strong>永久存储机制</strong>，sessionStorage 是<strong>跨会话</strong>的存储机制。这两种浏览器 API 提供了在浏览器中不受页面刷新影响而存储数据的两种方式。2009年之后所有主要供应商发布的浏览器版本在window 对象上支持 localStorage 和 sessionStorage。（web storage 第一版曾用过 globalStorage，不过现已废弃）。</p>

<h4 id="toc_4">Storage 类型</h4>

<p>Storage 类型用于保存键值对数据，直到存储空间上限（由浏览器决定）。Storage 的实例与其他对象一样，但增加了以下方法</p>

<ul>
<li>clear()：删除所有值，不在 Firefox 中实现。</li>
<li>getItem(<em>name</em>)：取得给定 <em>name</em> 的值。</li>
<li>key(<em>index</em>)：取得给定数值位置的名称。</li>
<li>removeItem(<em>name</em>)：删除给定的 <em>name</em> 的键值对。</li>
<li>setItem(<em>name</em>, <em>value</em>)：设置给定 <em>name</em> 的值。</li>
</ul>

<p>getItem() 、remove() 和 setItem() 方法可以直接或间接通过 Storage 对象调用。因为每个数据项都作为属性存储在该对象上。所以可以使用点或方括号访问这些属性，通过同样操作来设置值，也可以使用 delete 操作符删除属性。即便如此，通常还是建议使用方法而非属性来执行这些操作，以免意外重写某个已存在的对象成员。</p>

<p>通过 length 属性可以确定 Storage 对象中保存了多少键值对。我们无法确定对象中所有数据占用的空间大小，尽管 IE8 提供了 remainingSpace 属性用于确定还有多少存储空间（以字节计）可用。</p>

<p>Storage 类型只能存储<strong>字符串</strong>。非字符串数据在存储之后会自动转换为字符串。注意，这种转换不能在获取数据时撤销。</p>

<h4 id="toc_5">SessionStorage</h4>

<p>SessionStorage 对象只存储<strong>会话信息</strong>，即数据只会存储到浏览器关闭。这跟浏览器关闭时会消失的会话 cookie 类似。存储在 SessionStorage 中的数据不受页面刷新影响，可以在浏览器崩溃并重启后恢复。（取决于浏览器，Firefox 和 WebKit支持，IE不支持）</p>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-spring " style="padding-bottom:1em;">

        <div id="spring_yml"></div>
        <span class="hidden" itemprop="alternateName">spring_yml</span>

        <h2>
            <a itemprop="url" href="#spring_yml">
                <span itemprop="name">Spring YML</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/spring_yml.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">spring</span>
        

        <div itemprop="description">
            

<h3 id="toc_0">数据格式</h3>

<h4 id="toc_1">基本类型</h4>

<pre><code class="yaml">name: taicang
age: 18
</code></pre>

<h4 id="toc_2">键值对</h4>

<pre><code class="yaml">person:
    name: taicang
    age: 18
</code></pre>

<h4 id="toc_3">数组</h4>

<pre><code class="yaml">favplayer:
    - kobe
    - lebra
</code></pre>

<h3 id="toc_4">读取方式</h3>

<h4 id="toc_5">@Value</h4>

<pre><code class="yaml">server:
    port: 8080
</code></pre>

<pre><code class="java">@Value(&quot;${server.port}&quot;)
private String port
</code></pre>

<h4 id="toc_6">ConfigurationProperties</h4>

<pre><code class="yaml">student:
    name: jackma
    age: 18
</code></pre>

<p>javabean（需prefix (前缀) 参数）</p>

<pre><code class="java">@Component
@Lombok
@ConfigurationProperties(prefix = &quot;student&quot;)
public class Student {
    private String name;

    private Integer age;
}
</code></pre>

<h4 id="toc_7">Environment</h4>

<pre><code class="yaml">mes:
    url: xxxxxxx
</code></pre>

<pre><code class="java">@Resource
private Environment env;

@GetMapping(&quot;/mes&quot;)
public String getMesUrl() {
    String url = env.getProperty(&quot;mes.url&quot;);
    
    return url;
}
</code></pre>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-spring " style="padding-bottom:1em;">

        <div id="spring_swagger"></div>
        <span class="hidden" itemprop="alternateName">spring_swagger</span>

        <h2>
            <a itemprop="url" href="#spring_swagger">
                <span itemprop="name">Spring Swagger</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/spring_swagger.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">spring</span>
        

        <div itemprop="description">
            

<h3 id="toc_0">配置 Swagger</h3>

<h4 id="toc_1">1）添加 Swagger 依赖</h4>

<pre><code class="xml">&lt;!--Swagger 依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.springfox&lt;/groupId&gt;
    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
    &lt;version&gt;3.0.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--Swagger-UI 依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.springfox&lt;/groupId&gt;
    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
    &lt;version&gt;3.0.0&lt;/version&gt;
&lt;/dependency&gt;

</code></pre>

<h4 id="toc_2">2）创建 Swagger 配置类</h4>

<pre><code class="java">/**
 * Swagger 配置文件
 */
@Configuration
public class SwaggerConfig {
    @Bean
    public Docket createRestApi() {
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.basePackage(&quot;com.example.demo.controller&quot;))

                .paths(PathSelectors.any())
                .build();
    }

    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title(&quot; RESTful APIs&quot;)
                .description(&quot;RESTful APIs&quot;)
                .termsOfServiceUrl(&quot;http://localhost:8080/&quot;)
                .contact(&quot;long&quot;)
                .version(&quot;1.0&quot;)
                .build();
    }
}
</code></pre>

<p><code>@Configuration</code> ：让 spring 来加载该类配置</p>

<p><code>@EnableSwagger2</code> ：启用 Swagger2.createRestApi 函数创建 Docket 的 Bean</p>

<p><code>apiInfo()</code> ：用来展示该 API 的基本信息</p>

<p><code>select()</code> ：返回一个 ApiSelectorBuilder 实例，用来控制哪些接口暴露给 Swagger 来展示</p>

<p><code>api(RequestHandlerSelectors.basePackage())</code> ：配置包扫描路径。Swagger 会扫描包下面所有 Controller 定义的 API，并产生文档内容。如果不想产生 API，则使用注解 @Apilgnore</p>

<h4 id="toc_3">3）编写接口文档</h4>

<p><code>@Api</code> ：描述类/接口的主要路径</p>

<p><code>@ApiOperation</code> ：描述方法用途，给 API 增加说明</p>

<p><code>@ApiImplicitParam</code> ：描述方法的参数，给参数增加说明</p>

<p><code>@ApiImplicitParams</code> ：描述方法的参数（ Multi-Params ），给参数增加说明</p>

<p><code>@Apilgnore</code> ：忽略某类/方法/参数的文档</p>

<pre><code class="java">@RestController
public class HelloWorldController {
    @ApiOperation(value = &quot;hello&quot;, notes = &quot;notes &quot;)
    @RequestMapping(&quot;/hello&quot;)
    public String hello() throws Exception {
        return &quot;HelloWorld ,Spring Boot!&quot;;
    }
    //使用该注解忽略这个API
    @ApiIgnore
    @RequestMapping(value = &quot;/ignoreApi&quot;)
    public String  ignoreApi() {
        return &quot;HelloWorld ,Spring Boot!&quot;;
    }


    @ApiOperation(value = &quot;删除文章&quot;, notes = &quot;根据URL的id来指定删除对象&quot;)
    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;文章ID&quot;, required = true, dataType = &quot;Long&quot;)
    @RequestMapping(value = &quot;/{id}&quot;, method = RequestMethod.DELETE)
    public String del(@PathVariable(&quot;id&quot;) long id) {
        //articleRepository.deleteById(id);
        return &quot;success&quot;;
    }
}
</code></pre>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-spring " style="padding-bottom:1em;">

        <div id="spring_test"></div>
        <span class="hidden" itemprop="alternateName">spring_test</span>

        <h2>
            <a itemprop="url" href="#spring_test">
                <span itemprop="name">Spring Test</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/spring_test.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">spring</span>
        

        <div itemprop="description">
            

<p>单元测试的必要性</p>

<ul>
<li>预防 Bug</li>
<li>快速定位 Bug</li>
<li>提高代码质量，减少耦合</li>
<li>减少调试时间</li>
<li>减少重构的风险</li>
</ul>

<h3 id="toc_0">Spring Boot 的测试库</h3>

<p>Spring Boot 提供了 spring-boot-starter-test 启动器。通过它，能引入一些有用的测试库，如下所示</p>

<ul>
<li>Spring Test&amp;Spring Boot Test：Spring Boot 提供的应用程序功能集成化测试支持</li>
<li>Junit：Java 应用程序单元测试标准类库</li>
<li>AssertJ：轻量级的断言类库</li>
<li>Hamcrest：对象匹配器类库</li>
<li>Mockito：Java Mork 测试框架</li>
<li>JsonPath：JSON 操作类库</li>
<li>JSONassert：用于 JSON 的断言库</li>
</ul>

<h4 id="toc_1">1. 了解回归测试框架 JUnit</h4>

<p>JUnit 测试是白盒测试。要使用 JUnit，则只需要继承 TestCase 类。</p>

<p>JUnit 提供以下注解</p>

<ul>
<li><code>@BeforeClass</code> ：在所有测试单元前执行一次，一般用来初始化整体的代码</li>

<li><p><code>@AfterClass</code> ：在所有测试单元后执行一次，一般用来销毁和释放资源</p></li>

<li><p><code>@Before</code> ：在每个测试单元前执行，一般用来初始化方法</p></li>

<li><p><code>@After</code> ：在每个测试单元前执行，一般用来回滚测试数据</p></li>

<li><p><code>@Test</code> ：编写测试用例</p></li>

<li><p><code>@Test(timeout=1000)</code> ：对测试单元进行限时。“1000” 表示超过 1s 则超时，测试失败</p></li>

<li><p><code>@Test(expected=Exception.class)</code> ：指定测试单元期望得到的异常类。如果执行完成后没有抛出指定的异常，则测试失败</p></li>

<li><p><code>@Ignore</code> ：执行测试时将忽略掉此方法。如果用于修饰类，则忽略整个类</p></li>

<li><p><code>@RunWith</code> ：在 JUnit 中有很多 Runner，它们负责调用测试代码。每个 Runner 都有特殊功能，应根据需要选择不同的 Runner 来运行测试代码</p></li>
</ul>

<h4 id="toc_2">2. 了解 assertThat</h4>

<p>Unit 4.4 结合 Hamcrest 提供了一个新的断言语法——assertThat。使用 assertThat 的一个断言语句结合 Hamcrest 提供的匹配符，就可以表达全部的测试思想。</p>

<p>1）assertThat 的基本语法如下。</p>

<pre><code class="java">assertThat([value], [matcher statement]);
</code></pre>

<ul>
<li>value：要测试的变量值</li>
<li>master statement：如果 value 值与 master statement 所表达的期望值相符，则测试成功，否则失败。就是两个值比较</li>
</ul>

<p>2）一般匹配符</p>

<ul>
<li><code>assertThat(testNumber, allOf(greaterThan(5), lessThan(8)));</code> ：allOf 表示，所有条件必须都成立，测试才能通过。</li>
<li><code>assertThat(testNumber, anyOf(greaterThan(5), lessThan(8)));</code> ：allOf 表示，所有条件只要有一个成立，测试才能通过。</li>
<li><code>assertThat(testNumber, anythong());</code> ：anything 表示，无论什么条件，结果永远为 true。</li>
</ul>

<p>3）字符串相关匹配符</p>

<p>4）数值相关匹配符</p>

<p>5）collection 相关匹配符</p>

<h4 id="toc_3">3. 了解 Mockito</h4>

<p>Mockito 是 Github 上使用最广泛的 Mocking 框架。它提供简洁的 API 用来测试。与 JUnit 结合使用，Mockito 框架可以创建和配置 Mock 对象。</p>

<h4 id="toc_4">4. 了解 JSONPath</h4>

<p>JSONPath 是 xPath 在 JSON 中的应用，它的数据结构通常不一定有根元素，它用一个抽象的名字 “$” 来表示最外层对象，而且允许使用通配符 “*” 表示所有的子元素和数组索引。</p>

<p>JSONPath 表达式可以使用 “.” 符号解析 JSON，如下代码</p>

<pre><code class="java">$.person.card[0].num
</code></pre>

<p>或使用 “[]” 符号</p>

<pre><code class="java">$['persion']['card'][0]['num']
</code></pre>

<h4 id="toc_5">5. 测试的回滚</h4>

<p>在单元测试中可能会产生垃圾数据，可以开启事务功能进行回滚——在方法或类头部添加注解 @Transaction 即可</p>

<pre><code class="java">@RunWith(SpringRunner.calss)
@SpringBootTest
@Transactional
public class CardRepositoryTest {
    @Autowired
    private CardReponsitory cardReponsitory;
    
    @Test
    public void testRollBank() {
        // 查询操作
        Card card = new Card();
        card.setNum();
        cardReponsitory.save(card);
    }
}
</code></pre>

<p>在类上添加了注解 @Transactional，测试完成后就会回滚，不会产生垃圾数据。如果关闭回滚，则只需加上注解 @Rollback(false) 即可</p>

<p>Tip：如果使用数据库是 MySQL，有时注解 @Transactional 不会回滚，多数情况下是因为默认引擎不是 InnoDB.</p>

<h3 id="toc_6">快速创建测试单元</h3>

<h4 id="toc_7">添加依赖</h4>

<pre><code class="xml">
</code></pre>

<p>在 “src/test/java” 目录下新建一个测试类</p>

<pre><code class="java">@RunWith(SpringRunner.class)
public class test {
    @Test
    public void contextLoads() {
        // 测试代码
    }
}
</code></pre>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-spring " style="padding-bottom:1em;">

        <div id="spring_transactional"></div>
        <span class="hidden" itemprop="alternateName">spring_transactional</span>

        <h2>
            <a itemprop="url" href="#spring_transactional">
                <span itemprop="name">Spring transactional</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/spring_transactional.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">spring</span>
        

        <div itemprop="description">
            

<h3 id="toc_0">springboot 的事务处理 Transactional</h3>

<h4 id="toc_1">1. springboot事务</h4>

<p>两种处理方式</p>

<ul>
<li><strong>编程式事务管理</strong>，推荐使用<code>TransactionTemplate</code></li>
<li><strong>声明式事务管理</strong>，基于AOP原理的注解<code>@Transactional</code></li>
</ul>

<h4 id="toc_2">2. Transaction 的使用</h4>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-linux " style="padding-bottom:1em;">

        <div id="linux 文件与目录权限"></div>
        <span class="hidden" itemprop="alternateName">linux 文件与目录权限</span>

        <h2>
            <a itemprop="url" href="#linux%20%e6%96%87%e4%bb%b6%e4%b8%8e%e7%9b%ae%e5%bd%95%e6%9d%83%e9%99%90">
                <span itemprop="name">Linux permissions</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/linux%20%e6%96%87%e4%bb%b6%e4%b8%8e%e7%9b%ae%e5%bd%95%e6%9d%83%e9%99%90.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">linux</span>
        

        <div itemprop="description">
            

<p>linux 是多人多任务环境。为了让各用户具有保密的文件数据，文件权限管理变得很重要。linux 一般将文件可读写的身份分为三个类别：<strong>拥有者（owner）</strong>、<strong>所属群组（group）</strong>、<strong>其他人（others）</strong>，且三种身份各有读（read）、写（write）、执行（execute）等权限。</p>

<h4 id="toc_0">用户与用户组</h4>

<p>·</p>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-redis " style="padding-bottom:1em;">

        <div id="redis_string"></div>
        <span class="hidden" itemprop="alternateName">redis_string</span>

        <h2>
            <a itemprop="url" href="#redis_string">
                <span itemprop="name">Redis String</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/redis_string.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">redis</span>
        

        <div itemprop="description">
            

<h3 id="toc_0">字符串</h3>

<h4 id="toc_1">1 常用命令</h4>

<p>(1) 设置值</p>

<pre><code class="shell">set key value [ex seconds] [px milliseconds] [nx|xx]
</code></pre>

<p>set 命令有几个选项</p>

<ul>
<li>ex seconds：为键设置秒级过期时间。</li>
<li>px milliseconds：为键设置毫秒级过期时间</li>
<li>nx： 键必须不存在，才可以设置成功，用于添加</li>
<li>xx：与nx相反，键必须存在，才可以设置成功，用于更新</li>
</ul>

<p>除了 set 选项，Redis 还提供了 setex 和 setnx 两个命令</p>

<pre><code class="shell">setnx key seconds value
setnx key value
</code></pre>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-redis " style="padding-bottom:1em;">

        <div id="redis_clients"></div>
        <span class="hidden" itemprop="alternateName">redis_clients</span>

        <h2>
            <a itemprop="url" href="#redis_clients">
                <span itemprop="name">Redis Client API</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/redis_clients.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">redis</span>
        

        <div itemprop="description">
            

<h4 id="toc_0">Python 客户端 redis-py</h4>

<p>redis-py 的基本使用方法、redis-py 的 Pipeline 的使用和 redis-py 的 Lua 脚本使用。</p>

<h4 id="toc_1">获取 redis-py</h4>

<p>redis-py 需要 Python 2.7 以上版本。获取方式如下：</p>

<pre><code class="shell"># 使用 pip 进行安装
pip install redis

# 使用 easy_install 安装
easy_install redis

# 源码安装：以2.10.5为例
wget https://guthub.com/andymccurdy/redis-py/archive/2.10.5.zip
uzip redis-2.10.5.zip
cd redis-2.10.5
# 安装 redis-py
python setup.py install
</code></pre>

<h4 id="toc_2">redis-py 的基本使用方法</h4>

<pre><code class="python">import redis

# 生产客户端连接：需 Redis 实例 IP 和端口两个参数
client = redis.StrictRedis(host='127.0.0.1', port=6379)

# 执行命令，redis-py API 保留了 Redis API 的原始风格
client.set(key, &quot;python-redis&quot;) # True
client.get(key) # world
</code></pre>

<h4 id="toc_3">redis-py 中的 Pipeline 的只使用方法</h4>

<pre><code class="python">pipline = client.pipline(transaction=False) # transaction False 代表不使用事务

# 将命令封装到 Pipline 中，此时命令并没有真正执行
pipline.set('hello', 'world')
pipline.incr('counter')

# 执行 Pipline
result = pipline.execute() # [True, 3]
</code></pre>

<h4 id="toc_4">redis-py 中的 Lua 脚本使用方法</h4>

<p>redid-py 提供了三个重要的函数实现 Lua 脚本的执行：</p>

<pre><code class="python">eval(String script, int keyCount, String... params)
script_load(String script)
evalsha(String sha1, int keyCount, String... params)
</code></pre>

<p>script：Lua 脚本内容；KeyCount：键的个数；params：相关参数 KEYS 和 ARGV。</p>

<p>return redis.call(&lsquo;get&rsquo;, KEYS[1])  在 redis-py 中实现如下</p>

<pre><code class="python">script = 'return redis.call('get', KEYS[1]) '
client.eval(script, 1, 'hello') # world
</code></pre>

<p>script_load 和 evalsha 函数一起使用，首先使用 script_load 将脚本加载到 Redis 中</p>

<pre><code class="python">scriptSha = client.script_load(script)
</code></pre>

<p>evalsha 函数用来执行脚本的哈希值，需要三个参数：</p>

<p>scriptSha：脚本的 SHA1；KeyCount：键的个数；params：相关参数 KEYS 和 ARGV。</p>

<p>执行效果如下</p>

<pre><code class="python">client.evalsha(scriptSha, 1, 'hello')
</code></pre>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-redis " style="padding-bottom:1em;">

        <div id="redis_cmd"></div>
        <span class="hidden" itemprop="alternateName">redis_cmd</span>

        <h2>
            <a itemprop="url" href="#redis_cmd">
                <span itemprop="name">Redis Command</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/redis_cmd.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">redis</span>
        

        <div itemprop="description">
            

<h3 id="toc_0">全局命令</h3>

<h5 id="toc_1">1. 查看所有键：</h5>

<pre><code class="shell">keys *
</code></pre>

<h5 id="toc_2">2. 键总数：</h5>

<pre><code class="shell">dbsize
</code></pre>

<h5 id="toc_3">3. 检查键是否存在</h5>

<pre><code class="shell">exists key # 存在返回1，不存在返回0
</code></pre>

<h5 id="toc_4">4. 删除键</h5>

<pre><code class="shell">del key [key ...] # 通用命令 无论值是什么类型都可删除 返回结果为成功删除键的个数，删除不存在的键，就会返回0
</code></pre>

<h5 id="toc_5">5. 键过期</h5>

<pre><code class="shell">expire key seconds
</code></pre>

<p>ttl 命令返回键的剩余过期时间，有三种返回值</p>

<ul>
<li>大于等于0的整数：键剩余的过期时间</li>
<li>-1：键没设置过期时间</li>
<li>-2：键不存在</li>
</ul>

<h5 id="toc_6">6. 键的数据结构类型</h5>

<pre><code class="shell">type key # 键不存在，则返回none
</code></pre>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-redis " style="padding-bottom:1em;">

        <div id="redis_config"></div>
        <span class="hidden" itemprop="alternateName">redis_config</span>

        <h2>
            <a itemprop="url" href="#redis_config">
                <span itemprop="name">Redis Config</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/redis_config.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">redis</span>
        

        <div itemprop="description">
            

<h3 id="toc_0">启动</h3>

<h4 id="toc_1">默认配置</h4>

<p>redis-service  建议使用配置文件启动</p>

<h4 id="toc_2">运行配置</h4>

<p>redis-service &ndash;configKey &ndash;configValue &ndash;configKey2 &ndash; configValue2</p>

<p>例：redis-server &ndash;port &ndash;6379</p>

<h4 id="toc_3">配置文件启动</h4>

<p>例：配置文件写在/opt/redis/redis.config</p>

<p>redis-server /opt/redis/redis.config</p>

<p>一些重要配置如下</p>

<table>
<thead>
<tr>
<td>配置名</td>
<td>配置说明</td>
</tr>
</thead>

<tbody>
<tr>
<td>port</td>
<td>端口</td>
</tr>

<tr>
<td>logfile</td>
<td>日志文件</td>
</tr>

<tr>
<td>dir</td>
<td>Redis工作目录（存放持久化文件和日志文件）</td>
</tr>

<tr>
<td>dacmonize</td>
<td>是否以守护进程的方式启动Redis</td>
</tr>
</tbody>
</table>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-redis " style="padding-bottom:1em;">

        <div id="redis_list"></div>
        <span class="hidden" itemprop="alternateName">redis_list</span>

        <h2>
            <a itemprop="url" href="#redis_list">
                <span itemprop="name">Redis List</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/redis_list.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">redis</span>
        

        <div itemprop="description">
            

<h3 id="toc_0">列表</h3>

<p>列表（list）类型是用来存储多个<strong>有序</strong>的字符串，列表类型有两个特点：第一、列表中的元素是有序的，这意味这可以通过索引下标获取某个元素或者某个范围内的元素列表，第二、列表中的元素可以是重复的。</p>

<p>列表的四种操作类型</p>

<table>
<thead>
<tr>
<td>操作类型</td>
<td>操作</td>
</tr>
</thead>

<tbody>
<tr>
<td>添加</td>
<td>rpush    lpush    linsert</td>
</tr>

<tr>
<td>查</td>
<td>lrange    lindex   len</td>
</tr>

<tr>
<td>删除</td>
<td>lpop     rpop     lrem    ltrim</td>
</tr>

<tr>
<td>修改</td>
<td>lset</td>
</tr>

<tr>
<td>阻塞操作</td>
<td>blop   brpop</td>
</tr>
</tbody>
</table>

<h5 id="toc_1">1.添加操作</h5>

<p>（1）从右边插入元素</p>

<pre><code class="shell">rpush key value [value ...]
</code></pre>

<p>lrang 0 -1 命令可以从左到右获取列表的所有元素</p>

<p>（2）从左边插入元素</p>

<pre><code class="shell">lpush key value [value ....]
</code></pre>

<p>（3）向某个元素前或者后插入元素</p>

<pre><code class="shell">linsert key before|after privot value
</code></pre>

<p>linsert 命令会从列表中找到等于pivot的元素，在其前（before）或者后（after）插入新元素value</p>

<p>返回当前命令长度</p>

<h5 id="toc_2">2.查找</h5>

<p>（1）获取指定范围内的元素列表</p>

<pre><code class="powershell">lrange key start end
</code></pre>

<p>lrange操作会获取列表指定索引范围所有的元素。索引下标有两个特点：</p>

<p>第一，索引下标从左到右分别是0到N-1，但从右到左分别是-1 到 -N</p>

<p>第二，lrange中的end选项包含了自身</p>

<p>（2）获取列表指定索引下标的元素</p>

<pre><code class="powershell">lindex key index
</code></pre>

<p>（3）获取列表长度</p>

<pre><code class="powershell">llen key
</code></pre>

<h5 id="toc_3">3.删除</h5>

<p>（1）从列表左侧弹出元素</p>

<pre><code class="powershell">lpop key
</code></pre>

<p>（2）从列表右侧弹出</p>

<pre><code class="powershell">rpop key
</code></pre>

<p>（3）删除指定元素</p>

<pre><code class="powershell">lrem key count value
</code></pre>

<p>lrem 会从列表中找到等于value 的元素进行删除，根据count的不同分为三种情况：</p>

<ul>
<li>count&gt;0，从左到右，删除最多count个元素。</li>
<li>count&lt;0，从右到左，删除最多count绝对值个元素</li>
<li>count=0，删除所有</li>
</ul>

<p>（4）按照索引范围修剪列表</p>

<pre><code class="powershell">ltrim key start end
</code></pre>

<h5 id="toc_4">4. 修改</h5>

<p>修改指定索引下标的元素：</p>

<pre><code class="powershell">lset key index newValue
</code></pre>

<h5 id="toc_5">5. 阻塞操作</h5>

<p>阻塞式弹出如下：</p>

<pre><code class="powershell">blpop key [key ...] timout
brpop key [key ...] timout
</code></pre>

<p>blpop 和 brpop 是 lpop 和 rpop 的阻塞版本，它们除了弹出方式不同，使用方法基本相同，所以下面以brpop命令进行说明,brpop命令包含两个参数:</p>

<ul>
<li><p>key [key &hellip;]：多个列表的键。</p></li>

<li><p>timeout：阻塞时间（单位：秒）</p></li>
</ul>

<p>1）列表为空：如果 timeout=3，那么客户端要等到 3 秒后返回，timeout=0，客户端会一直阻塞等下去</p>

<pre><code class="powershell">127.0.0.1:6379&gt; brpop list:test 3
(nill)
(3.10s)
127.0.0.1:6379&gt; brpop list:test 3
...阻塞...
</code></pre>

<p>如果此期间添加了数据 element1，客户端立即返回：</p>

<pre><code class="powershell">127.0.0.1:6379&gt; brpop list:test 3
1) &quot;list:test&quot;
2) &quot;element1&quot;
(2.06s)
</code></pre>

<p>2）列表不为空：客户端会立刻返回。</p>

<pre><code class="powershell">127.0.0.1:6379&gt; brpop list:test 0
1) &quot;list:test&quot;
2) &quot;element1&quot;
</code></pre>

<p>在使用 bprop 时，有两点需要注意。</p>

<p>第一点，如果是多个键，那么 brpop 会从左至右遍历键，一旦有个键能弹出元素，客户端立即回：</p>

<pre><code class="powershell">127.0.0.1:6379&gt; brpop list:1 list:2 list:3
...阻塞...
</code></pre>

<p>此时另一个客户端分别向 list:2 和 list:3 插入元素：</p>

<pre><code class="powershell">client-lpush&gt; lpush list:2 element2
(integer) 1
client-lpush&gt; lpish list:3 element3
(integer) 1
</code></pre>

<p>客户端会立即返回 list:2 中的 element2，因为 list:2 最先有可能弹出的元素：</p>

<pre><code class="powershell">127.0.0.1：6379&gt; bprop list:1 list:2 list:3 0
1) &quot;list:2&quot;
2) &quot;element2_1&quot;
</code></pre>

<p>第二点，如果多个客户端对同一个键执行 bprop，那么最先执行 brpop 命令的客户端可以获取到出的值：
客户端1：</p>

<pre><code class="powershell">client-1&gt; bprop list:test 0
...阻塞...
</code></pre>

<p>客户端2：</p>

<pre><code class="powershell">client-2&gt; bprop list:test 0
...阻塞...
</code></pre>

<p>客户端3：</p>

<pre><code class="powershell">client-3&gt; bprop list:test 0
...阻塞...
</code></pre>

<p>此时另一个客户端 lpush 一个元素到 list:test 列表中：</p>

<pre><code class="powershell">client-lpush&gt; lpush list:test element
(integer) 1
</code></pre>

<p>那么客户端 1 最会获取到元素，因为客户端 1 最先执行 brpop，而客户端2 和 3 继续阻塞</p>

<pre><code class="powershell">client&gt; bprop list:test 0
1) &quot;list:test&quot;
2) &quot;elememt&quot;  
</code></pre>

<h4 id="toc_6">时间复杂度</h4>

<table>
<thead>
<tr>
<td>操作类型</td>
<td>命令</td>
<td>时间复杂度</td>
</tr>
</thead>

<tbody>
<tr>
<td>添加</td>
<td>rpush key value [value &hellip;]</td>
<td>O(k)，k是元素个数</td>
</tr>

<tr>
<td></td>
<td>lpush key value [value &hellip;]</td>
<td>O(k)，k是元素个数</td>
</tr>

<tr>
<td></td>
<td>linsert key before|after privot value</td>
<td>O(n)，n是pivot距离列表头或尾的距离</td>
</tr>

<tr>
<td>查找</td>
<td>lrange key start end</td>
<td>O(s+n)，s是start偏移量，n是start到end的范围</td>
</tr>

<tr>
<td></td>
<td>lindex key index</td>
<td>O(n)，n是索引的偏移量</td>
</tr>

<tr>
<td></td>
<td>llen key</td>
<td>O(1)</td>
</tr>

<tr>
<td>删除</td>
<td>lpop key</td>
<td>O(1)</td>
</tr>

<tr>
<td></td>
<td>rpop key</td>
<td>O(1)</td>
</tr>

<tr>
<td></td>
<td>lrem count value</td>
<td>O(n)，n是列表长度</td>
</tr>

<tr>
<td></td>
<td>ltrim key start end</td>
<td>O(n)，n是要裁剪的元素总数</td>
</tr>

<tr>
<td>修改</td>
<td>lset key index value</td>
<td>O(n)，n是索引的偏移量</td>
</tr>

<tr>
<td>阻塞操作</td>
<td>blpop brpop</td>
<td>O(1)</td>
</tr>
</tbody>
</table>

<h4 id="toc_7">内部编码</h4>

<p>列表类型的内部编码有两种。</p>

<ul>
<li>ziplist（压缩列表）：当列表的元素个数小于 list-max-ziplist-entries 配置（默认512个），同时列表中每个元素的值都小于 list-max-ziplist-value 配置时（默认64字节）。Redis 会选用 ziplist 来作为列表的内部实现来减少内存的使用。</li>
<li>linkedlist（链表）：当列表类型无法满足 ziplist 的条件时，Redis 会使用 linkedlist 作为列表的内部实现。</li>
</ul>

<p>下面演示列表类型的颞部编码，以及相应的变化。</p>

<p>1）当元素个数较少且没有大元素时，内部编码为 ziplist</p>

<pre><code class="shell">127.0.0.1:6379&gt; rpush listkey e1 e2 e3
(integer) 3
127.0.0.1:6379&gt; object encoding listkey
&quot;ziplist&quot;
</code></pre>

<p>2.1）当元素个数超过 512 个，内部编码变为 linkedlist：</p>

<pre><code class="shell">127.0.0.1:6379&gt; rpush listkey e4 e5 e6 ... 忽略 ... e512 e513
(integer) 513
127.0.0.1:6379&gt; object encoding listkey
&quot;linkedlist&quot;
</code></pre>

<p>2.2）或者当某个元素超过 64 字节，内部编码也会变为 linkedlist：</p>

<pre><code class="shell">127.0.0.1:6379&gt; rpush listkey &quot;one string is bigger than 64 byts ...&quot;
(integer) 4
127.0.0.1:6379&gt; object encoding listkey
&quot;linkedlist&quot;
</code></pre>

<p>tip：Redis 3.2版本提供了 quicklist 内部编码，简单地说他是一个以 ziplist 为节点的 linkedlist，它结合了 ziplist 和 linkedlist 的优势，为列表类型提供了一种更为优秀的内部编码实现，它的设计原理可以参考Redis 的另一个作者 Matt Stancliff 的博客：<a href="https://matt.sh/redis-quicklist。">https://matt.sh/redis-quicklist。</a></p>

<h4 id="toc_8">使用场景</h4>

<p><strong>消息队列</strong></p>

<p>Redis 的 lpush + brpop 命令组合即可实现阻塞队列，生产者客户端使用 lrpush 从列表左侧插入元素，多个消费者客户端使用 brpop 命令阻塞式的“抢”列表尾部的元素，多个客户端保证了消费的负载均衡和高可用性。</p>

<p><strong>文章列表</strong></p>

<p>每个用户有属于自己的文章列表，现需要分页展示文章列表，此时可以考虑使用列表，因为列表不但是有序的，同时支持按照索引范围获取元素。</p>

<p>1）每篇文章使用哈希结构存储，例如每篇文章有 3 个属性 title、timestamp、content：</p>

<pre><code class="shelll">hmset article:1 title xx timestamp 1476536196 content xxx
...
hmset article:k title yy timestamp 1476512536 content yyy
...
</code></pre>

<p>2）向用户文章列表添加文章，user:{id}:articles 作为用户文章列表的键：</p>

<pre><code class="shell">lpush user:1:articles articles:1 acticle3
...
lpush user:k:articles article:5
...
</code></pre>

<p>3）分页获取用户文章列表，例如下面伪代码获取用户 id=1 的前10篇文章：</p>

<pre><code>articles = lrange user:1:articles 0 9
for article in {articles}
    hgetall {article}
</code></pre>

<p>使用列表类型保存和获取文章列表会存在两个问题。第一，如果每次分页获取的文章较多，需执行多次 hgetall 操作，此时可以考虑使用 Pipline 批量获取。或者考虑将文章数据序列化为字符串类型，使用 mget 批量获取。第二，分页获取文章列表是，lrange 命令在列表两端性能较好，但如果列表较大，获取列表中间范围的元素性能会变差，此时可考虑将列表做二级拆分，或者使用 Redis 3.2 的 quicklist 内部编码实现，它结合 ziplist 和 linkedlist 的特点，获取列表中间范围的元素时也可以高效的完成。</p>

<p>tip：实际上列表的使用场景很多，在选择时可以参考一下口诀：</p>

<ul>
<li>lpush + lpop = Stack（栈）</li>
<li>lpush + rpop = Queue（队列）</li>
<li>lpush + ltrim = Capped Collection（有限集合）</li>
<li>lpush + brpop = Message Queue（消息队列）</li>
</ul>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-redis " style="padding-bottom:1em;">

        <div id="redis_memory"></div>
        <span class="hidden" itemprop="alternateName">redis_memory</span>

        <h2>
            <a itemprop="url" href="#redis_memory">
                <span itemprop="name">Redis Memory</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/redis_memory.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">redis</span>
        

        <div itemprop="description">
            

<p>redis所有数据都存在内存中</p>

<h3 id="toc_0">redisObject 对象</h3>

<p>Redis 存储的所有值都在内部定义为 redisObject 结构体。</p>

<pre><code>type: 4                             // 对象类型
encoding: 4                         // 内部编码类型
lruREDIS_LRU_BITS                   // LRU计时时钟
int refcount                        // 引用计数器
void *ptr                           // 数据指针
</code></pre>

<p>Redis 存储的数据都使用 redisObject 来封装，包括 string、hash、list、set、zset 在内的所有数据类型。理解 redisObject 对内存优化十分有帮助：</p>

<ul>
<li><p>type 字段：表示当前对象使用的数据类型</p></li>

<li><p>encoding 字段：表示 Redis 内部编码类型</p></li>

<li><p>lru 字段：记录对象最后一次被访问的时间，当配置了maxmemory 和 maxmemory-policy=volatile-lru 或者 allkeys-lru 时，用于辅助 LRU 算法删除键数据。可以使用 object idletime {key} 命令在不更新 lru 字段情况下查看当前键的空闲时间</p></li>
</ul>

<p><strong>Tip</strong>：可以使用 scan + object idletime 命令批量查询哪些键长时间未被访问。找出长时间不访问的键进行清理，可降低内存占用</p>

<ul>
<li><p>refcount 字段：记录当前对象被引用的次数，用于通过引用次数回收内存，当 refcount = 0 时，可以安全回收当前对象空间。使用 object refcount {key} 获取当前对象引用。当对象为整数且范围在[0-9999] 时，Redis 可以使用共享对象的方式来节约内存。具体见共享对象池部分。</p></li>

<li><p>*ptr 字段：与对象的数据内容相关，如果是整数，直接存储数据；否则表示指向数据的指针。Redis 在 3.0 之后对值对象是字符串且长度&lt;=39 字节的数据，内部编码为 embstr 类型，字符串 sds 和 redisObject 一起分配，从而只要一次内存操作即可</p></li>
</ul>

<p>tip：高并发写入场景中，在条件允许的情况下，建议字符串长度控制在 39 字节以内，减少创建 redisObject 内存分配次数，从而提高性能</p>

<h3 id="toc_1">缩减键值对象</h3>

<p>降低 Redis 内存使用<strong>最直接的方式就是缩减键（key）和值（value）的长度</strong></p>

<ul>
<li><p>key 长度：如在设计键时，在完整描述业务情况下，键值越短越好。如 user:{uid}:friends:notify:{fid} 可简化为 u:{uid}:fs:nt:{fid}</p></li>

<li><p>value 长度：值对象缩减比较复杂，常见需求是把业务对象序列化成二进制数组放入 Redis。首先应该在业务上精简业务对象，去掉不必要的属性避免存储无效数据。其次在序列化工具选择上，应该选择更高效的序列化工具来降低字节数组大小。以 Java 为例，内置的序列化方式无论从速度还是压缩比都不尽人意。这时可以选择更高效的序列化工具，如：protostuff、kryo 等</p></li>
</ul>

<p>值对象除了存储二进制数据之外，通常还会使用通用格式存储数据比如：json、xml等作为字符串存储在 Redis 中。这种方式的优点是方便调试和跨语言，但是同样的数据相比字节数组所需的空间更大，在内存紧张的情况下，可以使用通用压缩算法压缩 json、xml 后再存入 redis，从而降低内存占用，例如 GZIP 压缩后的 json 可降低 60% 的空间。</p>

<p><strong>Tip</strong>：当频繁压缩解压 json 等文本数据时，开发人员要考虑压缩速度和计算开销成本，这里推荐使用 Google 的 Snappy 压缩工具，在特定的压缩情况下效率远远高于 GZIP 等传统压缩工具、且支持所有主流语言环境。</p>

<h3 id="toc_2">共享对象池</h3>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-java " style="padding-bottom:1em;">

        <div id="java_sort"></div>
        <span class="hidden" itemprop="alternateName">java_sort</span>

        <h2>
            <a itemprop="url" href="#java_sort">
                <span itemprop="name">java Sort</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/java_sort.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">java</span>
        

        <div itemprop="description">
            

<h3 id="toc_0">排序算法类的模板</h3>

<pre><code class="java">public class Example {
    public static void stort (Compareable[] a) {
        // 见算法 2.1、2.2、2.3、2.4、2.5 或 2.7
    }
    
    private static boolean less (Comparable v, Comparable w) {
        return v.compareTo(w) &lt; 0;
    }
    
    private static void exah (Comparable[] a, int i, int j) {
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }
    
    private static void show (Comparable[] a) {
        // 在单行中打印数组
        for (int i=0; i&lt;a.length; i++)
            System.out.print(a[i] + &quot;&quot;);
        System.out.println();
    }
    
    private static boolean isStored (Comparable[] a) {
        // 测试数组元素是否有序
        for (int i=1; i&lt;a.length; i++)
            if (less(a[i], a[i-1])) return false;
        return true;
    }
    
    public static void main(String[] args) {
        // 从标准输入读取字符串，将它们排序并输出
        String[] a = In.readString();
        sort(a);
        assert isStored(a);
        show(a);
    }
}
</code></pre>

<h3 id="toc_1">算法2.1 选择排序</h3>

<p>找到数组中最小的元素，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素则它和自己交换。）再在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。此为*选择排序*，因为它在不断选择剩余元素之中的最小值。</p>

<pre><code class="java">public class Selection {
    public static void sort(Comparable[] a) {
        // 将 a[] 按升序排序
        for (int i=0; i&lt;N; i++) {
            // 将 a[i] 和 a[i+1..N] 中最小的元素交换
            int min = i;
            for (int j = i+1; j&lt;N; j++)
                if (less(a[j], a[min])) min = j;
            exah(a, i, min);
        }
    }
    // less()、exch()、isSorted() 和 main() 方法见 “排序算法类模板”
}
</code></pre>

<h3 id="toc_2">算法2.2 插入排序</h3>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-design " style="padding-bottom:1em;">

        <div id="abstract_factory"></div>
        <span class="hidden" itemprop="alternateName">abstract_factory</span>

        <h2>
            <a itemprop="url" href="#abstract_factory">
                <span itemprop="name">Abstract Factory</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/abstract_factory.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">design</span>
        

        <div itemprop="description">
            

<p>###　（Abstract Factory）抽象工厂模式——对象创建型模式</p>

<h4 id="toc_0">１.　意图：</h4>

<p>提供一个接口以创建一系列相关或相互依赖的对象，而无需指定它们具体的类</p>

<h4 id="toc_1">2.  别名</h4>

<p>Kit</p>

<h4 id="toc_2">3. 动机</h4>

<p>考虑一个支持多种视感（look-and-feel）标准的用户界面工具包，例如 Motif 和 Presentation Manager。不同的视感风格诸如滚动条、窗口和按钮等用户界面“窗口组件”定义不同的外观和行为。为保证视感风格标准之间的可移植性，一个应用不应该为一个特定的视感外观硬编码它的窗口组件。在整个应用中实例化特定视感风格的窗口组件类将使得以后很难改变视感风格。</p>

<p>为解决这一问题，可以定义一个抽象的 WidgeFactory 类，这个类声明一个用来创建每一类的基本窗口组件的接口。每一个窗口组件都有一个抽象类，而具体子类则实现了窗口组件的特定视感风格。对于每一个抽象窗口组件类，WidgeFactory  接口都有一个返回新窗口组件对象的操作。客户调用这些操作以获得窗口组件实例，但客户并不知道其正在使用的是哪些具体类。这样客户就不依赖于一般的视感风格，如下图所示。</p>

<h4 id="toc_3">4. 适用性</h4>

<p>在一下情况下使用 Abstract Factory 模式</p>

<ul>
<li>一个系统要独立于它的产品的创建、组合和表示</li>
<li>一个系统要由多个产品系列中的一个来配置</li>
<li>要强调一系列相关的产品对象的设计以便进行联合使用</li>
<li>提供一个产品类库，但只想现实它们的接口而不是实现。</li>
</ul>

<h4 id="toc_4">5. 结构</h4>

<h4 id="toc_5">6. 参与者</h4>

<ul>
<li>AbstractFactory （WidgetFactory）</li>
</ul>

<p>— 声明一个创建抽象产品对象的操作接口</p>

<ul>
<li>ConcreteFactory （MotifWidgetFactory、PMWidgetFactory）</li>
</ul>

<p>— 实现创建具体产品对象的组件</p>

<ul>
<li>AbstractProduct （Window、ScrollBar）</li>
</ul>

<p>— 为一类产品对象声明一个接口</p>

<ul>
<li>ConcreteProduct（MotifWindow、MotifScrollBar）</li>
</ul>

<p>— 定义一个将被相应的具体工厂创建的产品对象。</p>

<p>— 实现 AbstractProduct 接口。</p>

<ul>
<li>Client</li>
</ul>

<p>— 仅使用由 AbstractFactory 和 AbstractProduct 类声明的接口。</p>

<h4 id="toc_6">7. 协作</h4>

<p>通常在运行时创建一个 ConcreteFactory 类的实例。这一具体的工厂创建具有特定实现的产品对象。为创建不同的产品对象，客户应使用不同的具体工厂。</p>

<p>AbstractFactory 将产品对象的创建延迟到它的 ConcreteFactory 子类。</p>

<h4 id="toc_7">8. 效果</h4>

<p>AbstractFactory 模式有以下优点和缺点：</p>

<p>1）<strong>它分离了具体的类</strong>　Abstract Factory 模式帮助你控制一个应用创建的对象的类。因为一个工厂封装创建产品对象的责任和过程，他将客户与类的实现分离。客户通过它们的抽象接口操纵实例。产品的类名也在具体工厂的实现中被隔离，即它们不出现在客户代码中。</p>

<p>2）<strong>它是的易于交换产品系列</strong>　一个具体工厂类在一个应用中仅出现一次——在它初始化的时候。这使得该百年一个应用的具体工厂变得很容易。只需要该百年具体的工厂即可使用不同的产品配置。这是因为一个抽象工厂创建了一个完整的产品系列，所以整个产品系列会立刻改变。在用户界面的例子中，仅需转换到相应的工厂对象并重新从创建接口，就可实现从 Motif 窗口组件转换为 Presentation Manager 窗组件。</p>

<p>3）<strong>它有利于产品的一致性</strong>　当一个系列中的产品对象被设计成一起工作时吗，一个应用一次只能使用同一个系列中的对象，这一点很重要，而 AbstractFactory 很容易做到这一点</p>

<p>4）<strong>难以支持新种类的产品</strong>　难以扩产抽象工厂以生产新种类的产品。这是因为 AbstractFactory 接口确定了可以被创建的产品集合。支持新种类的产品就需要扩展该工厂接口，这将涉及 AbstractFactory 和及其所有子类的改变。在实现一节中会讨论这个问题的一个解决办法。</p>

<h4 id="toc_8">9. 实现</h4>

<pre><code class="java">
</code></pre>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-design " style="padding-bottom:1em;">

        <div id="design_pattern"></div>
        <span class="hidden" itemprop="alternateName">design_pattern</span>

        <h2>
            <a itemprop="url" href="#design_pattern">
                <span itemprop="name">Design Pattern</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/design_pattern.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">design</span>
        

        <div itemprop="description">
            

<h2 id="toc_0">设计模式怎么解决设计问题</h2>

<h4 id="toc_1">寻找合适的对象</h4>

<p>面向对象程序由对象组成，对象包括数据和对数据操作的过程，过程通常称为方法或操作。对象在收到客户的请求或消息后，执行相应的操作。</p>

<p>客户请求是使对象<strong>执行操作的唯一方法</strong>，操作由是对象<strong>改变内部数据的唯一方法</strong>。由于这些限制，对象的内部状态是封装的，它不能被直接访问，它的表示对于对象外部是不可见的。</p>

<p>面向对象设计最困难的部分是<strong>将系统分解成对象集合</strong>。因为要考虑许多因素：封装、粒度、依赖关系、灵活性、性能、演化、复用等。他们都影响着系统的分解，并且这些因素通常还是互相冲突的。</p>

<p>面向对象设计方法学支持多种设计方法。你可以写出一个问题描述，挑出名词和动词，进而创建相应的类和操作；或者，你可以关注系统的协作和职责关系；或者，你可以对现实世界建模，再将分析时发现的对象转化至设计中，至于哪一种方法最好，并无定论。</p>

<p>设计的许多对象来源于现实世界的分析模型。但是，设计结果所得到的类通常在现实世界中并不存在，有些是像数组之类的低层类，而另一些则层次较高，例如，Composite 模式引入了统一对待现实世界中并不存在的对象的抽象方法。严格反应当前现实世界的模型并不能产生也能反映将来世界的系统。<strong>设计中的抽象对于产生灵活的设计是至关重要的</strong>。</p>

<p>设计模式帮你<strong>确定并不明显的抽象和描述这些抽象的对象</strong>。例如，描述过程或算法的对象现实中并不存在，但他们确实设计的关键部分。Strategy 模式描述了怎么实现可互换的算法族。State 模式将实体的每一个状态描述为一个对象。这些对象在分析阶段，甚至在设计阶段的早期并不存在，后来为使设计更加灵活、复用性更好才将他们发掘出来。</p>

<h3 id="toc_2">决定对象的粒度</h3>

<p>对象在大小和数目上变化极大。它们能表示下至硬件或上至整个应用的任何事物。设计模式很好的讲述了怎么决定一个对象应该是什么，Facade（外观）模式描述了怎么用对象表示完整的子系统，Flyweight（享元）模式描述了如何支持大量的最小粒度的对象。其他一些设计模式描述了将一个对象分解成许多小对象的特定方法。Abstract Factory（抽象工厂）和 Builder（生成器）产生那些专门负责生产其他对象的对象。Visitor（访问者）和 Command（命令）模式生产的对象专门负责实现对其他对象或者对象组的请求。</p>

<h3 id="toc_3">指明对象接口</h3>

<p>对象声明的每一个操作都指定操作名、作为参数的对象和返回值，这就是所谓的操作的<strong>型构</strong>（signature）。对象操作所定义的所有操作型构的集合被称作该对象的<strong>接口</strong>（interface）。对象接口描述了该对象所能接受的全部请求的集合，任何匹配对象接口中型构的请求都可以发送给对象。</p>

<h3 id="toc_4">描述对象的实现</h3>

<h3 id="toc_5">运用复用机制</h3>

<p><strong>继承和组合的比较</strong></p>

<p>面向对象系统中功能复用的两种最常用技术是类继承和<strong>对象组合</strong>。类继承允许你根据其他类的实现来定义一个类的实现。这种通过生产子类的复用通常被称为<strong>白箱复用</strong>（white-box reuse）。“白箱”是相对可视性而言的：在继承方式中，父类的内部细节对子类可见。</p>

<p>对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为<strong>黑箱复用</strong>（black-box resue），因为对象的内部细节是不可见的。对象只以“黑箱”的形似出现。</p>

<p>继承和组合各有优缺点。类继承是编译时静态定义的，且可直接使用，因为程序设计语言支持类继承。类继承可以较方便地改变被复用的实现。当一个子类重定义一些而不是全部操作时，它也能影响它所继承地操作，只要在这些操作中调用了被重定义地操作。</p>

<p>但是类继承也有一些不足之处。首先，因为继承在编译时就定义了，所以无法在运行时改变从父类继承的实现。更糟的是，父类通常至少定义了部分子类的具体表示。因为继承对子类揭示了其父类的实现细节，所以继承常被认为“破坏了封闭性”。子类中的实现与它的父类有如此紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。</p>

<h3 id="toc_6">关联运行时和编译时的结构</h3>

<p>一个面向对象程序运行时的结构通常与它的代码结构相差较大。代码结构在编译时就被确定下来了，它由继承关系固定的类组成。而程序的运行时结构是由快速变化的通信对象网络组成的。事实上两个结构是彼此独立的，试图由一个去理解另一个就好像试图从静态的动植物去理解活生生的生态系统的动态性一样。反之亦然。</p>

<p>考虑对象<strong>聚合</strong>（aggregation）和<strong>相识</strong>（acquaintance）的差别以及它们在编译时和运行时的表示时多么不同。聚合意味着一个对象拥有另一个对象或对另一个对象负责。一般我们称一个对象<strong>包含</strong>另一个对象或者另一个对象的一部分。聚合意味着聚合对象和其所有者具有相同的生命周期</p>

<p>相识意味着一个对象仅仅知道另一个对象。有时相识也被称为“关联”或“引用”关系。相识的对象可能请求彼此的操作，但是它们不为对方负责。相识是一种比聚合更弱的关系，它只标识了对象间较松散的耦合关系。</p>

<h3 id="toc_7">设计应支持变化</h3>

<p>获取最大限度复用的关键在于对新需求和已有需求发生变化时的预见性，要求你的系统设计能够相应地改进。</p>

<p>为了设计适应这种变化且具有健壮性的系统，你必须考虑系统在它的生命周期内会发生怎样的变化。一个不考虑系统变化的设计在将来就有可能需要重新设计。这些变化可能是类的重新定义和实现，修改客户和重新测试。重新设计会影响软件系统的许多方面，并且未曾料到的变化总是代价巨大的。</p>

<p>设计模式可以确保系统以特定方式变化，从而帮助你避免重新设计系统。每一个设计模式允许系统结构的某个方便的变化独立于其他方面，这样产生的系统对于某种特定变化将更健壮。</p>

<p>下面阐述了一些导致重新设计的一般原因，以及解决问题的设计模式：</p>

<p>1）<strong>通过显式地指定一个类来创建对象</strong> 在创建对象时指定类名将使你受特定实现的约束而不是特定接口的约束。这会使未来的变化更复杂。要避免这种情况，应该间接地创建对象。</p>

<p>*设计模式*：Abstract Factory，Factory Method，Prototype。</p>

<p>2）<strong>对特定操作地依赖</strong> 当你为请求指定一个特殊的操作时，完成该请求地方式就固定下来了。为避免将请求代码写死，你将可以在编译时或运行时很方便地改变响应请求地方法。</p>

<p>*设计模式*：Chain of Resposibility，Command。</p>

<p>3）<strong>对硬件和软件平台的依赖</strong> 外部的操作系统接口和应用编程接口（API）在不同的软硬件平台上是不同的。依赖于特定平台的软件很难移植到其他平台上，甚至很难跟上本地平台的更新。所以设计系统时限制平台相关性就很重要了。</p>

<p>*设计模式*：Abstract Factory，Bridge。</p>

<p>4) <strong>对对象表示或实现的依赖</strong> 知道对象怎样表示、保存、定位或实现的客户在对象发生变化时可能也需要变化。对客户隐藏这些信息能阻止连锁变化。</p>

<p>*设计模式*：Abstract Factory，Bridge，Memento，Proxy。</p>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-css " style="padding-bottom:1em;">

        <div id="css_bg&amp;bd"></div>
        <span class="hidden" itemprop="alternateName">css_bg&amp;bd</span>

        <h2>
            <a itemprop="url" href="#css_bg%26bd">
                <span itemprop="name">CSS background border</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/css_bg&amp;bd.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">css</span>
        

        <div itemprop="description">
            

<h3 id="toc_0">半透明边框（RGBA/HSLA 颜色）</h3>

<p>给容器一个白色背景和一道半透明的白色边框</p>

<pre><code class="css">border: 10px solid hsla(0.0%,100%,.5);
background: white;
</code></pre>

<p>上述 css 并不会达到需求，背景的白色会透过边框显示出来</p>

<pre><code class="css">border: 10px solid hsla(0.0%,100%,.5);
background: white;
background-clip: padding-box;
</code></pre>

<p>css3 中 使用 background-clip（初始值为 border-clip 意味背景会被元素的 border box 边框的外延框裁切掉。）如果不想背景侵入边框所在的范围，即把值设为</p>

<p>padding-box，这样浏览器就会用内边距的外延来把背景裁切掉。</p>

<h3 id="toc_1">多重边框（box-shadow）</h3>

<p>box-shadow 可接收第四个参数（称作扩张半径）,通过指定正负值，可让<strong>投影面积加大</strong>或<strong>减小</strong>。一个正值的扩张半径加上两个为零的偏移量以及为零的模糊值，得到的投影其实就像一道实线边框</p>

<pre><code class="css">background: yellowgreen;
box-shadow: 0 0 0 10px #655;
</code></pre>

<p>border 属性可生产完全一致的效果。不过 box-shadow 好处在于，<strong>它支持逗号分割法，我们可以创建任意数量的投影</strong>，因此，上例中可非常轻松的加上一道 deeppink 颜色的边框。</p>

<pre><code class="css">background: yellowgreen;
box-shadow: 0 0 0 10px #655, 0 0 0 15px deeppink;
</code></pre>

<p>唯一需要注意的是，box-shadow 是层层叠加的，第一层投影位于最顶层，依次类推。因此。需要按此规律调整扩张半径。比如说，在前面代码中还想在外圈再加一道 5px 的外框吗，那就需指定扩张半径的值为 15px（10px + 5px）还可以在这些边框的底下再加一层常规的投影</p>

<pre><code class="css">background: yellowgreen;
box-shadow: 0 0 0 10px #655,
            0 0 0 15px deeppink,
            0 2px 5px 15px rgba(0,0,0,.6)
</code></pre>

<p>多重投影解决方案在大多数场合下可以很好工作，但有一些注意事项：</p>

<ul>
<li><p>投影的行为和边框不完全一致，因为它不影响布局，而且也不会受到box-sizing 属性的影响。不过，可以通过内边距或外边距（取决于投影是内嵌还是外扩的）来额外模拟出边框所需要占据的空间</p></li>

<li><p>上述方法创建出的假边框出现在元素的<strong>外圈</strong>。它们并不会影响鼠标事件，比如悬停或点击。如果这一点非常重要，你可以给 box-shadow 属性加上 inset 关键字，来使投影绘制在元素的<strong>内圈</strong>。注意，此时需要你增加额外的内边距来腾出足够的空隙。</p></li>
</ul>

<h4 id="toc_2">outline 方案</h4>

<p>某些情况下，<strong>可能只需要两层边框</strong>，那就可以先设置一层常规边框，再加上outline（描边）属性来产生外层的边框。这样做边框样式十分灵活，不像上面的 box-shadow 方案只能模拟实线边框（box-shadow 无法模拟虚线边框）下例实现双层边框</p>

<pre><code class="css">background: yellowgreen;
border: 10px solid #655;
outline: 5px solid deeppink;
</code></pre>

<p>描边的另一个好处在于，可以通过 outline-offset 属性来控制它跟元素边缘之间的间距，这个属性可以接收负值。</p>

<p>这个方案同样存在一些注意点：</p>

<ul>
<li>如上所述，它只适用于双层“边框”的场景，因为 outline 并不能接受用逗号分隔的多个值。如果需要更多层的边框，只能采取前一种方案。</li>
<li>边框不一定会贴合 border-radius 属性产生的圆角，因此如果元素是圆角的，他的描边可能还是直角的。注意，此行为被 CSS 工作组认为是一个 bug，因此未来可能会改为整合 border-radius 圆角。</li>
<li>根据 CSS 基本 UI 特征（第三版规范）所述。“描边可以不是矩形”。尽管在绝大多数情况下，描边都是矩形，但如果你想使用这个方法，请切记：最好在不同浏览器中完整地测试最终效果。</li>
</ul>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-other " style="padding-bottom:1em;">

        <div id="mac"></div>
        <span class="hidden" itemprop="alternateName">mac</span>

        <h2>
            <a itemprop="url" href="#mac">
                <span itemprop="name">MAC adr</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/mac.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">other</span>
        

        <div itemprop="description">
            

<p><strong>MAC地址</strong>（<strong>英语：Media Access Control Address）</strong>，直译为<strong>媒体访问控制地址</strong>，也称为<strong>局域网地址</strong>（LAN Address），<strong>以太网地址</strong>（Ethernet Address）或<strong>物理地址</strong>（Physical Address），它是一个用来确认网络设备位置的地址。在<a href="https://zh.wikipedia.org/wiki/OSI模型">OSI模型</a>中，第三层网络层负责IP地址，第二层数据链接层则负责MAC地址。MAC地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址。</p>

<h3 id="toc_0">格式</h3>

<p>MAC地址共48位（6个字节），以十六进制表示。</p>

<p>第1Bit为广播地址(0)/群播地址(1)，第2Bit为广域地址(0)/区域地址(1)。前3~24位由<a href="https://zh.wikipedia.org/wiki/IEEE">IEEE</a>决定如何分配给每一家制造商，且不重复，后24位由实际生产该网络设备的厂商自行指定且不重复。</p>

<p>ff:ff:ff:ff:ff:ff则作为广播地址。</p>

<p>01:xx:xx:xx:xx:xx是多播地址，01:00:5e:xx:xx:xx是<a href="https://zh.wikipedia.org/wiki/IPv4">IPv4</a>多播地址。</p>

<h3 id="toc_1">举例</h3>

<p>假设现有一台路由器，含有一个WAN端口及四个LAN端口。它的WAN端口会有一个如61.61.61.61的IP地址，也会有一个如00:0A:02:0B:03:0C的MAC地址。而它的四个LAN端口会各分配到一个例如192.168.1.0/24的IP地址，四个端口各会有一个不同的MAC地址。</p>

<h3 id="toc_2">查看MAC地址</h3>

<h4 id="toc_3">Windows</h4>

<p>在Windows命令提示符（cmd.exe）下运行 ipconfig /all 命令。假设运行结果含：</p>

<pre><code class="powershell">        Physical Address. . . . . . . . . : 00-05-5D-E8-0F-A3
</code></pre>

<p>那么其中的00-05-5D-E8-0F-A3就是本机网卡的MAC地址。如果计算机上有多个网络设备（无论物理或虚拟），则会有多组信息及MAC地址，需辨识相应的设备。</p>

<h4 id="toc_4">Linux</h4>

<p>第一种： 在 Linux下运行 ifconfig 命令，如下：</p>

<pre><code class="shell"> $ ifconfig
 eth0    Link encap:Ethernet HWaddr 00:0C:29:01:98:27
         inet addr:192.168.1.88  Bcast:192.168.1.255  Mask:255.255.255.0
         UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
         RX packets:74978 errors:0 dropped:0 overruns:0 frame:0
         TX packets:38451 errors:0 dropped:0 overruns:0 carrier:0
         collisions:0 txqueuelen:100
         RX bytes:14157042 (13.5 Mb)  TX bytes:5063398 (4.8 Mb)
         Interrupt:18 Base address:0x1080
 
 lo      Link encap:Local Loopback
         inet addr:127.0.0.1  Mask:255.0.0.0
         UP LOOPBACK RUNNING  MTU:16436  Metric:1
         RX packets:1097 errors:0 dropped:0 overruns:0 frame:0
         TX packets:1097 errors:0 dropped:0 overruns:0 carrier:0
         collisions:0 txqueuelen:0
         RX bytes:151393 (147.8 Kb)  TX bytes:151393 (147.8 Kb)
</code></pre>

<p>eth0 为第一块物理网卡， HWaddr 00:0C:29:01:98:27 就是MAC地址，lo为本地回环地址。</p>

<p>第二种： 运行 ip命令(是一个命令，不是Tcp/Ip里的ip)，示例如下：</p>

<pre><code> $ ip link show
 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
 2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 28:d2:44:d4:e6:ea brd ff:ff:ff:ff:ff:ff
</code></pre>

<p>其中$是linux下的命令提示符，一般情况下：$ 表示一般用户，# 表示root用户</p>

<h3 id="toc_5">如何修改MAC地址</h3>

<p>网卡MAC地址可以通过Windows设备管理员或其他工具修改。对于某些手机、平板电脑设备来说，其MAC地址／产品序号均由厂方连同销售或保修时的客户资料一并记录在案，而有关的MAC地址也不可通过常规手段来修改。</p>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
  </div>
</div>


<hr>
<div class="container footer">
  <div class="row">
    <div class="col-xs-12 text-center">
		YSlow are licensed under the <a href="https://raw.github.com/marcelduran/yslow/master/LICENSE.txt">New BSD License</a>.<br>
		YSlow also includes files from the <a href="http://yuilibrary.com/">Yahoo! User Interface library</a>, which are licensed under the <a href="http://yuilibrary.com/license/">BSD license</a>.<br>
		Translations are licensed under the <a href="https://raw.github.com/checkmyws/yslow-rules/master/LICENSE">MIT License</a>.<br>
		Powered by <a href="http://hugo.spf13.com/">Hugo</a>.
    </div>
  </div>
</div>
    <noscript></noscript>
    <script src="https://cdn.staticfile.org/jquery/2.1.0/jquery.min.js"></script>
    <script src="https://gniqizeuy.github.io//js/main.js"></script>
    <script src="https://cdn.staticfile.org/highlight.js/10.0.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>