<!doctype html>



 <html class="no-js"> 

  <head>
    <title>saul - goodman</title>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">

    <meta name="description" content="taicang">
    <meta name="google-site-verification" content="_kDN7uZlq3Uv5yjsjP5vA1I-u5_Vifz2XkAOla4l0hY">

    <link rel="shortcut icon" type="image/png" href="https://gniqizeuy.github.io//img/favicon.png" />
 
    <link rel="stylesheet" href="https://gniqizeuy.github.io//css/bootstrap.min.css">
    <link rel="stylesheet" href="https://gniqizeuy.github.io//css/main.css">
  </head>

  <body>

    <a href="https://github.com/gniqizeuy" class="hidden-xs">
      <img style="position: absolute; top: 0; right: 0; border: 0; z-index: 10000;" src="https://github-camo.global.ssl.fastly.net/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png">
    </a>
<div id="top"></div>

<div class="header">
  <div class="hidden-xs stars_1"></div>
  <div class="hidden-xs stars_2"></div>

  <nav class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <a class="navbar-brand" href="#">taicang</a>
    </div>
  </nav>

  <div class="container">
    <div class="row">
      <div class="col-xs-12">
       
        
          
           <h1>gniqizeuy blog</h1>
 <p>do my best</p>
 
        

      </div>
      <div class="col-xs-12">
        <span class="pull-right links">
          <ul>
            <li>
              <a href="http://yslow.org/"><img height=24 src="https://gniqizeuy.github.io//img/yslow.png">YSlow.org</a>
            </li>
            <li>
              <a href="http://www.checkmy.ws/"><img width=24 src="https://gniqizeuy.github.io//img/checkmyws.png">Check my Website</a>
            </li>
          </ul>
        </span>
      </div>
    </div>
  </div>
</div>

<nav class="navbar navbar-default" role="navigation">
  <div class="container">
    <ul class="nav navbar-nav">
      <li>
        <a onclick="clickTag('all');">All</a>
      </li>
      
      <li>
        <a onclick="clickTag('css');">Css</a>
      </li>
      
      <li>
        <a onclick="clickTag('design');">Design</a>
      </li>
      
      <li>
        <a onclick="clickTag('java');">Java</a>
      </li>
      
      <li>
        <a onclick="clickTag('js');">Js</a>
      </li>
      
      <li>
        <a onclick="clickTag('linux');">Linux</a>
      </li>
      
      <li>
        <a onclick="clickTag('other');">Other</a>
      </li>
      
      <li>
        <a onclick="clickTag('python');">Python</a>
      </li>
      
      <li>
        <a onclick="clickTag('redis');">Redis</a>
      </li>
      
      <li>
        <a onclick="clickTag('spring');">Spring</a>
      </li>
      
    </ul>

    <ul class="nav navbar-nav navbar-right">
      <li>
        <a href="https://gniqizeuy.github.io/en">
          <img src="https://gniqizeuy.github.io//css/blank.gif" class="flag flag-us" alt="English" />
        </a>
      </li>
      <li>
        <a href="https://gniqizeuy.github.io/fr">
          <img src="https://gniqizeuy.github.io//css/blank.gif" class="flag flag-fr" alt="Français" />
        </a>
      </li>
      <li>
        <a href="https://gniqizeuy.github.io/es">
          <img src="https://gniqizeuy.github.io//css/blank.gif" class="flag flag-es" alt="Espanõl" />
        </a>
      </li>
    </ul>
  </div>
</nav>

<div class="container intro">
  <div class="row">
    <div class="col-xs-12">
      
        
        <p><span style="color: red; font-size: 20px">code</span> <span style="color: green; font-size: 20px">eat</span> <span style="color: blue; font-size: 20px">sleep</span></p>
      
    </div>
  </div>
</div>


<div class="container">
  <div class="row">
    <div class="col-xs-12">
      <div class="summary hidden-xs">
        <ol>
          
          <li class="rule tag-java ">
            <a href="#java_file">Java 文件</a>
          </li>
          
          <li class="rule tag-python ">
            <a href="#py_dict">Python 字典</a>
          </li>
          
          <li class="rule tag-python ">
            <a href="#py_set">Python Set</a>
          </li>
          
          <li class="rule tag-python ">
            <a href="#py_summary">Python 总结</a>
          </li>
          
          <li class="rule tag-spring ">
            <a href="#spring_yml">Spring YML</a>
          </li>
          
          <li class="rule tag-linux ">
            <a href="#linux%20%e6%96%87%e4%bb%b6%e4%b8%8e%e7%9b%ae%e5%bd%95%e6%9d%83%e9%99%90">Linux file permissions and directory configuration</a>
          </li>
          
          <li class="rule tag-redis ">
            <a href="#redis_clients">Redis 客户端API</a>
          </li>
          
          <li class="rule tag-js ">
            <a href="#js_storage">Js 客户端存储</a>
          </li>
          
          <li class="rule tag-js ">
            <a href="#js_websocket">Js WebSocket</a>
          </li>
          
          <li class="rule tag-js ">
            <a href="#java_collections">Java 集合与映射</a>
          </li>
          
          <li class="rule tag-Java ">
            <a href="#java_list">Java 抽象数据类型</a>
          </li>
          
          <li class="rule tag-java ">
            <a href="#java_sort">java 排序</a>
          </li>
          
          <li class="rule tag-design ">
            <a href="#design_pattern">设计模式</a>
          </li>
          
          <li class="rule tag-redis ">
            <a href="#redis_string">Redis String</a>
          </li>
          
          <li class="rule tag-redis ">
            <a href="#redis_cmd">Redis 命令</a>
          </li>
          
          <li class="rule tag-redis ">
            <a href="#redis_config">Redis Config</a>
          </li>
          
          <li class="rule tag-redis ">
            <a href="#redis_list">Redis List</a>
          </li>
          
          <li class="rule tag-css ">
            <a href="#css_bg%26bd">CSS 背景与边框</a>
          </li>
          
          <li class="rule tag-other ">
            <a href="#mac">MAC adr</a>
          </li>
          
        </ol>
      </div>
      <div class="summary-small visible-xs">
        <ol>
          
          <li class="rule tag-java ">
            <a href="#java_file">Java 文件</a>
          </li>
          
          <li class="rule tag-spring ">
            <a href="#spring_yml">Spring YML</a>
          </li>
          
          <li class="rule tag-python ">
            <a href="#py_dict">Python 字典</a>
          </li>
          
          <li class="rule tag-python ">
            <a href="#py_set">Python Set</a>
          </li>
          
          <li class="rule tag-python ">
            <a href="#py_summary">Python 总结</a>
          </li>
          
          <li class="rule tag-Java ">
            <a href="#java_list">Java 抽象数据类型</a>
          </li>
          
          <li class="rule tag-java ">
            <a href="#java_sort">java 排序</a>
          </li>
          
          <li class="rule tag-design ">
            <a href="#design_pattern">设计模式</a>
          </li>
          
          <li class="rule tag-js ">
            <a href="#java_collections">Java 集合与映射</a>
          </li>
          
          <li class="rule tag-linux ">
            <a href="#linux%20%e6%96%87%e4%bb%b6%e4%b8%8e%e7%9b%ae%e5%bd%95%e6%9d%83%e9%99%90">Linux file permissions and directory configuration</a>
          </li>
          
          <li class="rule tag-redis ">
            <a href="#redis_clients">Redis 客户端API</a>
          </li>
          
          <li class="rule tag-js ">
            <a href="#js_storage">Js 客户端存储</a>
          </li>
          
          <li class="rule tag-js ">
            <a href="#js_websocket">Js WebSocket</a>
          </li>
          
          <li class="rule tag-redis ">
            <a href="#redis_string">Redis String</a>
          </li>
          
          <li class="rule tag-redis ">
            <a href="#redis_cmd">Redis 命令</a>
          </li>
          
          <li class="rule tag-redis ">
            <a href="#redis_config">Redis Config</a>
          </li>
          
          <li class="rule tag-redis ">
            <a href="#redis_list">Redis List</a>
          </li>
          
          <li class="rule tag-css ">
            <a href="#css_bg%26bd">CSS 背景与边框</a>
          </li>
          
          <li class="rule tag-other ">
            <a href="#mac">MAC adr</a>
          </li>
          
        </ol>
      </div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-java " style="padding-bottom:1em;">

        <div id="java_file"></div>
        <span class="hidden" itemprop="alternateName">java_file</span>

        <h2>
            <a itemprop="url" href="#java_file">
                <span itemprop="name">Java 文件</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/java_file.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">java</span>
        

        <div itemprop="description">
            

<h3 id="toc_0">try-with-resources 优先于 try-finally</h3>

<p>java7 中引入了 try-with-resources语句。要使用这个构造的资源，必须先实现 <strong>AutoCloseable</strong> 接口，其中包含了单个返回 void 的 close 方法。java 类库与第三方类库中许多类和接口，现在都实现或扩展了 AutoCloseable 接口。如果编写了一个类，它代表的是必须被关闭的资源，那么这个类也应该实现 AutoCloseable。</p>

<p>范例1：</p>

<pre><code class="java">static String firstLineOfFile(String path) throws IOException {
    try (BufferedReader br = new BufferReader(new FileReader(path))) {
        return br.readLine();
    }
}
</code></pre>

<p>范例2：</p>

<pre><code class="java">static void copy(String src, String dst) throws IOException {
    try (
        InputStream in = new FileInputStream(src);
        OutputStream out = new FileOutputStream(dst)
    ) {
        byte[] buf = new byte[BUFFER_SIZE];
        int n;
        while ((n = in.read(buf)) &gt;= 0)
            out.write(buf, 0, n);
    }
}
</code></pre>

<p>使用 try-with-resources 不仅使代码变得简洁易懂，也更容易诊断。以 firstLineOfFile 方法为例，如果调用 readline 和（不可见）close 方法都抛出异常，后一个异常就会被禁止，以保留第一个异常。事实上，为了保留你想看到的那个异常，即便多个异常都可以被禁止。这些被禁止的异常并不是简单地被抛弃了，而是会被打印在堆栈轨迹中，并注明它们是被禁止的异常。通过编程调用 getSuppressed 方法还可以访问到它们，getSuppressed 方法也添加在 java 7  的 Throwable 中</p>

<p>在 try-with-resources 语句中还可以使用 catch 子句，和 try-finally 语句一样。这样既可以处理异常，又不需要再套用一层代码。</p>

<pre><code class="java">static String firstLineOfFile(String path, String defaultVal) {
    try (BufferedReader br = new BufferedReader(new FileReader(path))) {
        return br.readLine();
    } catch (IOException e) {
        return dafaultVal
    }
}
</code></pre>

<p>firstLineOfFile 方法没有抛出异常，但是如果它无法打开文件，或者无法从中读取，就会返回一个默认值。在处理必须关闭的资源时，始终要优先考虑用try-with-resources，而不是用 try-finally。这样得到的代码将更加简洁、清晰、产生的异常也更有价值。</p>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-python " style="padding-bottom:1em;">

        <div id="py_summary"></div>
        <span class="hidden" itemprop="alternateName">py_summary</span>

        <h2>
            <a itemprop="url" href="#py_summary">
                <span itemprop="name">Python 总结</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/py_summary.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">python</span>
        

        <div itemprop="description">
            

<h2 id="toc_0">写给大忙人看</h2>

<h5 id="toc_1">哈哈哈，若感兴趣可点击相应文章查阅（其实只有你会看）😀小丑竟是我自己。</h5>

<h4 id="toc_2">字面量与构造方法</h4>

<h5 id="toc_3">1. 字典</h5>

<p>（1）字面量</p>

<pre><code class="python">lover = {'name': 'zxl', 'age': 18}
</code></pre>

<p>（2）构造方法
~~~python
lover = dict(&lsquo;name&rsquo;=&lsquo;zxl&rsquo;, &lsquo;age&rsquo;=18)
      = dict(zip([&lsquo;name&rsquo;, &lsquo;age&rsquo;,], [&lsquo;zxl&rsquo;, 18]))
      = dict([(&lsquo;name&rsquo;, &lsquo;zxl&rsquo;), (&lsquo;age&rsquo;, 18)])
      = dict({&lsquo;name&rsquo;: &lsquo;zxl&rsquo;, &lsquo;age&rsquo;: 18})
~~~</p>

<h5 id="toc_4">2. 集合</h5>

<p>（1）字面量(set)</p>

<pre><code class="python">fav_player = {'kobe', 'lebra'}
</code></pre>

<p>（2）构造方法</p>

<pre><code class="python">fav_player = set({'kobe', 'lebra'})
</code></pre>

<p>frozenset没有字面量句法</p>

<pre><code class="python">fav_player = frozenset({'kobe', 'lebra'})
</code></pre>

<p>空集合必须写成 set()，{}只会表示为空字典</p>

<pre><code class="python">empty_set = set()
</code></pre>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-spring " style="padding-bottom:1em;">

        <div id="spring_yml"></div>
        <span class="hidden" itemprop="alternateName">spring_yml</span>

        <h2>
            <a itemprop="url" href="#spring_yml">
                <span itemprop="name">Spring YML</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/spring_yml.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">spring</span>
        

        <div itemprop="description">
            

<h2 id="toc_0">数据格式</h2>

<h3 id="toc_1">基本类型</h3>

<pre><code class="yaml">name: taicang
age: 18
</code></pre>

<h3 id="toc_2">键值对</h3>

<pre><code class="yaml">person:
    name: taicang
    age: 18
</code></pre>

<h3 id="toc_3">数组</h3>

<pre><code class="yaml">favplayer:
    - kobe
    - lebra
</code></pre>

<h2 id="toc_4">读取方式</h2>

<h3 id="toc_5">@Value</h3>

<pre><code class="yaml">server:
    port: 8080
</code></pre>

<pre><code class="java">@Value(&quot;${server.port}&quot;)
private String port
</code></pre>

<h3 id="toc_6">ConfigurationProperties</h3>

<pre><code class="yaml">student:
    name: jackma
    age: 18
</code></pre>

<p>javabean（需prefix (前缀) 参数）</p>

<pre><code class="java">@Component
@Lombok
@ConfigurationProperties(prefix = &quot;student&quot;)
public class Student {
    private String name;

    private Integer age;
}
</code></pre>

<h3 id="toc_7">Environment</h3>

<pre><code class="yaml">mes:
    url: xxxxxxx
</code></pre>

<pre><code class="java">@Resource
private Environment env;

@GetMapping(&quot;/mes&quot;)
public String getMesUrl() {
    String url = env.getProperty(&quot;mes.url&quot;);
    
    return url;
}
</code></pre>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-python " style="padding-bottom:1em;">

        <div id="py_dict"></div>
        <span class="hidden" itemprop="alternateName">py_dict</span>

        <h2>
            <a itemprop="url" href="#py_dict">
                <span itemprop="name">Python 字典</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/py_dict.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">python</span>
        

        <div itemprop="description">
            

<p><font color=red>散列表</font>是字典类型性能出众的根本原因</p>

<p>字典提供了多种构造函数 点击<a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict">Built-in Types</a> 有例子说明创建字典的不同形式</p>

<pre><code class="python">&gt;&gt;&gt; a = dict(one=1, two=2, three=3)
&gt;&gt;&gt; b = {'one': 1, 'two': 2, 'three': 3}
&gt;&gt;&gt; c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
&gt;&gt;&gt; d = dict([('two', 2), ('one', 1), ('three', 3)])
&gt;&gt;&gt; e = dict({'three': 3, 'one': 1, 'two': 2})
&gt;&gt;&gt; a == b == c == d == e
True
</code></pre>

<h5 id="toc_0">字典推导</h5>

<p>自python 2.7以来，列表和生成器表达式的概念移植到字典上,从而有个字典推导（后面还会看到集合推到）</p>

<p>字典推导（dictcomp）可以从<font color=red>任何以键值对作为元素的可选迭代对象</font>中构建字典</p>

<p>下例展示利用字典推导可以把一个装满元组的列表变成两个不同的字典。</p>

<pre><code class="python">&gt;&gt;&gt; simple_list = [
    (1, 'a'),
    (2, 'b'),
    (3, 'c'),
    (4, 'd'),
    (5, 'e'),
    (6, 'f'),
    (7, 'g'),
]

&gt;&gt;&gt; res = {num: char for char num in simple_list}
&gt;&gt;&gt; res
{'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7}

&gt;&gt;&gt; {num: char.upper() for char, code in res.items() if num &lt; 4}
{1: 'a', 2: 'b', 3: 'c'}
</code></pre>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-python " style="padding-bottom:1em;">

        <div id="py_set"></div>
        <span class="hidden" itemprop="alternateName">py_set</span>

        <h2>
            <a itemprop="url" href="#py_set">
                <span itemprop="name">Python Set</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/py_set.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">python</span>
        

        <div itemprop="description">
            

<p>&ldquo;集&rdquo; 这个概念在Pyhton中算是比较年轻的，同时使用率也较低。set和它的不可变姊妹类型frozenset直到Pyhton2.3才首次以模块的形式出现，然后在Python2.6中它们升级成为内置类型</p>

<p>集合的本质是<font color=red>许多唯一对象</font>的集合。因此，集合可以去重：</p>

<pre><code class="python">&gt;&gt;&gt; l = ['spam', 'spam', 'eggs', 'spam']
&gt;&gt;&gt; set(l)
&gt;&gt;&gt; {'eggs', 'spam'}
&gt;&gt;&gt; list(set(l))
&gt;&gt;&gt; ['eggs', 'spam']
</code></pre>

<p>集合中的元素必须是<font color=red>可散列</font>的，set类型本身是不可散列的，但是frozenset可以。因此可以创建一个包含不同frozenset的set。</p>

<p>除了保证唯一性，集合还实现了很多基础的中缀运算符。给定两个集合a和b, <strong>a|b</strong> 返回的是它们的<strong>合集</strong>，</p>

<p><strong>a &amp; b</strong>得到的是<strong>交集</strong>，而a - b得到的是<strong>差集</strong>。合理地利用这些操作，可使代码行数变少，还能减少Python程序的运行时间。亦可使代码更易读，从而更容易判断程序的正确性，因为利用这些运算符可以省去不必要的循环和逻辑操作。</p>

<p>例1：needles中元素在haystack里出现次数，两个变量都是set类型。</p>

<pre><code class="python">found = len(needles &amp; haystack)
</code></pre>

<p>例2：for循环实现。</p>

<pre><code class="python">found =  0
for n in needles
    if n in haystack
        found += 1
</code></pre>

<p>例1比例2速度要快一些，另一方面，例2可以用在任何可迭代对象上，例1则要求两者皆为集合。若没有集合，可随时建立集合，如例3所示。</p>

<p>例3：转化为set进行交集操作</p>

<pre><code class="python">found = len(set(needles) &amp; set(haystack))
</code></pre>

<p>另一种写法</p>

<pre><code class="python">found = len(set(needles).intersection(haystack))
</code></pre>

<p>例3写法会牵制到把对象转化为集合的成本，不过如果 needles 或 haystack 中任一为集合，那么例3的方案比例2更高效。</p>

<p>以上所有例子的运行时间都能在3毫秒左右，在含有10000000个元素的haystack里搜索1000个值，算下来大概时每个元素3微妙。</p>

<p>除了速度极快的查找功能（这归功于背后的散列表），内置的 set 和 frozenset 提供了丰富的功能和操作，不但让创建集合的方式丰富多彩，且对于 set 来讲，我们还可以对集合里已有的元素进行修改。在讨论操作之前，先看下相关的句法。</p>

<h3 id="toc_0">集合字面量</h3>

<p>除空集之外，集合的字面量——{1}、{1, 2}，等到——看起来与数学形式一摸一样。若是空集，则必须写成set()的形式</p>

<p>tip：创建空集，必须使用不带任何参数的构造方法 set()，如果只写成 {} 的形式，跟以前一样，你创建的其实是个空字典</p>

<p>在python3中，除了空集，集合的字符串表示形式总是以 {&hellip;} 的形式出现。</p>

<p>字面量句法 {1, 2, 3} 相比构造方法 (set([1, 2, 3])) 要更快更易读，后者的速度要慢一些，因为Pyhton 必须先从这个名字来查询构造方法，然后新建一个列表，最后再把这个列表传入到构造方法中，但如果是字面量的形式，Python会利用一个专门的叫做 BUILD_SET 的字节码来创建集合。</p>

<p>​</p>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-redis " style="padding-bottom:1em;">

        <div id="redis_clients"></div>
        <span class="hidden" itemprop="alternateName">redis_clients</span>

        <h2>
            <a itemprop="url" href="#redis_clients">
                <span itemprop="name">Redis 客户端API</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/redis_clients.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">redis</span>
        

        <div itemprop="description">
            

<h4 id="toc_0">Python 客户端 redis-py</h4>

<p>redis-py 的基本使用方法、redis-py 的 Pipeline 的使用和 redis-py 的 Lua 脚本使用。</p>

<h4 id="toc_1">获取 redis-py</h4>

<p>redis-py 需要 Python 2.7 以上版本。获取方式如下：</p>

<pre><code class="shell"># 使用 pip 进行安装
pip install redis

# 使用 easy_install 安装
easy_install redis

# 源码安装：以2.10.5为例
wget https://guthub.com/andymccurdy/redis-py/archive/2.10.5.zip
uzip redis-2.10.5.zip
cd redis-2.10.5
# 安装 redis-py
python setup.py install
</code></pre>

<h4 id="toc_2">redis-py 的基本使用方法</h4>

<pre><code class="python">import redis

# 生产客户端连接：需 Redis 实例 IP 和端口两个参数
client = redis.StrictRedis(host='127.0.0.1', port=6379)

# 执行命令，redis-py API 保留了 Redis API 的原始风格
client.set(key, &quot;python-redis&quot;) # True
client.get(key) # world
</code></pre>

<h4 id="toc_3">redis-py 中的 Pipeline 的只使用方法</h4>

<pre><code class="python">pipline = client.pipline(transaction=False) # transaction False 代表不使用事务

# 将命令封装到 Pipline 中，此时命令并没有真正执行
pipline.set('hello', 'world')
pipline.incr('counter')

# 执行 Pipline
result = pipline.execute() # [True, 3]
</code></pre>

<h4 id="toc_4">redis-py 中的 Lua 脚本使用方法</h4>

<p>redid-py 提供了三个重要的函数实现 Lua 脚本的执行：</p>

<pre><code class="python">eval(String script, int keyCount, String... params)
script_load(String script)
evalsha(String sha1, int keyCount, String... params)
</code></pre>

<p>script：Lua 脚本内容；KeyCount：键的个数；params：相关参数 KEYS 和 ARGV。</p>

<p>return redis.call(&lsquo;get&rsquo;, KEYS[1])  在 redis-py 中实现如下</p>

<pre><code class="python">script = 'return redis.call('get', KEYS[1]) '
client.eval(script, 1, 'hello') # world
</code></pre>

<p>script_load 和 evalsha 函数一起使用，首先使用 script_load 将脚本加载到 Redis 中</p>

<pre><code class="python">scriptSha = client.script_load(script)
</code></pre>

<p>evalsha 函数用来执行脚本的哈希值，需要三个参数：</p>

<p>scriptSha：脚本的 SHA1；KeyCount：键的个数；params：相关参数 KEYS 和 ARGV。</p>

<p>执行效果如下</p>

<pre><code class="python">client.evalsha(scriptSha, 1, 'hello')
</code></pre>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-js " style="padding-bottom:1em;">

        <div id="js_storage"></div>
        <span class="hidden" itemprop="alternateName">js_storage</span>

        <h2>
            <a itemprop="url" href="#js_storage">
                <span itemprop="name">Js 客户端存储</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/js_storage.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">js</span>
        

        <div itemprop="description">
            

<p>cookie、浏览器存储API，IndexedDB</p>

<h2 id="toc_0">背景：</h2>

<p>直接在客户端存储用户信息出于用户想要将与自身有关的信息保存在用户的机器上。无聊是登录信息、个人偏好，还是其他数据。Web应用程序提供者需要将它们保存在用户的机器上。对此第一个解决方案就是cookie。cookie是古老的网景公司发明，由一份名为 <em>Persistent Client State: HTTP Cookies</em> 的规范定义。今天 cookie 只是在客户端存储数据的一个选项。</p>

<h3 id="toc_1">1. cookie</h3>

<p>HTTP cookie 通常也叫做 cookie，最初用于在客户端存储会话信息。这个规范要求服务器在响应 HTTP 请求时，通过发送 Set-Cookie HTTP 头部包含会话信息。例下面是包含这个头部的一个 HTTP 响应：</p>

<pre><code>HTTP/1.1 200 OK
Content-type: text/html
Set-Cookie: name=value
Other-header: other-header-value
</code></pre>

<p>这个 HTTP 响应会设置一个名为&rdquo;name&rdquo;，值为&rdquo;value&rdquo;的 cookie。键和值在发送时都会经过 URL 编码。浏览器会存储这些会话信息，并在之后的每个请求中都会通过 HTTP 头部 cookie 再将它们发回服务器，比如：</p>

<pre><code>GET /index.js HTTP/1.1
Cookie: name=value
Other-header: other-header-value
</code></pre>

<p>这些发送回服务器的额外信息可用于唯一标识发送请求的客户端。</p>

<h3 id="toc_2">2. 限制</h3>

<p>cookie 是与特定域绑定的。设置 cookie 后，它会与请求一起发送到创建它的域。这个限制能保证 cookie 中存储的信息只对认可的接收者开放，不被其他域访问。</p>

<p>因为 cookie 存储在客户端机器上，所以为保证它不会被恶意利用，浏览器会施加限制。同时，cookie 也不会占用太多磁盘空间。通常，只要遵守以下大致的限制，就不会在任何浏览器中碰到问题</p>

<ul>
<li>不超过 300 个 cookie；</li>
<li>每个 cookie 不超过 4096 字节；</li>
<li>每个域不超过 20 个 cookie；</li>
<li>每个域不超过 81920 字节。</li>
<li>每个域能设置的 cookie 总数也是受限的，但不同浏览器的限制不同</li>
</ul>

<p>Safari 和 Chrome 对每个域的 cookie 数没有硬性限制。</p>

<p>如果 cookie 总数超过单个域的上限，浏览器就会删除之前设置的 cookie。</p>

<h2 id="toc_3">Web Storage</h2>

<p>Web Storage 的目的是解决通过客户端存储不需要频繁发送回服务器的数据时使用 cookie 的问题。</p>

<p>Web Storage 规范最新的版本是第2版，这一版规范主要有两个目标：</p>

<ul>
<li><p>提供在 cookie 之外的存储会话数据的途径；</p></li>

<li><p>提供跨会话持久化存储大量数据的机制。</p></li>
</ul>

<p>web storage 的第2版定义了两个对象：localStorage 和 sessionStorage。localStorage 是 <strong>永久存储机制</strong>，sessionStorage 是<strong>跨会话</strong>的存储机制。这两种浏览器 API 提供了在浏览器中不受页面刷新影响而存储数据的两种方式。2009年之后所有主要供应商发布的浏览器版本在window 对象上支持 localStorage 和 sessionStorage。（web storage 第一版曾用过 globalStorage，不过现已废弃）。</p>

<p>### Storage 类型</p>

<p>Storage 类型用于保存键值对数据，直到存储空间上限（由浏览器决定）。Storage 的实例与其他对象一样，但增加了以下方法</p>

<ul>
<li>clear()：删除所有值，不在 Firefox 中实现。</li>
<li>getItem(<em>name</em>)：取得给定 <em>name</em> 的值。</li>
<li>key(<em>index</em>)：取得给定数值位置的名称。</li>
<li>removeItem(<em>name</em>)：删除给定的 <em>name</em> 的键值对。</li>
<li>setItem(<em>name</em>, <em>value</em>)：设置给定 <em>name</em> 的值。</li>
</ul>

<p>getItem() 、remove() 和 setItem() 方法可以直接或间接通过 Storage 对象调用。因为每个数据项都作为属性存储在该对象上。所以可以使用点或方括号访问这些属性，通过同样操作来设置值，也可以使用 delete 操作符删除属性。即便如此，通常还是建议使用方法而非属性来执行这些操作，以免意外重写某个已存在的对象成员。</p>

<p>通过 length 属性可以确定 Storage 对象中保存了多少键值对。我们无法确定对象中所有数据占用的空间大小，尽管 IE8 提供了 remainingSpace 属性用于确定还有多少存储空间（以字节计）可用。</p>

<p>Storage 类型只能存储<strong>字符串</strong>。非字符串数据在存储之后会自动转换为字符串。注意，这种转换不能在获取数据时撤销。</p>

<h3 id="toc_4">SessionStorage</h3>

<p>SessionStorage 对象只存储<strong>会话信息</strong>，即数据只会存储到浏览器关闭。这跟浏览器关闭时会消失的会话 cookie 类似。存储在 SessionStorage 中的数据不受页面刷新影响，可以在浏览器崩溃并重启后恢复。（取决于浏览器，Firefox 和 WebKit支持，IE不支持）</p>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-js " style="padding-bottom:1em;">

        <div id="js_websocket"></div>
        <span class="hidden" itemprop="alternateName">js_websocket</span>

        <h2>
            <a itemprop="url" href="#js_websocket">
                <span itemprop="name">Js WebSocket</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/js_websocket.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">js</span>
        

        <div itemprop="description">
            

<p>web socket（套接字）的目标是通过一个长时连接实现与服务器全双工、双向的通信。在js中创建web socket时，一个HTTP请求会发送到服务器以初始化连接。服务器响应后，连接使用HTTP的Upgrade头部从HTTP协议切换到Web Socket协议。这意味着Web Socket不能通过标准Http服务器实现，而必须使用支持该协议的专有服务器。</p>

<p>因为Web Socket使用了自定义协议，所以URL方案（scheme）稍有变化：不能再使用http://或https://，而要使用ws://和wss://。前者是不安全的连接，后者是安全连接。在指定 Web Socket  URL时，必须包含URL方案，因为将来有可能支持其他方案。</p>

<p>使用自定义协议而非HTTP协议的好处是，客户端与服务器之间可以发送非常少的数据，不会对HTTP造成任何负担。使用更小的数据包让Web Socket非常适合带宽和延迟问题比较明显的移动应用。缺点是，定义协议的时间比定义Javascript API要长。Web Socket得到了所有浏览器的支持。</p>

<h3 id="toc_0">API</h3>

<p>创建一个新的 Web Socket，就要实例化一个WebSocket 对象并传入提供连接的URL</p>

<pre><code class="javascript">let socket = new WebSocket(&quot;ws://www.example.con/server.php&quot;)
</code></pre>

<p>　　tip: 必须给WebSocket构造函数传入一个绝对URL。同源策略不适用于WebSocket，因此可以打开到任意站点的连接。至于是否与特定源的页面通信，则完全取决于服务器（在握手阶段就可以确定请求来自哪里）</p>

<p>浏览器会在初始化 WebSocket 对象之后立即创建连接。与XHR类似，WebSocket 也有一个readyState 属性表示当前状态。不过，这个值与XHR中的值不一样。</p>

<ul>
<li>WebSocket.OPENING（0）：连接正在建立。</li>
<li>WebSocket.OPEN（1）：连接已经建立。</li>
<li>WebSokket.CLOSING（2）：连接正在关闭。</li>
<li>WebSocket.CLOSE（3）：连接已经关闭。</li>
</ul>

<p>WebSocket 对象没有 readystatechange 事件，而是有与上述不同状态对应的其他事件。readyState值从0开始。</p>

<p>任何时候都可以调用 close() 方法关闭Web Socket连接：</p>

<pre><code class="javascript">socket.close()
</code></pre>

<h3 id="toc_1">发送和接受数据</h3>

<p>打开Web Socket 之后，可通过连接发送和接收数据。要向服务器发送数据，使用send() 方法并传入一个字符串、ArrayBuffer 或 Blob，如下所示：</p>

<pre><code class="javascript">let socket = new WebSocket(&quot;ws://www.example.con/server.php&quot;)

let stringData = &quot;Hello World!&quot;
let arrayBufferData = Uint8Array.from['f', 'o', 'o']
let blobData = new Blob(['f', 'o', 'o'])

socket.send(stringData)
socket.send(arrayBufferData.buffer)
socket.send(blobData)
</code></pre>

<p>服务器向客户端发送消息时，WebSocket 对象上会触发message事件。这个message事件与其他消息协议类似，可以通过event.data属性访问到有效载荷：</p>

<pre><code class="javascript">socket.onmessage = function(event) {
    let data = event.data
    // 对数据执行某些操作
}
</code></pre>

<p>与通过send()方法发送的数据类似，event.data返回的数据也可能是ArrayBuffer 或 Blob。这由 WebSocket 对象的 binaryType 属性决定，该属性可能是&rdquo;blob&rdquo;或&rdquo;arraybuffer&rdquo;。</p>

<h5 id="toc_2">其他事件</h5>

<p>websocket 对象在连接周期中可能触发3个其他事件。
- open：在连接成功建立时触发。
- error：在发生错误时触发。连接无法续存。
- close：在连接关闭时触发。</p>

<p>WebSocket 对象不支持 DOM Level 2事件监听器，因此需要使用DOM Level 0风格的事件处理程序来监听这些事件：</p>

<pre><code class="javascript">let socket = new WebSocket(&quot;ws://www.example.con/server.php&quot;)
socket.onopen = function() {
    alert(&quot;Connection established.&quot;)
}
socket.onerror = function() {
    alert(&quot;Connection error.&quot;)
}
socket.oncloes = function() {
    alert(&quot;Connection closed.&quot;)
}
</code></pre>

<p>在这些事件中，只有 close 事件的 event 对象上有额外信息。此对象上有3个额外属性：wasClean、code 和 reason。其中，weaClean 是一个布尔值，表示连接是否干净地关闭；code 是一个来自服务器的数值状态码；reason 是一个字符串，包含服务器发来的消息。可以将这些信息显示给用户或记录到日志:</p>

<pre><code class="javascript">socket.onclose = function(event) {
    console.log('as clean? $(event.wasClean) code=${event.code) Rason = ${event.reason}')
}
</code></pre>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-linux " style="padding-bottom:1em;">

        <div id="linux 文件与目录权限"></div>
        <span class="hidden" itemprop="alternateName">linux 文件与目录权限</span>

        <h2>
            <a itemprop="url" href="#linux%20%e6%96%87%e4%bb%b6%e4%b8%8e%e7%9b%ae%e5%bd%95%e6%9d%83%e9%99%90">
                <span itemprop="name">Linux file permissions and directory configuration</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/linux%20%e6%96%87%e4%bb%b6%e4%b8%8e%e7%9b%ae%e5%bd%95%e6%9d%83%e9%99%90.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">linux</span>
        

        <div itemprop="description">
            

<p>linux 是多人多任务环境。为了让各用户具有保密的文件数据，文件权限管理变得很重要。linux 一般将文件可读写的身份分为三个类别：<strong>拥有者（owner）</strong>、<strong>所属群组（group）</strong>、<strong>其他人（others）</strong>，且三种身份各有读（read）、写（write）、执行（execute）等权限。</p>

<h4 id="toc_0">用户与用户组</h4>

<p>·</p>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-Java " style="padding-bottom:1em;">

        <div id="java_list"></div>
        <span class="hidden" itemprop="alternateName">java_list</span>

        <h2>
            <a itemprop="url" href="#java_list">
                <span itemprop="name">Java 抽象数据类型</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/java_list.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">Java</span>
        

        <div itemprop="description">
            

<h3 id="toc_0">抽象数据类型</h3>

<p>　　抽象数据类型（abstract data type，ADT）是带有<strong>一组操作的一些对象的集合</strong></p>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-java " style="padding-bottom:1em;">

        <div id="java_sort"></div>
        <span class="hidden" itemprop="alternateName">java_sort</span>

        <h2>
            <a itemprop="url" href="#java_sort">
                <span itemprop="name">java 排序</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/java_sort.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">java</span>
        

        <div itemprop="description">
            

<h3 id="toc_0">排序算法类的模板</h3>

<pre><code class="java">public class Example {
    public static void stort (Compareable[] a) {
        // 见算法 2.1、2.2、2.3、2.4、2.5 或 2.7
    }
    
    private static boolean less (Comparable v, Comparable w) {
        return v.compareTo(w) &lt; 0;
    }
    
    private static void exah (Comparable[] a, int i, int j) {
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }
    
    private static void show (Comparable[] a) {
        // 在单行中打印数组
        for (int i=0; i&lt;a.length; i++)
            System.out.print(a[i] + &quot;&quot;);
        System.out.println();
    }
    
    private static boolean isStored (Comparable[] a) {
        // 测试数组元素是否有序
        for (int i=1; i&lt;a.length; i++)
            if (less(a[i], a[i-1])) return false;
        return true;
    }
    
    public static void main(String[] args) {
        // 从标准输入读取字符串，将它们排序并输出
        String[] a = In.readString();
        sort(a);
        assert isStored(a);
        show(a);
    }
}
</code></pre>

<h3 id="toc_1">算法2.1 选择排序</h3>

<p>找到数组中最小的元素，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素则它和自己交换。）再在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。此为*选择排序*，因为它在不断选择剩余元素之中的最小值。</p>

<pre><code class="java">public class Selection {
    public static void sort(Comparable[] a) {
        // 将 a[] 按升序排序
        for (int i=0; i&lt;N; i++) {
            // 将 a[i] 和 a[i+1..N] 中最小的元素交换
            int min = i;
            for (int j = i+1; j&lt;N; j++)
                if (less(a[j], a[min])) min = j;
            exah(a, i, min);
        }
    }
    // less()、exch()、isSorted() 和 main() 方法见 “排序算法类模板”
}
</code></pre>

<h3 id="toc_2">算法2.2 插入排序</h3>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-design " style="padding-bottom:1em;">

        <div id="design_pattern"></div>
        <span class="hidden" itemprop="alternateName">design_pattern</span>

        <h2>
            <a itemprop="url" href="#design_pattern">
                <span itemprop="name">设计模式</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/design_pattern.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">design</span>
        

        <div itemprop="description">
            

<h2 id="toc_0">设计模式怎么解决设计问题</h2>

<h4 id="toc_1">寻找合适的对象</h4>

<p>　　面向对象程序由对象组成，对象包括数据和对数据操作的过程，过程通常称为方法或操作。对象在收到客户的请求或消息后，执行相应的操作。</p>

<p>　　客户请求是使对象<strong>执行操作的唯一方法</strong>，操作由是对象<strong>改变内部数据的唯一方法</strong>。由于这些限制，对象的内部状态是封装的，它不能被直接访问，它的表示对于对象外部是不可见的。</p>

<p>面向对象设计最困难的部分是<strong>将系统分解成对象集合</strong>。因为要考虑许多因素：封装、粒度、依赖关系、灵活性、性能、演化、复用等。他们都影响着系统的分解，并且这些因素通常还是互相冲突的。</p>

<p>　　面向对象设计方法学支持多种设计方法。你可以写出一个问题描述，挑出名词和动词，进而创建相应的类和操作；或者，你可以关注系统的协作和职责关系；或者，你可以对现实世界建模，再将分析时发现的对象转化至设计中，至于哪一种方法最好，并无定论。</p>

<p>　　设计的许多对象来源于现实世界的分析模型。但是，设计结果所得到的类通常在现实世界中并不存在，有些是像数组之类的低层类，而另一些则层次较高，例如，Composite 模式引入了统一对待现实世界中并不存在的对象的抽象方法。严格反应当前现实世界的模型并不能产生也能反映将来世界的系统。<strong>设计中的抽象对于产生灵活的设计是至关重要的</strong>。</p>

<p>　　设计模式帮你<strong>确定并不明显的抽象和描述这些抽象的对象</strong>。例如，描述过程或算法的对象现实中并不存在，但他们确实设计的关键部分。Strategy 模式描述了怎么实现可互换的算法族。State 模式将实体的每一个状态描述为一个对象。这些对象在分析阶段，甚至在设计阶段的早期并不存在，后来为使设计更加灵活、复用性更好才将他们发掘出来。</p>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-js " style="padding-bottom:1em;">

        <div id="java_collections"></div>
        <span class="hidden" itemprop="alternateName">java_collections</span>

        <h2>
            <a itemprop="url" href="#java_collections">
                <span itemprop="name">Java 集合与映射</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/java_collections.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">js</span>
        

        <div itemprop="description">
            

<h3 id="toc_0">标准库中的集合与映射</h3>

<p>####　关于 Set 接口</p>

<p>Set 接口代表不允许重复元的 Collection。由接口 SortedSet 给出的一种特殊类型的 Set 保证其中的各项处于有序的状态。因为一个</p>

<p>Set IS-A Collection，所以用于访问继承 Collection 的 List 的项的方法也对 Set 有效。</p>

<p>由 Set 所要求的一些特殊的操作是一些插入，删除以及（有效地）执行基本查找的能力。对于 Set，add 方法如果执行成功则返回 true，否则返回 false，因为被添加的项已经存在。保持各项以有序状态的 Set 的实现是 TreeSet。TreeSet 类的基本操作花费对数最坏情形时间。</p>

<p>默认情况下，排序假设 TreeSet 中的项实现 Comparable 接口。另一种排序可以通过用 Comparator 实例化 TreeSet 来确定。例如，可以创建一个存储 String 对象的 TreeSet，通过使用 CaseInsensitiveCompare 函数对象忽略大小写。下面代码中，Set s 大小为1。</p>

<pre><code class="java">Class CaseInsensitiveCompare implements Comparator&lt;String&gt; {
    public int compare(String lhs, String rhs) {
        return lhs.compareToIgnoreCase(rhs);
    }
}

Set&lt;String&gt; s = new TreeSet&lt;&gt;(new CaseInsensitiveCompare());
s.add(&quot;Hello&quot;);
s.add(&quot;HeLLo&quot;);
System.out.print(&quot;The size is: &quot; + s.size());
</code></pre>

<h4 id="toc_1">关于 Map 接口</h4>

<p>Map 是一个接口，代表由键以及值组成的一些项的集合。键唯一。在 SortedMap 接口中，映射中的关键字保持逻辑上有序状态。SortedMap 接口的一种实现是 TreeMap 类。Map的基本操作包括诸如 isEmpty、clear、size 等方法，而且最重要的是包含以下方法：</p>

<pre><code class="java">boolean containsKey(keyType key);
ValueType get(keyType key);
ValueType put(KeyType key, ValueType value);
</code></pre>

<p>get 返回 Map 中与 key 相关的值，或当 key 不存在时返回 null。如果在 Map 中不存在 null 值，那么由 get 返回的值可以用来确定 key 是否存在 Map 中。然而，如果存在 null，那么必须使用 containsKey。方法 put 把键值对置入 Map 中，或者返回 null，或者返回与key 相联系的值。</p>

<p>通过一个 Map 进行迭代要比 Collection 复杂，因为 Map 不提供迭代器，而是根据 3 种方法，将 Map 对象的视图作为 Collection 对象返回。由于这些视图本身就是 Collection，因此它们可以被迭代。所提供的 3 种方法如下：</p>

<pre><code class="java">Set&lt;KeyType&gt; keySet();
Collection&lt;ValueType&gt; values();
Set&lt;Map.Entry&lt;KeyType, ValueType&gt;&gt; entrySet()
</code></pre>

<p>方法 keySet 和 values 返回简单的集合（键不包含重复元，因此以一个 Set 对象的形式返回）。entrySet 方法是作为一些项而形成的 Set 对象被返回的（由于键唯一，因此不存在重复项）。每一项均由被嵌套的接口 Map.Entry 表示。对于类型 Map.Entry 的对象，其现有的方法包含访问键、键的值、以及改变键对应的值：</p>

<pre><code class="java">KeyType getKey();
ValueType getValue();
ValueType setValue(ValueType newValue);
</code></pre>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-redis " style="padding-bottom:1em;">

        <div id="redis_string"></div>
        <span class="hidden" itemprop="alternateName">redis_string</span>

        <h2>
            <a itemprop="url" href="#redis_string">
                <span itemprop="name">Redis String</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/redis_string.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">redis</span>
        

        <div itemprop="description">
            

<h3 id="toc_0">字符串</h3>

<h4 id="toc_1">1 常用命令</h4>

<p>(1) 设置值</p>

<pre><code class="shell">set key value [ex seconds] [px milliseconds] [nx|xx]
</code></pre>

<p>set 命令有几个选项</p>

<ul>
<li>ex seconds：为键设置秒级过期时间。</li>
<li>px milliseconds：为键设置毫秒级过期时间</li>
<li>nx： 键必须不存在，才可以设置成功，用于添加</li>
<li>xx：与nx相反，键必须存在，才可以设置成功，用于更新</li>
</ul>

<p>除了 set 选项，Redis 还提供了 setex 和 setnx 两个命令</p>

<pre><code class="shell">setnx key seconds value
setnx key value
</code></pre>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-redis " style="padding-bottom:1em;">

        <div id="redis_cmd"></div>
        <span class="hidden" itemprop="alternateName">redis_cmd</span>

        <h2>
            <a itemprop="url" href="#redis_cmd">
                <span itemprop="name">Redis 命令</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/redis_cmd.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">redis</span>
        

        <div itemprop="description">
            

<h3 id="toc_0">全局命令</h3>

<h5 id="toc_1">1. 查看所有键：</h5>

<pre><code class="shell">keys *
</code></pre>

<h5 id="toc_2">2. 键总数：</h5>

<pre><code class="shell">dbsize
</code></pre>

<h5 id="toc_3">3. 检查键是否存在</h5>

<pre><code class="shell">exists key # 存在返回1，不存在返回0
</code></pre>

<h5 id="toc_4">4. 删除键</h5>

<pre><code class="shell">del key [key ...] # 通用命令 无论值是什么类型都可删除 返回结果为成功删除键的个数，删除不存在的键，就会返回0
</code></pre>

<h5 id="toc_5">5. 键过期</h5>

<pre><code class="shell">expire key seconds
</code></pre>

<p>ttl 命令返回键的剩余过期时间，有三种返回值</p>

<ul>
<li>大于等于0的整数：键剩余的过期时间</li>
<li>-1：键没设置过期时间</li>
<li>-2：键不存在</li>
</ul>

<h5 id="toc_6">6. 键的数据结构类型</h5>

<pre><code class="shell">type key # 键不存在，则返回none
</code></pre>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-redis " style="padding-bottom:1em;">

        <div id="redis_config"></div>
        <span class="hidden" itemprop="alternateName">redis_config</span>

        <h2>
            <a itemprop="url" href="#redis_config">
                <span itemprop="name">Redis Config</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/redis_config.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">redis</span>
        

        <div itemprop="description">
            

<h3 id="toc_0">启动</h3>

<h4 id="toc_1">默认配置</h4>

<p>redis-service  建议使用配置文件启动</p>

<h4 id="toc_2">运行配置</h4>

<p>redis-service &ndash;configKey &ndash;configValue &ndash;configKey2 &ndash; configValue2</p>

<p>例：redis-server &ndash;port &ndash;6379</p>

<h4 id="toc_3">配置文件启动</h4>

<p>例：配置文件写在/opt/redis/redis.config</p>

<p>redis-server /opt/redis/redis.config</p>

<p>一些重要配置如下</p>

<table>
<thead>
<tr>
<td>配置名</td>
<td>配置说明</td>
</tr>
</thead>

<tbody>
<tr>
<td>port</td>
<td>端口</td>
</tr>

<tr>
<td>logfile</td>
<td>日志文件</td>
</tr>

<tr>
<td>dir</td>
<td>Redis工作目录（存放持久化文件和日志文件）</td>
</tr>

<tr>
<td>dacmonize</td>
<td>是否以守护进程的方式启动Redis</td>
</tr>
</tbody>
</table>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-redis " style="padding-bottom:1em;">

        <div id="redis_list"></div>
        <span class="hidden" itemprop="alternateName">redis_list</span>

        <h2>
            <a itemprop="url" href="#redis_list">
                <span itemprop="name">Redis List</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/redis_list.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">redis</span>
        

        <div itemprop="description">
            

<h3 id="toc_0">列表</h3>

<p>列表的四种操作类型</p>

<table>
<thead>
<tr>
<td>操作类型</td>
<td>操作</td>
</tr>
</thead>

<tbody>
<tr>
<td>添加</td>
<td>rpush    lpush    linsert</td>
</tr>

<tr>
<td>查</td>
<td>lrange    lindex   len</td>
</tr>

<tr>
<td>删除</td>
<td>lpop     rpop     lrem    ltrim</td>
</tr>

<tr>
<td>修改</td>
<td>lset</td>
</tr>

<tr>
<td>阻塞操作</td>
<td>blop   brpop</td>
</tr>
</tbody>
</table>

<h5 id="toc_1">1.添加操作</h5>

<p>（1）从右边插入元素</p>

<pre><code class="shell">rpush key value [value ...]
</code></pre>

<p>lrang 0 -1 命令可以从左到右获取列表的所有元素</p>

<p>（2）从左边插入元素</p>

<pre><code class="shell">lpush key value [value ....]
</code></pre>

<p>（3）向某个元素前或者后插入元素</p>

<pre><code class="shell">linsert key before|after privot value
</code></pre>

<p>linsert 命令会从列表中找到等于pivot的元素，在其前（before）或者后（after）插入新元素value</p>

<p>返回当前命令长度</p>

<h5 id="toc_2">2.查找</h5>

<p>（1）获取指定范围内的元素列表</p>

<pre><code class="powershell">lrange key start end
</code></pre>

<p>lrange操作会获取列表指定索引范围所有的元素。索引下标有两个特点：</p>

<p>第一，索引下标从左到右分别是0到N-1，但从右到左分别是-1 到 -N</p>

<p>第二，lrange中的end选项包含了自身</p>

<p>（2）获取列表指定索引下标的元素</p>

<pre><code class="powershell">lindex key index
</code></pre>

<p>（3）获取列表长度</p>

<pre><code class="powershell">llen key
</code></pre>

<h5 id="toc_3">3.删除</h5>

<p>（1）从列表左侧弹出元素</p>

<pre><code class="powershell">lpop key
</code></pre>

<p>（2）从列表右侧弹出</p>

<pre><code class="powershell">rpop key
</code></pre>

<p>（3）删除指定元素</p>

<pre><code class="powershell">lrem key count value
</code></pre>

<p>lrem 会从列表中找到等于value 的元素进行删除，根据count的不同分为三种情况：</p>

<ul>
<li>count&gt;0，从左到右，删除最多count个元素。</li>
<li>count&lt;0，从右到左，删除最多count绝对值个元素</li>
<li>count=0，删除所有</li>
</ul>

<p>（4）按照索引范围修剪列表</p>

<pre><code class="powershell">ltrim key start end
</code></pre>

<h5 id="toc_4">4. 修改</h5>

<p>修改指定索引下标的元素：</p>

<pre><code class="powershell">lset key index newValue
</code></pre>

<h5 id="toc_5">5. 阻塞操作</h5>

<p>阻塞式弹出如下：</p>

<pre><code class="powershell">blpop key [key ...] timout
brpop key [key ...] timout
</code></pre>

<p>blpop 和 brpop 是 lpop 和 rpop 的阻塞版本，它们除了弹出方式不同，使用方法基本相同，所以下面以brpop命令进行说明,brpop命令包含两个参数:</p>

<ul>
<li><p>key [key &hellip;]：多个列表的键。</p></li>

<li><p>timeout：阻塞时间（单位：秒）</p></li>
</ul>

<p>1）列表为空：如果 timeout=3，那么客户端要等到 3 秒后返回，timeout=0，客户端会一直阻塞等下去</p>

<pre><code class="powershell">127.0.0.1:6379&gt; brpop list:test 3
(nill)
(3.10s)
127.0.0.1:6379&gt; brpop list:test 3
...阻塞...
</code></pre>

<p>如果此期间添加了数据 element1，客户端立即返回：</p>

<pre><code class="powershell">127.0.0.1:6379&gt; brpop list:test 3
1) &quot;list:test&quot;
2) &quot;element1&quot;
(2.06s)
</code></pre>

<p>2）列表不为空：客户端会立刻返回。</p>

<pre><code class="powershell">127.0.0.1:6379&gt; brpop list:test 0
1) &quot;list:test&quot;
2) &quot;element1&quot;
</code></pre>

<p>在使用 bprop 时，有两点需要注意。</p>

<p>第一点，如果是多个键，那么 brpop 会从左至右遍历键，一旦有个键能弹出元素，客户端立即回：</p>

<pre><code class="powershell">127.0.0.1:6379&gt; brpop list:1 list:2 list:3
...阻塞...
</code></pre>

<p>此时另一个客户端分别向 list:2 和 list:3 插入元素：</p>

<pre><code class="powershell">client-lpush&gt; lpush list:2 element2
(integer) 1
client-lpush&gt; lpish list:3 element3
(integer) 1
</code></pre>

<p>客户端会立即返回 list:2 中的 element2，因为 list:2 最先有可能弹出的元素：</p>

<pre><code class="powershell">127.0.0.1：6379&gt; bprop list:1 list:2 list:3 0
1) &quot;list:2&quot;
2) &quot;element2_1&quot;
</code></pre>

<p>第二点，如果多个客户端对同一个键执行 bprop，那么最先执行 brpop 命令的客户端可以获取到出的值：
客户端1：</p>

<pre><code class="powershell">client-1&gt; bprop list:test 0
...阻塞...
</code></pre>

<p>客户端2：</p>

<pre><code class="powershell">client-2&gt; bprop list:test 0
...阻塞...
</code></pre>

<p>客户端3：</p>

<pre><code class="powershell">client-3&gt; bprop list:test 0
...阻塞...
</code></pre>

<p>此时另一个客户端 lpush 一个元素到 list:test 列表中：</p>

<pre><code class="powershell">client-lpush&gt; lpush list:test element
(integer) 1
</code></pre>

<p>那么客户端 1 最会获取到元素，因为客户端 1 最先执行 brpop，而客户端2 和 3 继续阻塞</p>

<pre><code class="powershell">client&gt; bprop list:test 0
1) &quot;list:test&quot;
2) &quot;elememt&quot;  
</code></pre>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-css " style="padding-bottom:1em;">

        <div id="css_bg&amp;bd"></div>
        <span class="hidden" itemprop="alternateName">css_bg&amp;bd</span>

        <h2>
            <a itemprop="url" href="#css_bg%26bd">
                <span itemprop="name">CSS 背景与边框</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/css_bg&amp;bd.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">css</span>
        

        <div itemprop="description">
            

<h3 id="toc_0">半透明边框（RGBA/HSLA 颜色）</h3>

<p>给容器一个白色背景和一道半透明的白色边框</p>

<pre><code class="css">border: 10px solid hsla(0.0%,100%,.5);
background: white;
</code></pre>

<p>上述 css 并不会达到需求，背景的白色会透过边框显示出来</p>

<pre><code class="css">border: 10px solid hsla(0.0%,100%,.5);
background: white;
background-clip: padding-box;
</code></pre>

<p>css3 中 使用 background-clip（初始值为 border-clip 意味背景会被元素的 border box 边框的外延框裁切掉。）如果不想背景侵入边框所在的范围，即把值设为</p>

<p>padding-box，这样浏览器就会用内边距的外延来把背景裁切掉。</p>

<h3 id="toc_1">多重边框（box-shadow）</h3>

<p>box-shadow 可接收第四个参数（称作扩张半径）,通过指定正负值，可让<strong>投影面积加大</strong>或<strong>减小</strong>。一个正值的扩张半径加上两个为零的偏移量以及为零的模糊值，得到的投影其实就像一道实线边框</p>

<pre><code class="css">background: yellowgreen;
box-shadow: 0 0 0 10px #655;
</code></pre>

<p>border 属性可生产完全一致的效果。不过 box-shadow 好处在于，<strong>它支持逗号分割法，我们可以创建任意数量的投影</strong>，因此，上例中可非常轻松的加上一道 deeppink 颜色的边框。</p>

<pre><code class="css">background: yellowgreen;
box-shadow: 0 0 0 10px #655, 0 0 0 15px deeppink;
</code></pre>

<p>唯一需要注意的是，box-shadow 是层层叠加的，第一层投影位于最顶层，依次类推。因此。需要按此规律调整扩张半径。比如说，在前面代码中还想在外圈再加一道 5px 的外框吗，那就需指定扩张半径的值为 15px（10px + 5px）还可以在这些边框的底下再加一层常规的投影</p>

<pre><code class="css">background: yellowgreen;
box-shadow: 0 0 0 10px #655,
            0 0 0 15px deeppink,
            0 2px 5px 15px rgba(0,0,0,.6)
</code></pre>

<p>多重投影解决方案在大多数场合下可以很好工作，但有一些注意事项：</p>

<ul>
<li><p>投影的行为和边框不完全一致，因为它不影响布局，而且也不会受到box-sizing 属性的影响。不过，可以通过内边距或外边距（取决于投影是内嵌还是外扩的）来额外模拟出边框所需要占据的空间</p></li>

<li><p>上述方法创建出的假边框出现在元素的<strong>外圈</strong>。它们并不会影响鼠标事件，比如悬停或点击。如果这一点非常重要，你可以给 box-shadow 属性加上 inset 关键字，来使投影绘制在元素的<strong>内圈</strong>。注意，此时需要你增加额外的内边距来腾出足够的空隙。</p></li>
</ul>

<h4 id="toc_2">outline 方案</h4>

<p>某些情况下，<strong>可能只需要两层边框</strong>，那就可以先设置一层常规边框，再加上outline（描边）属性来产生外层的边框。这样做边框样式十分灵活，不像上面的 box-shadow 方案只能模拟实线边框（box-shadow 无法模拟虚线边框）下例实现双层边框</p>

<pre><code class="css">background: yellowgreen;
border: 10px solid #655;
outline: 5px solid deeppink;
</code></pre>

<p>描边的另一个好处在于，可以通过 outline-offset 属性来控制它跟元素边缘之间的间距，这个属性可以接收负值。</p>

<p>这个方案同样存在一些注意点：</p>

<ul>
<li>如上所述，它只适用于双层“边框”的场景，因为 outline 并不能接受用逗号分隔的多个值。如果需要更多层的边框，只能采取前一种方案。</li>
<li>边框不一定会贴合 border-radius 属性产生的圆角，因此如果元素是圆角的，他的描边可能还是直角的。注意，此行为被 CSS 工作组认为是一个 bug，因此未来可能会改为整合 border-radius 圆角。</li>
<li>根据 CSS 基本 UI 特征（第三版规范）所述。“描边可以不是矩形”。尽管在绝大多数情况下，描边都是矩形，但如果你想使用这个方法，请切记：最好在不同浏览器中完整地测试最终效果。</li>
</ul>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
	    <section itemscope itemtype="http://schema.org/Property"> 
    <div class="col-xs-12 rule tag-other " style="padding-bottom:1em;">

        <div id="mac"></div>
        <span class="hidden" itemprop="alternateName">mac</span>

        <h2>
            <a itemprop="url" href="#mac">
                <span itemprop="name">MAC adr</span>
            </a>
        </h2>

        <a href="https://github.com/checkmyws/yslow-rules/edit/master/content/en/mac.md" target="_blank">
            <span class="pull-right glyphicon glyphicon-edit"></span>
        </a>

        Tags:
        
            <span class="tags label label-default">other</span>
        

        <div itemprop="description">
            

<p><strong>MAC地址</strong>（<strong>英语：Media Access Control Address）</strong>，直译为<strong>媒体访问控制地址</strong>，也称为<strong>局域网地址</strong>（LAN Address），<strong>以太网地址</strong>（Ethernet Address）或<strong>物理地址</strong>（Physical Address），它是一个用来确认网络设备位置的地址。在<a href="https://zh.wikipedia.org/wiki/OSI模型">OSI模型</a>中，第三层网络层负责IP地址，第二层数据链接层则负责MAC地址。MAC地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址。</p>

<h2 id="toc_0">格式</h2>

<p>MAC地址共48位（6个字节），以十六进制表示。</p>

<p>第1Bit为广播地址(0)/群播地址(1)，第2Bit为广域地址(0)/区域地址(1)。前3~24位由<a href="https://zh.wikipedia.org/wiki/IEEE">IEEE</a>决定如何分配给每一家制造商，且不重复，后24位由实际生产该网络设备的厂商自行指定且不重复。</p>

<p>ff:ff:ff:ff:ff:ff则作为广播地址。</p>

<p>01:xx:xx:xx:xx:xx是多播地址，01:00:5e:xx:xx:xx是<a href="https://zh.wikipedia.org/wiki/IPv4">IPv4</a>多播地址。</p>

<h2 id="toc_1">举例</h2>

<p>假设现有一台路由器，含有一个WAN端口及四个LAN端口。它的WAN端口会有一个如61.61.61.61的IP地址，也会有一个如00:0A:02:0B:03:0C的MAC地址。而它的四个LAN端口会各分配到一个例如192.168.1.0/24的IP地址，四个端口各会有一个不同的MAC地址。</p>

<h2 id="toc_2">查看MAC地址</h2>

<h3 id="toc_3">Windows</h3>

<p>在Windows命令提示符（cmd.exe）下运行 ipconfig /all 命令。假设运行结果含：</p>

<pre><code class="powershell">        Physical Address. . . . . . . . . : 00-05-5D-E8-0F-A3
</code></pre>

<p>那么其中的00-05-5D-E8-0F-A3就是本机网卡的MAC地址。如果计算机上有多个网络设备（无论物理或虚拟），则会有多组信息及MAC地址，需辨识相应的设备。</p>

<h3 id="toc_4">Linux</h3>

<p>第一种： 在 Linux下运行 ifconfig 命令，如下：</p>

<pre><code class="shell"> $ ifconfig
 eth0    Link encap:Ethernet HWaddr 00:0C:29:01:98:27
         inet addr:192.168.1.88  Bcast:192.168.1.255  Mask:255.255.255.0
         UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
         RX packets:74978 errors:0 dropped:0 overruns:0 frame:0
         TX packets:38451 errors:0 dropped:0 overruns:0 carrier:0
         collisions:0 txqueuelen:100
         RX bytes:14157042 (13.5 Mb)  TX bytes:5063398 (4.8 Mb)
         Interrupt:18 Base address:0x1080
 
 lo      Link encap:Local Loopback
         inet addr:127.0.0.1  Mask:255.0.0.0
         UP LOOPBACK RUNNING  MTU:16436  Metric:1
         RX packets:1097 errors:0 dropped:0 overruns:0 frame:0
         TX packets:1097 errors:0 dropped:0 overruns:0 carrier:0
         collisions:0 txqueuelen:0
         RX bytes:151393 (147.8 Kb)  TX bytes:151393 (147.8 Kb)
</code></pre>

<p>eth0 为第一块物理网卡， HWaddr 00:0C:29:01:98:27 就是MAC地址，lo为本地回环地址。</p>

<p>第二种： 运行 ip命令(是一个命令，不是Tcp/Ip里的ip)，示例如下：</p>

<pre><code> $ ip link show
 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
 2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 28:d2:44:d4:e6:ea brd ff:ff:ff:ff:ff:ff
</code></pre>

<p>其中$是linux下的命令提示符，一般情况下：$ 表示一般用户，# 表示root用户</p>

<h2 id="toc_5">如何修改MAC地址</h2>

<p>网卡MAC地址可以通过Windows设备管理员或其他工具修改。对于某些手机、平板电脑设备来说，其MAC地址／产品序号均由厂方连同销售或保修时的客户资料一并记录在案，而有关的MAC地址也不可通过常规手段来修改。</p>

        </div>
        <br>
        <a href="#top">Top</a> | <a itemprop="sameAs" href="http://developer.yahoo.com/performance/rules.html#cdn">Reference</a>
    </div>
</section>
	  
  </div>
</div>


<hr>
<div class="container footer">
  <div class="row">
    <div class="col-xs-12 text-center">
		YSlow are licensed under the <a href="https://raw.github.com/marcelduran/yslow/master/LICENSE.txt">New BSD License</a>.<br>
		YSlow also includes files from the <a href="http://yuilibrary.com/">Yahoo! User Interface library</a>, which are licensed under the <a href="http://yuilibrary.com/license/">BSD license</a>.<br>
		Translations are licensed under the <a href="https://raw.github.com/checkmyws/yslow-rules/master/LICENSE">MIT License</a>.<br>
		Powered by <a href="http://hugo.spf13.com/">Hugo</a>.
    </div>
  </div>
</div>
    <noscript></noscript>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script>
    <script src="https://gniqizeuy.github.io//js/main.js"></script>
  </body>
</html>