redis_list
Redis List
redis 


<h3 id="toc_0">列表</h3>

<p>列表的四种操作类型</p>

<table>
<thead>
<tr>
<td>操作类型</td>
<td>操作</td>
</tr>
</thead>

<tbody>
<tr>
<td>添加</td>
<td>rpush    lpush    linsert</td>
</tr>

<tr>
<td>查</td>
<td>lrange    lindex   len</td>
</tr>

<tr>
<td>删除</td>
<td>lpop     rpop     lrem    ltrim</td>
</tr>

<tr>
<td>修改</td>
<td>lset</td>
</tr>

<tr>
<td>阻塞操作</td>
<td>blop   brpop</td>
</tr>
</tbody>
</table>

<h5 id="toc_1">1.添加操作</h5>

<p>（1）从右边插入元素</p>

<pre><code class="shell">rpush key value [value ...]
</code></pre>

<p>lrang 0 -1 命令可以从左到右获取列表的所有元素</p>

<p>（2）从左边插入元素</p>

<pre><code class="shell">lpush key value [value ....]
</code></pre>

<p>（3）向某个元素前或者后插入元素</p>

<pre><code class="shell">linsert key before|after privot value
</code></pre>

<p>linsert 命令会从列表中找到等于pivot的元素，在其前（before）或者后（after）插入新元素value</p>

<p>返回当前命令长度</p>

<h5 id="toc_2">2.查找</h5>

<p>（1）获取指定范围内的元素列表</p>

<pre><code class="powershell">lrange key start end
</code></pre>

<p>lrange操作会获取列表指定索引范围所有的元素。索引下标有两个特点：</p>

<p>第一，索引下标从左到右分别是0到N-1，但从右到左分别是-1 到 -N</p>

<p>第二，lrange中的end选项包含了自身</p>

<p>（2）获取列表指定索引下标的元素</p>

<pre><code class="powershell">lindex key index
</code></pre>

<p>（3）获取列表长度</p>

<pre><code class="powershell">llen key
</code></pre>

<h5 id="toc_3">3.删除</h5>

<p>（1）从列表左侧弹出元素</p>

<pre><code class="powershell">lpop key
</code></pre>

<p>（2）从列表右侧弹出</p>

<pre><code class="powershell">rpop key
</code></pre>

<p>（3）删除指定元素</p>

<pre><code class="powershell">lrem key count value
</code></pre>

<p>lrem 会从列表中找到等于value 的元素进行删除，根据count的不同分为三种情况：</p>

<ul>
<li>count&gt;0，从左到右，删除最多count个元素。</li>
<li>count&lt;0，从右到左，删除最多count绝对值个元素</li>
<li>count=0，删除所有</li>
</ul>

<p>（4）按照索引范围修剪列表</p>

<pre><code class="powershell">ltrim key start end
</code></pre>

<h5 id="toc_4">4. 修改</h5>

<p>修改指定索引下标的元素：</p>

<pre><code class="powershell">lset key index newValue
</code></pre>

<h5 id="toc_5">5. 阻塞操作</h5>

<p>阻塞式弹出如下：</p>

<pre><code class="powershell">blpop key [key ...] timout
brpop key [key ...] timout
</code></pre>

<p>　　blpop 和 brpop 是 lpop 和 rpop 的阻塞版本，它们除了弹出方式不同，使用方法基本相同，所以下面以brpop命令进行说明,brpop命令包含两个参数:</p>

<ul>
<li><p>key [key &hellip;]：多个列表的键。</p></li>

<li><p>timeout：阻塞时间（单位：秒）</p></li>
</ul>

<p>1）列表为空：如果 timeout=3，那么客户端要等到 3 秒后返回，timeout=0，客户端会一直阻塞等下去</p>

<pre><code>  127.0.0.1:6379&gt; brpop list:test 3
  (nill)
  (3.10s)
  127.0.0.1:6379&gt; brpop list:test 3
  ...阻塞...
</code></pre>

<p>如果此期间添加了数据 element1，客户端立即返回：</p>

<pre><code>  127.0.0.1:6379&gt; brpop list:test 3
  1) &quot;list:test&quot;
  2) &quot;element1&quot;
  (2.06s)
</code></pre>

<p>2）列表不为空：客户端会立刻返回。</p>

<pre><code>  127.0.0.1:6379&gt; brpop list:test 0
  1) &quot;list:test&quot;
  2) &quot;element1&quot;
</code></pre>

<p>在使用 bprop 时，有两点需要注意。</p>

<p>第一点，如果是多个键，那么 brpop 会从左至右遍历键，一旦有个键能弹出元素，客户端立即返回：</p>

<pre><code>  127.0.0.1:6379&gt; brpop list:1 list:2 list:3
  ...阻塞...
</code></pre>

<p>此时另一个客户端分别向 list:2 和 list:3 插入元素：
  ~~~
  client-lpush&gt; lpush list:2 element2
  (integer) 1
  client-lpush&gt; lpish list:3 element3
  (integer) 1
  ~~~
  客户端会立即返回 list:2 中的 element2，因为 list:2 最先有可能弹出的元素：
  ~~~
  127.0.0.1：6379&gt; bprop list:1 list:2 list:3 0
  1) &ldquo;list:2&rdquo;
  2) &ldquo;element2_1&rdquo;
  ~~~
  第二点，如果多个客户端对同一个键执行 bprop，那么最先执行 brpop 命令的客户端可以获取到弹出的值：
  客户端1：
  ~~~
  client-1&gt; bprop list:test 0
  &hellip;阻塞&hellip;
  ~~~
  客户端2：
  ~~~
  client-2&gt; bprop list:test 0
  &hellip;阻塞&hellip;
  ~~~
  客户端3：
  ~~~
  client-3&gt; bprop list:test 0
  &hellip;阻塞&hellip;
  ~~~
  此时另一个客户端 lpush 一个元素到 list:test 列表中：
  ~~~
  client-lpush&gt; lpush list:test element
  (integer) 1
  ~~~
  那么客户端 1 最会获取到元素，因为客户端 1 最先执行 brpop，而客户端2 和 3 继续阻塞
  ~~~
  client&gt; bprop list:test 0
  1) &ldquo;list:test&rdquo;
  2) &ldquo;elememt&rdquo;</p>

<p>~~~</p>
