redis_list
Redis List
redis 


<h3 id="toc_0">列表</h3>

<p>列表（list）类型是用来存储多个<strong>有序</strong>的字符串，列表类型有两个特点：第一、列表中的元素是有序的，这意味这可以通过索引下标获取某个元素或者某个范围内的元素列表，第二、列表中的元素可以是重复的。</p>

<p>列表的四种操作类型</p>

<table>
<thead>
<tr>
<td>操作类型</td>
<td>操作</td>
</tr>
</thead>

<tbody>
<tr>
<td>添加</td>
<td>rpush    lpush    linsert</td>
</tr>

<tr>
<td>查</td>
<td>lrange    lindex   len</td>
</tr>

<tr>
<td>删除</td>
<td>lpop     rpop     lrem    ltrim</td>
</tr>

<tr>
<td>修改</td>
<td>lset</td>
</tr>

<tr>
<td>阻塞操作</td>
<td>blop   brpop</td>
</tr>
</tbody>
</table>

<h5 id="toc_1">1.添加操作</h5>

<p>（1）从右边插入元素</p>

<pre><code class="shell">rpush key value [value ...]
</code></pre>

<p>lrang 0 -1 命令可以从左到右获取列表的所有元素</p>

<p>（2）从左边插入元素</p>

<pre><code class="shell">lpush key value [value ....]
</code></pre>

<p>（3）向某个元素前或者后插入元素</p>

<pre><code class="shell">linsert key before|after privot value
</code></pre>

<p>linsert 命令会从列表中找到等于pivot的元素，在其前（before）或者后（after）插入新元素value</p>

<p>返回当前命令长度</p>

<h5 id="toc_2">2.查找</h5>

<p>（1）获取指定范围内的元素列表</p>

<pre><code class="powershell">lrange key start end
</code></pre>

<p>lrange操作会获取列表指定索引范围所有的元素。索引下标有两个特点：</p>

<p>第一，索引下标从左到右分别是0到N-1，但从右到左分别是-1 到 -N</p>

<p>第二，lrange中的end选项包含了自身</p>

<p>（2）获取列表指定索引下标的元素</p>

<pre><code class="powershell">lindex key index
</code></pre>

<p>（3）获取列表长度</p>

<pre><code class="powershell">llen key
</code></pre>

<h5 id="toc_3">3.删除</h5>

<p>（1）从列表左侧弹出元素</p>

<pre><code class="powershell">lpop key
</code></pre>

<p>（2）从列表右侧弹出</p>

<pre><code class="powershell">rpop key
</code></pre>

<p>（3）删除指定元素</p>

<pre><code class="powershell">lrem key count value
</code></pre>

<p>lrem 会从列表中找到等于value 的元素进行删除，根据count的不同分为三种情况：</p>

<ul>
<li>count&gt;0，从左到右，删除最多count个元素。</li>
<li>count&lt;0，从右到左，删除最多count绝对值个元素</li>
<li>count=0，删除所有</li>
</ul>

<p>（4）按照索引范围修剪列表</p>

<pre><code class="powershell">ltrim key start end
</code></pre>

<h5 id="toc_4">4. 修改</h5>

<p>修改指定索引下标的元素：</p>

<pre><code class="powershell">lset key index newValue
</code></pre>

<h5 id="toc_5">5. 阻塞操作</h5>

<p>阻塞式弹出如下：</p>

<pre><code class="powershell">blpop key [key ...] timout
brpop key [key ...] timout
</code></pre>

<p>blpop 和 brpop 是 lpop 和 rpop 的阻塞版本，它们除了弹出方式不同，使用方法基本相同，所以下面以brpop命令进行说明,brpop命令包含两个参数:</p>

<ul>
<li><p>key [key &hellip;]：多个列表的键。</p></li>

<li><p>timeout：阻塞时间（单位：秒）</p></li>
</ul>

<p>1）列表为空：如果 timeout=3，那么客户端要等到 3 秒后返回，timeout=0，客户端会一直阻塞等下去</p>

<pre><code class="powershell">127.0.0.1:6379&gt; brpop list:test 3
(nill)
(3.10s)
127.0.0.1:6379&gt; brpop list:test 3
...阻塞...
</code></pre>

<p>如果此期间添加了数据 element1，客户端立即返回：</p>

<pre><code class="powershell">127.0.0.1:6379&gt; brpop list:test 3
1) &quot;list:test&quot;
2) &quot;element1&quot;
(2.06s)
</code></pre>

<p>2）列表不为空：客户端会立刻返回。</p>

<pre><code class="powershell">127.0.0.1:6379&gt; brpop list:test 0
1) &quot;list:test&quot;
2) &quot;element1&quot;
</code></pre>

<p>在使用 bprop 时，有两点需要注意。</p>

<p>第一点，如果是多个键，那么 brpop 会从左至右遍历键，一旦有个键能弹出元素，客户端立即回：</p>

<pre><code class="powershell">127.0.0.1:6379&gt; brpop list:1 list:2 list:3
...阻塞...
</code></pre>

<p>此时另一个客户端分别向 list:2 和 list:3 插入元素：</p>

<pre><code class="powershell">client-lpush&gt; lpush list:2 element2
(integer) 1
client-lpush&gt; lpish list:3 element3
(integer) 1
</code></pre>

<p>客户端会立即返回 list:2 中的 element2，因为 list:2 最先有可能弹出的元素：</p>

<pre><code class="powershell">127.0.0.1：6379&gt; bprop list:1 list:2 list:3 0
1) &quot;list:2&quot;
2) &quot;element2_1&quot;
</code></pre>

<p>第二点，如果多个客户端对同一个键执行 bprop，那么最先执行 brpop 命令的客户端可以获取到出的值：
客户端1：</p>

<pre><code class="powershell">client-1&gt; bprop list:test 0
...阻塞...
</code></pre>

<p>客户端2：</p>

<pre><code class="powershell">client-2&gt; bprop list:test 0
...阻塞...
</code></pre>

<p>客户端3：</p>

<pre><code class="powershell">client-3&gt; bprop list:test 0
...阻塞...
</code></pre>

<p>此时另一个客户端 lpush 一个元素到 list:test 列表中：</p>

<pre><code class="powershell">client-lpush&gt; lpush list:test element
(integer) 1
</code></pre>

<p>那么客户端 1 最会获取到元素，因为客户端 1 最先执行 brpop，而客户端2 和 3 继续阻塞</p>

<pre><code class="powershell">client&gt; bprop list:test 0
1) &quot;list:test&quot;
2) &quot;elememt&quot;  
</code></pre>

<h4 id="toc_6">时间复杂度</h4>

<table>
<thead>
<tr>
<td>操作类型</td>
<td>命令</td>
<td>时间复杂度</td>
</tr>
</thead>

<tbody>
<tr>
<td>添加</td>
<td>rpush key value [value &hellip;]</td>
<td>O(k)，k是元素个数</td>
</tr>

<tr>
<td></td>
<td>lpush key value [value &hellip;]</td>
<td>O(k)，k是元素个数</td>
</tr>

<tr>
<td></td>
<td>linsert key before|after privot value</td>
<td>O(n)，n是pivot距离列表头或尾的距离</td>
</tr>

<tr>
<td>查找</td>
<td>lrange key start end</td>
<td>O(s+n)，s是start偏移量，n是start到end的范围</td>
</tr>

<tr>
<td></td>
<td>lindex key index</td>
<td>O(n)，n是索引的偏移量</td>
</tr>

<tr>
<td></td>
<td>llen key</td>
<td>O(1)</td>
</tr>

<tr>
<td>删除</td>
<td>lpop key</td>
<td>O(1)</td>
</tr>

<tr>
<td></td>
<td>rpop key</td>
<td>O(1)</td>
</tr>

<tr>
<td></td>
<td>lrem count value</td>
<td>O(n)，n是列表长度</td>
</tr>

<tr>
<td></td>
<td>ltrim key start end</td>
<td>O(n)，n是要裁剪的元素总数</td>
</tr>

<tr>
<td>修改</td>
<td>lset key index value</td>
<td>O(n)，n是索引的偏移量</td>
</tr>

<tr>
<td>阻塞操作</td>
<td>blpop brpop</td>
<td>O(1)</td>
</tr>
</tbody>
</table>

<h4 id="toc_7">内部编码</h4>

<p>列表类型的内部编码有两种。</p>

<ul>
<li>ziplist（压缩列表）：当列表的元素个数小于 list-max-ziplist-entries 配置（默认512个），同时列表中每个元素的值都小于 list-max-ziplist-value 配置时（默认64字节）。Redis 会选用 ziplist 来作为列表的内部实现来减少内存的使用。</li>
<li>linkedlist（链表）：当列表类型无法满足 ziplist 的条件时，Redis 会使用 linkedlist 作为列表的内部实现。</li>
</ul>

<p>下面演示列表类型的颞部编码，以及相应的变化。</p>

<p>1）当元素个数较少且没有大元素时，内部编码为 ziplist</p>

<pre><code class="shell">127.0.0.1:6379&gt; rpush listkey e1 e2 e3
(integer) 3
127.0.0.1:6379&gt; object encoding listkey
&quot;ziplist&quot;
</code></pre>

<p>2.1）当元素个数超过 512 个，内部编码变为 linkedlist：</p>

<pre><code class="shell">127.0.0.1:6379&gt; rpush listkey e4 e5 e6 ... 忽略 ... e512 e513
(integer) 513
127.0.0.1:6379&gt; object encoding listkey
&quot;linkedlist&quot;
</code></pre>

<p>2.2）或者当某个元素超过 64 字节，内部编码也会变为 linkedlist：</p>

<pre><code class="shell">127.0.0.1:6379&gt; rpush listkey &quot;one string is bigger than 64 byts ...&quot;
(integer) 4
127.0.0.1:6379&gt; object encoding listkey
&quot;linkedlist&quot;
</code></pre>

<p>tip：Redis 3.2版本提供了 quicklist 内部编码，简单地说他是一个以 ziplist 为节点的 linkedlist，它结合了 ziplist 和 linkedlist 的优势，为列表类型提供了一种更为优秀的内部编码实现，它的设计原理可以参考Redis 的另一个作者 Matt Stancliff 的博客：<a href="https://matt.sh/redis-quicklist。">https://matt.sh/redis-quicklist。</a></p>

<h4 id="toc_8">使用场景</h4>

<p><strong>消息队列</strong></p>

<p>Redis 的 lpush + brpop 命令组合即可实现阻塞队列，生产者客户端使用 lrpush 从列表左侧插入元素，多个消费者客户端使用 brpop 命令阻塞式的“抢”列表尾部的元素，多个客户端保证了消费的负载均衡和高可用性。</p>

<p><strong>文章列表</strong></p>

<p>每个用户有属于自己的文章列表，现需要分页展示文章列表，此时可以考虑使用列表，因为列表不但是有序的，同时支持按照索引范围获取元素。</p>

<p>1）每篇文章使用哈希结构存储，例如每篇文章有 3 个属性 title、timestamp、content：</p>

<pre><code class="shelll">hmset article:1 title xx timestamp 1476536196 content xxx
...
hmset article:k title yy timestamp 1476512536 content yyy
...
</code></pre>

<p>2）向用户文章列表添加文章，user:{id}:articles 作为用户文章列表的键：</p>

<pre><code class="shell">lpush user:1:articles articles:1 acticle3
...
lpush user:k:articles article:5
...
</code></pre>

<p>3）分页获取用户文章列表，例如下面伪代码获取用户 id=1 的前10篇文章：</p>

<pre><code>articles = lrange user:1:articles 0 9
for article in {articles}
    hgetall {article}
</code></pre>

<p>使用列表类型保存和获取文章列表会存在两个问题。第一，如果每次分页获取的文章较多，需执行多次 hgetall 操作，此时可以考虑使用 Pipline 批量获取。或者考虑将文章数据序列化为字符串类型，使用 mget 批量获取。第二，分页获取文章列表是，lrange 命令在列表两端性能较好，但如果列表较大，获取列表中间范围的元素性能会变差，此时可考虑将列表做二级拆分，或者使用 Redis 3.2 的 quicklist 内部编码实现，它结合 ziplist 和 linkedlist 的特点，获取列表中间范围的元素时也可以高效的完成。</p>

<p>tip：实际上列表的使用场景很多，在选择时可以参考一下口诀：</p>

<ul>
<li>lpush + lpop = Stack（栈）</li>
<li>lpush + rpop = Queue（队列）</li>
<li>lpush + ltrim = Capped Collection（有限集合）</li>
<li>lpush + brpop = Message Queue（消息队列）</li>
</ul>
