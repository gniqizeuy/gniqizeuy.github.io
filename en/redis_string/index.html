redis_string
Redis String
redis 


<h3 id="toc_0">字符串</h3>

<p>字符串类型是 Redis 最基础的数据结构。首先键都是字符串类型，而且其他几种数据结构都是在字符串类型基础上构建的。字符串类型的值实际可以是字符串（简单的字符串、复杂的字符串（例如 JSON、XML）、数字（整数、浮点数），甚至是二进制（图片、音频、视频），但是值最大不能超过 512 MB</p>

<h4 id="toc_1">1 常用命令</h4>

<h5 id="toc_2">设置值</h5>

<pre><code class="shell">set key value [ex seconds] [px milliseconds] [nx|xx]
</code></pre>

<p>set 命令有几个选项</p>

<ul>
<li>ex seconds：为键设置秒级过期时间。</li>
<li>px milliseconds：为键设置毫秒级过期时间</li>
<li>nx： 键必须不存在，才可以设置成功，用于添加</li>
<li>xx：与nx相反，键必须存在，才可以设置成功，用于更新</li>
</ul>

<p>除了 set 选项，Redis 还提供了 setex 和 setnx 两个命令</p>

<pre><code class="shell">setnx key seconds value
setnx key value
</code></pre>

<p>作用与 ex 和 nx 选项一样</p>

<p>setnx 可以作为分布式锁的一种实现方案，以 setnx 命令为例，由于 Redis 的单线程命令处理机制，如果有多个客户端同时执行 setnx key value ，根据 setnx 的特性只有一个客户端能设置成功。Redis 官方给出了使用 setnx 实现分布式锁的方法：<a href="http://redis.io/topics/distlock">http://redis.io/topics/distlock</a></p>

<h5 id="toc_3">获取值</h5>

<pre><code class="shell">get key # 获取的键不存在则返回 nill（空）
</code></pre>

<h5 id="toc_4">批量设置值</h5>

<pre><code class="shell">mset key value [key value ...]
</code></pre>

<h5 id="toc_5">批量获取值</h5>

<pre><code class="shell">mget key [key ...]
</code></pre>

<p>批量操作命令可以有效提高开发效率，不适应 mget 命令，执行 n 次 get 命令的话，具体耗时如下：</p>

<p>n 次 get 时间 = n 次网络时间 + n 次命令时间</p>

<p>使用 mget 命令耗时如下：</p>

<p>n 次 get 时间 = 1 次网络时间 + n 次命令时间</p>

<blockquote>
<p>Redis 可以支撑每秒数万的读写操作，但这指的是 Redis 服务端的处理能力，对于客户端来说，一次命令除了命令时间还有网络时间，假设网络事件为 1 毫秒，命令时间为 0.1 毫秒（按照没秒处理 1 万条命令算），那么执行 1000 次 get 命令和 1 次 mget 命令的区别如下表，因为 Redis 的处理能力以及足够高，对于开发人员来说，网络可能成为性能的瓶颈</p>
</blockquote>

<table>
<thead>
<tr>
<td align="center">操作</td>
<td align="center">时间</td>
</tr>
</thead>

<tbody>
<tr>
<td align="center">1000 次 get</td>
<td align="center">1000 * 1 + 1000 * 0.1 = 1100 毫秒 = 1.1 秒</td>
</tr>

<tr>
<td align="center">1 次 mget （组装了 1000 个键值对）</td>
<td align="center">1 * 1 + 1000 * 0.1 = 101 毫秒 = 0.101 秒</td>
</tr>
</tbody>
</table>

<p>批量操作有助于提高业务处理能力，但是要注意每次批量操作所发送的命令数不是无节制的，如果数量过多可能造成 Redis 阻塞或者网络拥塞</p>

<h5 id="toc_6">计数</h5>

<pre><code class="shell">incr key
</code></pre>

<p>incr 命令用于对值做自增操作，返回结果分 3 种</p>

<ul>
<li>值不是整数，返回错误</li>
<li>值是整数，返回自增后的结果</li>
<li>键不存在，按照值为 0 自增，返回结果为 1</li>
</ul>

<p>除了 incr 命令，Redis 提供了 <code>decr</code>（自减）、<code>incrby</code>（自增指定数字）、<code>decrby</code>（自减指定数字）、<code>incrbyfloat</code>（自增浮点数）</p>

<p>很多存储系统和编程语言内部使用 CAS 机制实现基数功能，会有一定的 CPU 开销，但在 Redis 中完全不存在这个问题，因为 Redis 是单线程架构，任何命令到了 Redis 服务端都要顺序执行。</p>

<h4 id="toc_7">不常用命令</h4>

<h5 id="toc_8">追加值</h5>

<pre><code class="shell">append key value    # 返回追加值后的长度
</code></pre>

<h5 id="toc_9">字符串长度</h5>

<pre><code class="shell">strlen key  # 返回字符串长度，中文占 3 个字节
</code></pre>

<h5 id="toc_10">设置并返回原值</h5>

<pre><code class="shell">getset key value    # getset 和 set 一样会设置值，但是不同的是，它同时会返回键原来的值
</code></pre>

<h5 id="toc_11">设置指定位置的字符</h5>

<pre><code class="shell">setrange key offeset value
</code></pre>

<h5 id="toc_12">获取部分字符串</h5>

<pre><code class="shell">getrange key start end  # start 和 end 分别是开始和结束的偏移量，偏移量从 0 开始计算
</code></pre>

<p>下表为字符串类型命令的时间复杂度</p>

<table>
<thead>
<tr>
<td align="left">命令</td>
<td>时间复杂度</td>
</tr>
</thead>

<tbody>
<tr>
<td align="left">set key value</td>
<td><i>0(1)</i></td>
</tr>

<tr>
<td align="left">get key</td>
<td><i>0(1)</i></td>
</tr>

<tr>
<td align="left">del key [key &hellip;]</td>
<td><i>0(K)</i>，k 是键的个数</td>
</tr>

<tr>
<td align="left">mset key value [key value &hellip;]</td>
<td><i>0(K)</i>，k 是键的个数</td>
</tr>

<tr>
<td align="left">mget key [key &hellip;]</td>
<td><i>0(K)</i>，k 是键的个数</td>
</tr>

<tr>
<td align="left">incr key</td>
<td><i>0(1)</i></td>
</tr>

<tr>
<td align="left">decr key</td>
<td><i>0(1)</i></td>
</tr>

<tr>
<td align="left">incrby key increment</td>
<td><i>0(1)</i></td>
</tr>

<tr>
<td align="left">decrby key decrement</td>
<td><i>0(1)</i></td>
</tr>

<tr>
<td align="left">incrbyfloat key increment</td>
<td><i>0(1)</i></td>
</tr>

<tr>
<td align="left">append key value</td>
<td><i>0(1)</i></td>
</tr>

<tr>
<td align="left">strlen key</td>
<td><i>0(1)</i></td>
</tr>

<tr>
<td align="left">setrange key offset value</td>
<td><i>0(1)</i></td>
</tr>

<tr>
<td align="left">getrange key start end</td>
<td><i>0(n)</i>，n 是字符串长度，由于获取字符串非常快，所以如果字符串不是很长，可以视同为 <i>O(1)</i></td>
</tr>
</tbody>
</table>

<h4 id="toc_13">内部编码</h4>

<p>字符串类型的内部编码有 3 种</p>

<ul>
<li>int：8 个字节的长整型</li>
<li>embstr：小于等于 39 个字节的字符串</li>
<li>raw：大于 39 个字节的字符串</li>
</ul>

<p>Redis 会根据当前值的类型和长度决定使用哪种内部编码实现</p>

<p>整数类型示例如下：</p>

<pre><code class="shell">127.0.0.1:6379&gt; set key 8653
OK
127.0.0.1:6379&gt; object encoding key
&quot;int&quot;
</code></pre>

<h4 id="toc_14">典型使用场景</h4>

<h5 id="toc_15">缓存功能</h5>
