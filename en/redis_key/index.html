redis_key
Redis key
redis 


<h3 id="toc_0">Redis 键管理</h3>

<p>单个键、遍历键、数据库管理</p>

<h4 id="toc_1">单个键管理</h4>

<h5 id="toc_2">1.  键重命名</h5>

<pre><code class="shell">rename key newkey
</code></pre>

<p>如果在 rename 之前，键已存在，那么它的值也将被覆盖</p>

<p>防止强行 rename key，Redis 提供了 renamex 命令，确保只有 newkey 不存在时才被覆盖，newkey 存在时返回 0 代表未完成重命名。</p>

<p>在使用重命名命令时，有两点需要注意</p>

<ul>
<li>由于重命名键期间会执行 del 命令删除旧的键，如果键对应的值比较大，会存在阻塞 Redis 的可能性，这点不要忽略</li>
<li>如果 rename 和 renamex 中的 key 和 newkey 如果是相同的，在 Redis 3.2 和之前版本返回结果略有不同。</li>
</ul>

<p>Redis 3.2 中会返回 OK</p>

<p>Redis 3.2 之前版本会提示错误</p>

<pre><code class="shell">127.0.0.1&gt; rename key key
(error) ERR source and destination objects are the same
</code></pre>

<h5 id="toc_3">2.  随机返回一个键</h5>

<pre><code class="shell">randomkey
</code></pre>

<h5 id="toc_4">3. 键过期</h5>

<p>除了 expire、ttl 命令以外，Redis 还提供了 expireat、pexpire、pexpireat、pttl、persist 等一系列命令</p>

<ul>
<li><code>expire key seconds</code>：键在 seconds 秒后过期</li>
<li><code>expireat key timestamp</code>：键在秒级时间戳 timestamp 后过期</li>
</ul>

<p>ttl 命令和 pttl 都可以查询键的剩余过期时间，但是 pttl 精度更高可以达到毫秒级别，有 3 种返回值：</p>

<ul>
<li>大于等于 0 的整数：键剩余的过期时间（ttl 是秒，pttl 是毫秒）</li>
<li>-1：键没有设置过期时间</li>
<li>-2：键不存在</li>
</ul>

<p>expireat 命令可以设置键的秒级过期时间戳</p>

<pre><code class="shell">expireat hello 1469980800
</code></pre>

<p>Redis 2.6 版本后提供了毫秒级的过期方案</p>

<pre><code class="shell">pexpire key milliseconds    # 键在 milliseconds 毫秒后过期
</code></pre>

<pre><code class="shell">pexpire key milliseconds-timestamp  # 键在 毫秒级时间戳 timestamp 后过期
</code></pre>

<p>但无论是使用过期时间还是时间戳，秒级还是毫秒级，在 Redis 内部最终使用的都是 <code>pexpireat</code></p>

<p>使用 Redis 相关过期命令时，需要注意以下几点</p>

<p>1）如果 expire key 的键不存在，返回结果为 0</p>

<pre><code class="shell">127.0.0.1:6379&gt; expire not_exist_key 30
(integer) 0
</code></pre>

<p>2）如果过期时间为负值，键会立即被删除，犹如 del 命令一样</p>

<pre><code class="shell">127.0.0.1:6379&gt; set hello world
OK
127.0.0.1:6379&gt; expire hello -2
(integer) 1
127.0.0.1:6379&gt; get hello
(nil)
</code></pre>

<p>3）persist 命令可以将键的过期时间清除</p>

<pre><code class="shell">127.0.0.1:6379&gt; hset key f1 v1
(integer) 1
127.0.0.1:6379&gt; expire key 50
(integer) 1
127.0.0.1:6379&gt; ttl key
(integer) 46
127.0.0.1:6379&gt; persist key
(integer) 1
127.0.0.1:6379&gt; ttl key
(integer) -1
</code></pre>

<p>4）对于字符串类型键，执行 set 命令去掉过期时间，这个问题很容易在开发中被忽略</p>

<p>如下是 Redis 源码中，set 命令的函数 setKey，可以看到最后执行了 removeExpire(db, key) 函数去掉了过期时间</p>

<pre><code class="c">void setKey(redisDb *db, robj *key, robj *val) {
    if (lookupKeyWrite(db,key) == NULL) {
        dbAdd(db,key,val);
    } else {
        dbOverwrite(db,key,val);
    }
    incrRefCount(val);
    // 去掉过期时间
    removeExpire(db,key);
    signalModifiedKey(db,key);
}
</code></pre>

<p>下面例子证实了 set 会导致过期时间失效，因此 ttl 变为 -1</p>

<pre><code class="shell">127.0.0.1:6379&gt; expire hello 50
(integer) 1
127.0.0.1:6379&gt; ttl hello
(integer) 46
127.0.0.1:6379&gt; set hello world
OK
127.0.0.1:6379&gt; ttl hello
(integer) -1
</code></pre>

<p>5）Redis 不支持二级数据结构（例如哈希、列表）内部元素的过期功能，例如不能对列表类型的一个元素做过期时间设置</p>

<p>6）setex 命令作为 set + expire 的组合，不但是原子执行，同时减少了一次网络通讯的时间</p>

<h4 id="toc_5">迁徙键</h4>

<p>Redis 发展历程中提供了 move、dump + restore、migrate 三组迁移键的方法，他们的实现方式以及使用的场景不太相同</p>

<h5 id="toc_6">move</h5>

<pre><code class="shell">move key db
</code></pre>

<p>move 命令用于在 Redis 内部进行数据迁徙，Redis 内部可以多个数据库，彼此在数据上是相互隔离的，move key db 就是把指定的键从源数据库移动到目标数据库，不建议在生产环境使用</p>

<h5 id="toc_7">dump + restore</h5>

<pre><code class="shell">dump key
restore key ttl value
</code></pre>

<p>dump + restore 可以实现在不同的 Redis 实例之间进行数据迁移的功能，整个迁移的过程分成两步：</p>

<p>1  在源 Redis 上，dump 命令会将键值序列化，格式采用的是 RDB 格式</p>

<p>2 在目标 Redis 上，restore 命令将上面序列化的值进行复原，其中 ttl 参数代表过期时间，如果 ttl=0 代表没有过期时间</p>

<p>dump + restore 有两点需要注意，第一，真个迁徙过程并非原子性的，而是通过客户端分步完成的。第二，迁徙过程是开启了两个客户端连接，所以 dump 的结果不是在源 Redis 和目标 Redis 之间进行传输</p>

<p>1）在源 Redis 上执行 dump</p>

<pre><code class="shell">redis-source&gt; set hello world
OK
redis-source&gt; dump hello
&quot;\x00\x05world\t\x00\xc9#mH\x84/\x11s&quot;
</code></pre>

<p>2）在目标 Redis 上执行 restore</p>

<pre><code class="shell">redis-target&gt; get hello
(nil)
redis-target&gt; restore hello 0 &quot;\x00\x05world\t\x00\xc9#mH\x84/\x11s&quot;
OK
redis-target&gt; get hello
&quot;world&quot;
</code></pre>

<p>上面 2 步对应的伪代码如下：</p>

<pre><code class="java">Redis sourceRedis = new Redis(&quot;sourceMachine&quot;, 6379);
Redis targetRedis = new Redis(&quot;targetMachine&quot;, 6379);
targetRedis.restore(&quot;hello&quot;, 0, sourceRedis.dump(key));
</code></pre>

<h5 id="toc_8">migrate</h5>

<pre><code class="shell">migrate host port key|&quot;&quot; destination-db timeout [copy] [replace] [keys key [key ...]]
</code></pre>

<p>migrate 命令实际是将 dump、restore、del 三个命令进行组合，从而简化了操作流程。migrate 命令具有原子性，而且从 Redis 3.0.6版本以后已经支持迁移多个键的功能，有效地提高了迁徙效率，migrate 在水平扩容中起到了重要作用</p>

<p>实现过程与 dump + restore 基本类似，但有 3 点不太相同：第一，整个过程是原子执行的，不需要在多个 Redis 实例上开启客户端，只需在源 Redis 上执行 migrate 命令即可。第二，migrate 命令的数据传输直接在源 Redis 和目标 Redis 上完成的，第三，目标 Redis 完成 restore 后会发送 OK 给源 Redis ，源 Redis 接收后会根据 migrate 对应的选项来决定是否在源 Redis 上删除对应的键</p>

<p>migrate 的参数：</p>

<ul>
<li>host：目标 Redis 的 IP 地址</li>
<li>port：目标 Redis 的端口</li>
<li>key|&ldquo;&ldquo;：在 Redis 3.0.6 版本前 migrate 只支持迁移一个键，3.0.6 版本之后支持迁移多个键，如果当前需要迁移多个键，此处为空字符串 &ldquo;&rdquo;</li>
<li>destination-db：目标 destination-db 的数据库索引</li>
<li>timeout：迁移的超时时间（单位为毫秒）</li>
<li>[copy]：添加此选项，迁移后并不删除源键</li>
<li>[replace]：添加此选项，migrate 不管目标 Redis 是否存在该键都会正常迁移进行数据覆盖</li>
<li>[keys key [key &hellip;]]：迁移多个键</li>
</ul>

<p>使用如下，源 Redis 使用 6379 端口，目标 Redis 使用 6380 端口。现将源 Redis 的键 hello 迁移到目标 Redis 中，会分为如下几种情况</p>

<h5 id="toc_9">源 Redis 有键 hello ，目标 Redis 没有：</h5>

<pre><code class="shell">127.0.0.1:6379&gt; migrate 127.0.0.1 6380 hello 0 1000
OK
</code></pre>

<h5 id="toc_10">源 Redis 和目标 Redis 都有键 hello</h5>

<p>如果 migrate 没有加 replace 选项会收到错误提示，加了则会返回 OK 表示迁移成功</p>

<pre><code class="shell">127.0.0.1:6379&gt; migrate 127.0.0.1 6380 hello 0 1000

</code></pre>
