spring_exception
Spring Exception
spring 


<h4 id="toc_0">异常处理的必要性</h4>

<p>异常处理的方式通常有以下几种</p>

<ul>
<li>将异常通知给开发人员，运维人员或者用户</li>
<li>使因为异常中断的程序以适当的方式继续运行，或者退出</li>
<li>保存用户的当前操作，或者进行数据回滚</li>
<li>释放资源</li>
</ul>

<h4 id="toc_1">异常的分类</h4>

<ul>
<li><code>ERROR</code>：代表编译和系统的错误，不允许捕获</li>
<li><code>Exception</code>：标准 Java 库的方法所激发的异常，包含运行异常 <code>Runtime Exception</code> 和非运行异常 <code>Non Runtime Exception</code> 的子类</li>
<li><code>Runtime Exception</code>：运行时异常</li>
<li><code>Non Runtime Exception</code>：非运行时可检测的异常，Java 编译器利用分析方法或者构造方法中可能产生的结果来检测程序中是否包含有检测异常的处理程序，每个可能的可检测异常、方法或构造方法的 throw 子句必须列出该异常对应的类。</li>
<li><code>Throw</code>：用户自定义异常。</li>
</ul>

<h4 id="toc_2">如何处理异常</h4>

<h5 id="toc_3">捕获异常</h5>

<p>捕获异常的格式，见以下代码：</p>

<pre><code class="java">try {
    // ...
} catch {
    // ...
} finally {
    // ...
}
</code></pre>

<p><code>try</code>：在 try 语句中编写可能发生异常的代码，即正常的业务功能代码。如果执行完 try 语句不发生异常，则执行 finally 语句（如果有的话）和 finally 后面的代码；如果发生异常，则尝试去匹配 catch 语句。</p>

<p><code>catch</code>：捕获错误并处理</p>

<p><code>finally</code>：finally 语句是可选的，无论异常是否发生、是否匹配、是否被处理，finally 语句都会被执行。</p>

<p>一个 try 至少有一个 catch 语句，或至少有 1 个 finally 语句。finally 语句不是用来处理异常的，也不会捕获异常，是为了做一些清理工作，如流的关闭、数据库连接的关闭等。</p>

<h5 id="toc_4">抛出异常</h5>

<p>除用 try 语句处理异常外，还可以用 throw、throws 抛出异常。</p>

<p>执行 throw 语句的地方是一个异常抛出点，后面必须是一个异常对象，且必写在函数中。</p>

<p>throw 语法：</p>

<pre><code class="text">throw(异常对象);
</code></pre>

<p>throws 语法：</p>

<pre><code class="text">语法：[(修饰符)] (返回值类型) (方法名) ([参数列表]) [throws(异常类)] {...}
</code></pre>

<h5 id="toc_5">自定义异常</h5>

<p>在应用程序开发过程中，经常会自定义异常类，以避免使用 try 产生重复代码。自定义异常类一般通过扩展 Exception 类来实现的。这样的自定义异常类属于检查异常（checked exception）。如果要定义非检查异常，则需要继承 RuntimeException。</p>

<h4 id="toc_6">Spring Boot 默认的异常处理</h4>

<p>Spring Boot 提供了一个默认处理异常的映射。在 Spring Boot 的 Web 项目中，尝试访问一个不存在的 URL（<a href="http://localhost:8080/loginZhiran），会得到">http://localhost:8080/loginZhiran），会得到</a> Spring Boot 中内置的异常处理，如下所示：</p>

<pre><code class="text">This application has no explict mapping for /error, so you are seeing this as a fallback
Sat May 18 22:49:20 CST 2019
There was an unexpected error(type=Not Found, status=404)
No message available
</code></pre>

<p>同样的地址，如果发送的请求带有 ”Content-type —&gt; application/json;charset=UTF-8“，则返回的是 JSON 格式的错误结果，见以下输出结果：</p>

<pre><code class="json">{
    &quot;time&quot;:&quot;2019-05-18T14:47:46.722+0000&quot;,
    &quot;status&quot;:404,
    &quot;error&quot;:&quot;Not Found&quot;,
    &quot;message&quot;:&quot;No message available&quot;,
    &quot;path&quot;:&quot;/loginZhiran&quot;
}
</code></pre>

<p>Spring Boot 会消费者发送的 ”Content-type“ 来返回相应的异常内容，“application/json” 返回 JSON 文件； “text/html&rdquo; 返回 HTML 文件。</p>

<h4 id="toc_7">使用控制器通知</h4>

<p>在编写业务代码时，需要对异常进行处理。进行异常处理的普通的代码是 try···catch 结构。但在开发业务时，只想关注业务正常的代码，对于 catch 语句中的捕获异常，希望交给异常捕获来处理，不单独在每个方法中编写，这样不仅可以减少冗余代码，还可以减少因忘记写 catch 而出现错误的概率。</p>

<p>Spring 提供了一个非常方便的异常处理方案——<strong>控制器通知</strong>（<code>@ControllerAdvice</code> 或 <code>@RestControllerAdvice</code>），它将所有控制器作为一个切面，利用切面技术来实现。</p>

<p>通过基于 <code>@ControllerAdvice</code> 或 <code>@RestControllerAdvice</code> 的注解可以对异常进行全局统一处理，默认对所有的 Controller 有效。如果要限定生效范围，则可以使用 ControllerAdvice 支持的限定范围方式：</p>

<ul>
<li>按注解：<code>@ControllerAdvice(annotaions=RestController.class)</code></li>
<li>按包名：<code>@ControllerAdvice(&quot;org.example.controller&quot;)</code></li>
<li>按类型：<code>@ControllerAdvice(assignableTypes={ControllerInterface.class, AbstractController.class})</code></li>
</ul>

<p>这是 ControllerAdvice 进行统一异常处理的优点，它能够细粒度地控制该异常处理器针对哪些 Controller 、包或类型有效。</p>

<p>可以利用这一特性在一个系统实现多个异常处理器，然后 Controller 可以有选择地决定使用哪个，使得异常处理更加灵活、降低侵入性。</p>

<p>异常处理类会包含以下一个或多个方法：</p>

<ul>
<li><code>InitBinder</code>：对表单数据进行绑定，用于定义控制器参数绑定规则。如转换规则、格式化等。可以通过这个注解地方式得到 WebDataBinder 对象，它在参数转换之前被执行。</li>
<li><code>ModelAttribute</code>：在控制器方法被执行前，对所有 Controller 的 Model 添加属性进行操作。</li>
<li><code>@ExceptionHandler</code>：定义控制器发生异常后的操作，可以拦截所有控制器发生的异常。</li>
<li><code>ControllerAdice</code>：统一异常处理，通过 <code>@ExceptionHandler(value=Exception.class)</code> 来指定捕获的异常。“@ControllerAdvice + @ExceptionHandle&rdquo; 可以处理 除 ”404“ 以外的运行异常</li>
</ul>

<h4 id="toc_8">自定义错误处理控制器</h4>

<h5 id="toc_9">自定义一个错误的处理控制器</h5>

<pre><code class="java">import org.springframework.boot.web.servlet.error.ErrorController;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

@RestController
/*springboot提供了默认的错误映射地址error
@RequestMapping(&quot;${server.error.path:${error.path:/error}}&quot;)
@RequestMapping(&quot;/error&quot;)
上面2种写法都可以
*/
@RequestMapping(&quot;/error&quot;)
//继承springboot提供的ErrorController
public class TestErrorController implements ErrorController {
    //一定要重写方法,默认返回null就可以,不然报错,因为getErrorPath为空.
    @Override
    public String getErrorPath() {
        return null;
    }

    //一定要添加url映射,指向error
    @RequestMapping
    public Map&lt;String, Object&gt; handleError() {
        //用Map容器返回信息
        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
        map.put(&quot;code&quot;, 404);
        map.put(&quot;msg&quot;, &quot;不存在&quot;);
        return map;
    }
    /*这里加一个能正常访问的页面,作为比较
    因为写在一个控制器所以它的访问路径是
    http://localhost:8080/error/ok*/
    @RequestMapping(&quot;/ok&quot;)
    @ResponseBody
    public Map&lt;String, Object&gt; noError() {
        //用Map容器返回信息
        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
        map.put(&quot;code &quot;, 200);
        map.put(&quot;msg&quot;, &quot;正常，这是测试页面&quot;);

        return map;
    }


}

</code></pre>

<p>启动项目，访问一个不存在的网址，则返回以下信息：</p>

<pre><code class="json">{&quot;msg&quot;:&quot;不存在&quot;,&quot;code&quot;:404}
</code></pre>

<p>返回正确定义的映射，则返回以下信息：</p>

<pre><code class="json">{&quot;msg&quot;:&quot;正常，这是测试页面&quot;,&quot;code&quot;:200}
</code></pre>

<h5 id="toc_10">根据请求返回相应的数据格式</h5>

<pre><code class="java">// 这里不加 consume=&quot;text/html;charset=UTF-8&quot;, 否则不会成功，，有部分浏览器提交的是空值
@RequestMapping(value=&quot;&quot;,produces=&quot;text/html;charset=UTF-8&quot;)
@ResponseBody
public String errorHtml404(HttpServletRequest request, HttpServletResponse response) {
    // 跳转到 error 目录下的 404 模板
    return &quot;404错误 不存在&quot;;
}

@RequestMapping(value=&quot;&quot;, consume=&quot;application/json;charset=UTF-8&quot;, produces=&quot;application/json;charset=UTF-8&quot;)
@ResponseBody
public Map&lt;String Object&gt; errorJson() {
    // 用 Map 容器返回信息
    Map&lt;String Object&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;code&quot;,404);
    map.put(&quot;msg&quot;:&quot;不存在&quot;);
    return map;
}
</code></pre>

<h4 id="toc_11">自定义业务异常类</h4>

<h5 id="toc_12">自定义异常类</h5>

<p>自定义异常类需要继承 Exception 类。这里继承 RuntimeException，代码如下：</p>

<pre><code class="java">//@ResponseStatus(code= HttpStatus.INTERNAL_SERVER_ERROR,reason=&quot;600&quot;)
public class BusinessException extends RuntimeException{
    //自定义错误码
    private Integer code;
    //自定义构造器，必须输入错误码及内容
    public BusinessException(int code,String msg) {
        super(msg);
        this.code = code;
    }

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }
}
</code></pre>

<p>RuntimeException 和 Error 是非检查异常，其他的都是检查异常。所有方法都可以在不声明 &ldquo;throw&rdquo; 方法的情况下抛出 RuntimeException 和及子类，不可以在不声明的情况下抛出 RuntimeException，即非 RuntimeException 要自己写 catch 语句处理，如果 RuntimeException 不使用 &ldquo;try···catch&rdquo; 进行捕获，则会导致程序运行中断。</p>

<h5 id="toc_13">自定义全局捕获异常</h5>

<pre><code class="java">import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import java.util.HashMap;
import java.util.Map;
/**
 * 自定义业务处理业务异常类
 */
@ControllerAdvice
public class CustomerBusinessExceptionHandler {
    @ResponseBody
    @ExceptionHandler(BusinessException.class)
    public Map&lt;String, Object&gt; businessExceptionHandler(BusinessException e) {
        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
        map.put(&quot;code&quot;, e.getCode());
        map.put(&quot;message&quot;, e.getMessage());
        //发生异常进行日志记录，此处省略
        return map;
    }
}
</code></pre>

<h5 id="toc_14">测试自定义异常</h5>

<p>创建控制器，以抛出 BusinessException 的自定义异常</p>

<pre><code class="java">import com.example.demo.exception.BusinessException;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TestController {
    @RequestMapping(&quot;/BusinessException&quot;)
    public String testResponseStatusExceptionResolver(@RequestParam(&quot;i&quot;) int i){
        if (i==0) 
            throw new BusinessException(600,&quot;自定义业务错误&quot;);
        return &quot;success&quot;;
    }

}

</code></pre>

<p>启动项目，测试异常处理情况，则抛出以下错误信息</p>

<pre><code class="json">{&quot;code&quot;:600,&quot;message&quot;:&quot;自定义业务异常&quot;}
</code></pre>
