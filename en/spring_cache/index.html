spring_cache
Spring Cache
spring 


<p>Spring Cache 是 Spring 提供的一整套缓存解决方案。它本身并不提供缓存实现，而是根据统一的接口和代码规范、配置、注解等，以便整合各种 Cache 方案，使用户不用关心 Cache 的细节</p>

<p>Spring 支持透明地向应用程序添加缓存，将缓存应用于方法，在方法执行前检查缓存中是否有可用的数据。这样可以减少方法执行的次数，同时提高响应的速度。缓存的应用方式透明不会对调用者造成任何干扰。只要通过注解 <code>@EnableCaching</code> 启用了缓存支持，Spring Boot 就会自动处理好缓存的基础配置</p>

<p>Spring Cache 作用在方法上。当调用一个缓存方法时，会把方法参数和返回结果作为一个<strong>键值对</strong>存放在缓存中，下次用同样的参数来调用该方法时将不再执行该方法，而是直接从缓存中获取结果进行返回，所以在使用 Spring Cache 时，要保证在缓存的方法和方法参数相同时返回相同的结果。</p>

<h4 id="toc_0">声明式缓存注解</h4>

<table>
<thead>
<tr>
<td>注解</td>
<td>说明</td>
</tr>
</thead>

<tbody>
<tr>
<td>@EnableCaching</td>
<td>开启缓存</td>
</tr>

<tr>
<td>@Cacheable</td>
<td>作用于方法和类上，以键值对方式缓存类或方法的返回值</td>
</tr>

<tr>
<td>@CachePut</td>
<td>方法被调用，然后结果被缓存</td>
</tr>

<tr>
<td>@CacheEvict</td>
<td>清空缓存</td>
</tr>

<tr>
<td>@Caching</td>
<td>用来组合多个注解标签</td>
</tr>
</tbody>
</table>

<h5 id="toc_1">@EnableCaching</h5>

<p>标注在入口类上，用于开启缓存</p>

<h5 id="toc_2">@Cacheable</h5>

<p>键可以有默认策略和自定义策略</p>

<p>@Cacheable 注解会先查询是否已经有缓存，如果已有则会使用缓存，如果没有则会执行方法并进行缓存</p>

<p>@Cacheable 可以指定 3 个属性——value、key、和 condition</p>

<ul>
<li>value：缓存的名称，在 Spring 配置文件中定义，必须指定至少一个。如 <code>@Cacheable(value=&quot;cache1&quot;)</code> 、<code>@Cacheable(value={&quot;cache1&quot;, &quot;cache2&quot;})</code></li>
<li>key：缓存的 key 可以为空，如果自定义 key ，则需要按照 SpEL 表达式编写。可以自定按照方法的参数组合。如，<code>@Cacheable(value=&quot;cache1&quot;, key=&quot;#id&quot;)</code></li>
<li>condition：缓存的条件可以为空，如果自定义 condition，则使用 SpEL 表达式编写，以返回 true 或 false 值，只有返回 true 才进行缓存。如，<code>@Cacheable(value=&quot;cache1&quot;, condition=&quot;#id.length()&gt;2&quot;)</code></li>
</ul>

<p>使用方式如下</p>

<pre><code class="java">@Cacheable(value=&quot;emp&quot;, key=&quot;targetClass + methodName + #p0&quot;)
public User findUserById(long id) {
    return userRepository.findById(id);
}
</code></pre>

<p>代码解释如下：</p>

<ol>
<li>value 是必需的，它指定了缓存存放的位置</li>
<li>key 使用的是 SpEL 表达式</li>
<li>User 实体类一定要实现<strong>序列化</strong>，否则会报 <i>java.io.NotSerializableException</i> 异常。序列化可以继承 <code>Serializable</code></li>
</ol>

<h5 id="toc_3">@CachePut</h5>

<p>@CachePut 标注的方法在执行前不检查缓存是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。和 @Cacheable 不同的是，@CachePut 每次都会触发真实方法的调用，比如用户更新缓存数据</p>

<p>注意该注解的 value 和 key 必须与要更新的缓存相同，即与 @Cacheable 相同</p>

<pre><code class="java">@CachePut(value=&quot;usr&quot;, key=&quot;targetClass + #p0&quot;)
public User update(User user) {
    // ....
}

@Cacheable(value=&quot;usr&quot;, key=&quot;targetClass + #p0&quot;)
public User save(User user) {
    // ...
}
</code></pre>

<h5 id="toc_4">@CacheEvict</h5>

<p>@CacheEvict 用来标注需要清除缓存元素的方法或类。该注解用于触发缓存的清除操作。其中属性有 <code>value</code>、<code>key</code>、<code>condition</code>、<code>allEntries</code> 和 <code>beforeInvocation</code>。可以用这些属性来指定清除的条件</p>

<pre><code class="java">@Cacheable(value=&quot;usr&quot;, key=&quot;#p0.id&quot;)
public User save(User user) {
    // ...
}

// 清除一条缓存
@CacheEvict(value=&quot;usr&quot;, key=&quot;#id&quot;) 
public void deleteBykey(int id) {
    // ...
}

// 在方法调用后清空所有缓存
@CacheEvict(value=&quot;accountCache&quot;, allEntries=true)
public void deleteAll() {
    // ...
}

// 在方法调用前清空所有缓存
@CacheEvict(value=&quot;accountCache&quot;, beforeInvocation=true)
public void deleteAll() {
    // ...
}
</code></pre>

<h5 id="toc_5">@Caching</h5>

<p>@Caching 用来组合多个注解标签，有 3 个属性：<code>cacheable</code>、<code>put</code> 和 <code>evict</code>，用于指定 @Cacheable、@CachePut 和 @CacheEvict</p>

<pre><code class="java">@Caching(cacheable={
    @Cacheable(value=&quot;usr&quot;, key=&quot;#p0&quot;),
    // ...
}, put={
    @CachePut(value=&quot;usr&quot;, key=&quot;#p0&quot;),
    // ...
}, evict={
    @CacheEvict(value=&quot;usr&quot;, key=&quot;#p0&quot;),
    // ...
})
public User save(User user) {
    // ...
}
</code></pre>

<h4 id="toc_6">实例</h4>

<p>使用简单缓存（SIMPLE 方式）进行缓存管理</p>

<h5 id="toc_7">1. 添加依赖</h5>

<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<h5 id="toc_8">2. 配置缓存管理器</h5>

<p>application.properties 中配置目标缓存管理器，支持 Ehcache、Generic、Redis、Jcache 等。这里使用 SIMPLE 方式 &ldquo;spring.cache.type=SIMPLE&rdquo;</p>

<h5 id="toc_9">3. 开启缓存功能</h5>

<p>在入口类添加注解 <code>@EnableCaching</code> ，开启缓存功能</p>

<h5 id="toc_10">4. 在服务里实现编写缓存业务逻辑</h5>

<pre><code class="java">@CacheConfig(cacheNames = &quot;user&quot;)
@Service
public class UserServiceImpl implements UserService {
    @Autowired
    private UserRepository userRepository;

    // 查找用户
    @Override
    // @Cacheable(key = &quot;#id&quot;)
    // @Cacheable(key=&quot;#id&quot;,condition =&quot;#id==41&quot; )
    @Cacheable(key=&quot;#id&quot;,unless=&quot;#id.contains(41)&quot; )
    public User findUserById(long id) {
        User user = userRepository.findUserById(id);
        return user;
    }

    // 新增用户
    @Override
    @CachePut(key = &quot;#user.id&quot;)
    public User insertUser(User user) {
        user = this.userRepository.save(user);
        return user;
    }

    // 修改用户
    @Override
    @CachePut(key = &quot;#user.id&quot;)
    public User updateUserById(User user) {
        return userRepository.save(user);
    }

    // 删除用户
    @Override
    @CacheEvict(key = &quot;#id&quot;)
    public void deleteUserById(long id) {
        userRepository.deleteById(id);
    }
}
</code></pre>

<p>查找用户使用注解 @Cacheable 开启缓存。修改添加方法使用了注解 @CachePut 。它是先处理方法，再把结果进行缓存。删除数据，则需要使用注解 @CacheEvict 来清空缓存。</p>

<h5 id="toc_11">5. 控制器里调用缓存服务</h5>

<pre><code class="java">@RestController
@RequestMapping(&quot;user&quot;)
public class UserController {
    @Autowired
    private UserService userService;

    // 添加用户
    @PostMapping(&quot;/&quot;)
    public void insertUser() throws Exception {
        User user = new User();
        user.setUsername(&quot;zhonghua&quot;);
        userService.insertUser(user);
    }

    // 查找用户
    @GetMapping(&quot;/{id}&quot;)
    public void findUserById(@PathVariable long id) throws Exception {
        User user = userService.findUserById(id);
        System.out.println(user.getId() + user.getUsername());
    }


    // 修改用户
    @PutMapping(&quot;/{id}&quot;)
    public User updateUserById(User user) {
        return userService.updateUserById(user);
    }
    
    // 删除用户
    @DeleteMapping(&quot;/{id}&quot;)
    public void deleteUserById(@PathVariable long id) {
        userService.deleteUserById(id);
    }
}
</code></pre>

<h4 id="toc_12">整合 Ehcache</h4>

<p>Spring Boot 支持多种不同的缓存产品，在默认情况下使用的是简单缓存。不建议在正式环境中使用。可以配置一些更强大的缓存，比如 Ehcache</p>

<p>Ehcache 是一种广泛使用的开源 Java 分布式缓存，它具有内存和磁盘存储、缓存加载器、缓存扩展、缓存异常处理、GZIP 缓存、Servlet 过滤器，以及支持 REST 和 SOAP API 等特点</p>

<p>使用 Ehcache ，要先添加如下依赖</p>

<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<p>具体使用如下</p>

<pre><code class="java">@CacheConfig(cacheNames={&quot;userCache&quot;})
public class UserServiceImpl implements UserService {
    @Cacheable(key=&quot;targetClass + methodName + #p0&quot;)
    public List&lt;User&gt; findAllLimit(int num) {
        return userRepository.findAllLimit(num);
    }
}
</code></pre>

<h4 id="toc_13">整合 Caffeine</h4>

<p>Caffeine 是使用 Java 8 对 Guava 缓存的重写版本。它基于 LRU 算法实现，支持多种缓存过期策略。增加 Caffeine 依赖，Spring Boot 就会自动用 Caffeine 替换默认的简单缓存</p>

<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt;
    &lt;artifactId&gt;caffeine&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<p>配置参数</p>

<pre><code class="properties">spring.cache.type=caffeine
spring.cache.cache-names=myCaffeine
spring.cache.caffeine.spec=maximumSize=1,expireAfterAccess=5s
</code></pre>

<p>代码解释如下</p>

<ul>
<li>spring.cache.type：指定使用哪个缓存供应商</li>
<li>spring.cache.cache-names：在启动时创建缓存名称（即前面的 cacheNames）。如果有多个名称，则用逗号进行分隔</li>
<li>spring.cache.caffeine.spec：这是 Caffeine 缓存的专用配置</li>
<li>maximumSize=1：最大缓存数量。如果超出最大缓存数量，则保留后进（最新）的，最开始的缓存会被清除</li>
<li>expireAfterAccess=5s：缓存 5s ，即缓存在 5s 之内没有被使用，就会被清除。在默认情况下，缓存的数据会一直保存在内存中，有些数据可能用一次后很长时间都不会再用，这样会有大量无用的数据长时间占用内存，我们可以通过配置及时清除不需要的缓存</li>
</ul>
