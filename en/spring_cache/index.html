spring_cache
Spring Cache
spring 


<p>Spring Cache 是 Spring 提供的一整套缓存解决方案。它本身并不提供缓存实现，而是根据统一的接口和代码规范、配置、注解等，以便整合各种 Cache 方案，使用户不用关心 Cache 的细节</p>

<p>Spring 支持透明地向应用程序添加缓存，将缓存应用于方法，在方法执行前检查缓存中是否有可用的数据。这样可以减少方法执行的次数，同时提高响应的速度。缓存的应用方式透明不会对调用者造成任何干扰。只要通过注解 <code>@EnableCaching</code> 启用了缓存支持，Spring Boot 就会自动处理好缓存的基础配置</p>

<p>Spring Cache 作用在方法上。当调用一个缓存方法时，会把方法参数和返回结果作为一个<strong>键值对</strong>存放在缓存中，下次用同样的参数来调用该方法时将不再执行该方法，而是直接从缓存中获取结果进行返回，所以在使用 Spring Cache 时，要保证在缓存的方法和方法参数相同时返回相同的结果。</p>

<h4 id="toc_0">声明式缓存注解</h4>

<table>
<thead>
<tr>
<td>注解</td>
<td>说明</td>
</tr>
</thead>

<tbody>
<tr>
<td>@EnableCaching</td>
<td>开启缓存</td>
</tr>

<tr>
<td>@Cacheable</td>
<td>作用于方法和类上，以键值对方式缓存类或方法的返回值</td>
</tr>

<tr>
<td>@CachePut</td>
<td>方法被调用，然后结果被缓存</td>
</tr>

<tr>
<td>@CacheEvict</td>
<td>清空缓存</td>
</tr>

<tr>
<td>@Caching</td>
<td>用来组合多个注解标签</td>
</tr>
</tbody>
</table>

<h5 id="toc_1">@EnableCaching</h5>

<p>标注在入口类上，用于开启缓存</p>

<h5 id="toc_2">@Cacheable</h5>

<p>键可以有默认策略和自定义策略</p>

<p>@Cacheable 注解会先查询是否已经有缓存，如果已有则会使用缓存，如果没有则会执行方法并进行缓存</p>

<p>@Cacheable 可以指定 3 个属性——value、key、和 condition</p>

<ul>
<li>value：缓存的名称，在 Spring 配置文件中定义，必须指定至少一个。如 <code>@Cacheable(value=&quot;cache1&quot;)</code> 、<code>@Cacheable(value={&quot;cache1&quot;, &quot;cache2&quot;})</code></li>
<li>key：缓存的 key 可以为空，如果自定义 key ，则需要按照 SpEL 表达式编写。可以自定按照方法的参数组合。如，<code>@Cacheable(value=&quot;cache1&quot;, key=&quot;#id&quot;)</code></li>
<li>condition：缓存的条件可以为空，如果自定义 condition，则使用 SpEL 表达式编写，以返回 true 或 false 值，只有返回 true 才进行缓存。如，<code>@Cacheable(value=&quot;cache1&quot;, condition=&quot;#id.length()&gt;2&quot;)</code></li>
</ul>

<p>使用方式如下</p>

<pre><code class="java">@Cacheable(value=&quot;emp&quot;, key=&quot;targetClass + methodName + #p0&quot;)
public User findUserById(long id) {
    return userRepository.findById(id);
}
</code></pre>

<p>代码解释如下：</p>

<ol>
<li>value 是必需的，它指定了缓存存放的位置</li>
<li>key 使用的是 SpEL 表达式</li>
<li>User 实体类一定要实现<strong>序列化</strong>，否则会报 <i>java.io.NotSerializableException</i> 异常。序列化可以继承 <code>Serializable</code></li>
</ol>

<h5 id="toc_3">@CachePut</h5>

<p>@CachePut 标注的方法在执行前不检查缓存是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。和 @Cacheable 不同的是，@CachePut 每次都会触发真实方法的调用，比如用户更新缓存数据</p>

<p>注意该注解的 value 和 key 必须与要更新的缓存相同，即与 @Cacheable 相同</p>

<pre><code class="java">@CachePut(value=&quot;usr&quot;, key=&quot;targetClass + #p0&quot;)
public User update(User user) {
    // ....
}

@Cacheable(value=&quot;usr&quot;, key=&quot;targetClass + #p0&quot;)
public User save(User user) {
    // ...
}
</code></pre>

<h5 id="toc_4">@CacheEvict</h5>

<p>@CacheEvict 用来标注需要清除缓存元素的方法或类。该注解用于触发缓存的清除操作。其中属性有 <code>value</code>、<code>key</code>、<code>condition</code>、<code>allEntries</code> 和 <code>beforeInvocation</code>。可以用这些属性来指定清除的条件</p>

<pre><code class="java">@Cacheable(value=&quot;usr&quot;, key=&quot;#p0.id&quot;)
public User save(User user) {
    // ...
}

// 清除一条缓存
@CacheEvict(value=&quot;usr&quot;, key=&quot;#id&quot;) 
public void deleteBykey(int id) {
    // ...
}

// 在方法调用后清空所有缓存
@CacheEvict(value=&quot;accountCache&quot;, allEntries=true)
public void deleteAll() {
    // ...
}

// 在方法调用前清空所有缓存
@CacheEvict(value=&quot;accountCache&quot;, beforeInvocation=true)
public void deleteAll() {
    // ...
}
</code></pre>

<h5 id="toc_5">@Caching</h5>

<p>@Caching 用来组合多个注解标签，有 3 个属性：<code>cacheable</code>、<code>put</code> 和 <code>evict</code>，用于指定 @Cacheable、@CachePut 和 @CacheEvict</p>

<pre><code class="java">@Caching(cacheable={
    @Cacheable(value=&quot;usr&quot;, key=&quot;#p0&quot;),
    // ...
}, put={
    @CachePut(value=&quot;usr&quot;, key=&quot;#p0&quot;),
    // ...
}, evict={
    @CacheEvict(value=&quot;usr&quot;, key=&quot;#p0&quot;),
    // ...
})
public User save(User user) {
    // ...
}
</code></pre>
