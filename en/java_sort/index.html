java_sort
java Sort
java 


<h3 id="toc_0">排序算法类的模板</h3>

<pre><code class="java">public class Example {
    public static void stort (Compareable[] a) {
        // 见算法 2.1、2.2、2.3、2.4、2.5 或 2.7
    }
    
    private static boolean less (Comparable v, Comparable w) {
        return v.compareTo(w) &lt; 0;
    }
    
    private static void exah (Comparable[] a, int i, int j) {
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }
    
    private static void show (Comparable[] a) {
        // 在单行中打印数组
        for (int i=0; i&lt;a.length; i++)
            System.out.print(a[i] + &quot;&quot;);
        System.out.println();
    }
    
    private static boolean isStored (Comparable[] a) {
        // 测试数组元素是否有序
        for (int i=1; i&lt;a.length; i++)
            if (less(a[i], a[i-1])) return false;
        return true;
    }
    
    public static void main(String[] args) {
        // 从标准输入读取字符串，将它们排序并输出
        String[] a = In.readString();
        sort(a);
        assert isStored(a);
        show(a);
    }
}
</code></pre>

<h3 id="toc_1">算法2.1 选择排序</h3>

<p>找到数组中最小的元素，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素则它和自己交换。）再在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。此为*选择排序*，因为它在不断选择剩余元素之中的最小值。</p>

<pre><code class="java">

public class Selection {
    public static void sort(Comparable[] a) {
        // 将 a[] 按升序排序
        for (int i=0; i&lt;N; i++) {
            // 将 a[i] 和 a[i+1..N] 中最小的元素交换
            int min = i;
            for (int j = i+1; j&lt;N; j++)
                if (less(a[j], a[min])) min = j;
            exah(a, i, min);
        }
    }
    // less()、exch()、isSorted() 和 main() 方法见 “排序算法类模板”
}
</code></pre>

<p>选择排序的内循环只是在比较当前元素与目前已知最小元素（以及将当前索引加 1 和检查是否代码越界）交换元素的代码写在内循环中，每次交换都能排定一个元素，因此交换的总次数是 <i>N</i> 。所以算法的事件效率取决于比较的次数。</p>

<p>选择排序的特点：</p>

<ul>
<li><strong>运行时间和输入无关</strong>：为了找出最小的元素而扫描一遍数组并不能为下一边扫描提供信息。该特质在某些情况下是缺点，一个有序的数组或是主键全部相等的数组和一个元素随机排列的数组所用的排序时间一样长。其他算法会更善于利用输入的初始状态。</li>
<li><strong>数组移动是最少的</strong>：每次交换都会改变两个数组元素的值，因此选择排序</li>
</ul>

<h3 id="toc_2">算法2.2 插入排序</h3>

<p>通常人们在整理桥牌方法是一张一张来，将每一张牌插入到其他已经有序的牌中的适当位置。在计算机的实现中，为了给要插入的元素腾出空间，需要将其余所有元素在插入之前都向右移动一位。这种算法叫做 <i>插入排序</i> 。</p>

<p>与选择排序一样，当索引左边所有的元素都是有序的，但它们的最终位置还不确定，为了给更小的元素腾出空间，它们可能会被移动。但当索引到达数组的右端时，数组排序就完成了。</p>

<p>和选择排序不同的是，插入排序所需的时间取决于输入中元素的初始顺序。对一个极大且其中元素已经有序（或接近有序）的数组进行排序将会比对随机顺序的元素或逆序数组进行排序要快的多</p>

<pre><code class="java">public class Insertion {
    
    public static void sort(Comparable[] a) {
        // 将 a[] 升序排序
        int N = a.length;

        for (int i = 1; i &lt; N; i++) {
            // 将 a[i] 插入到 a[i-1]、a[i-2]、a[i-2]...之中
            for (int j = 1; j &gt; 0 &amp;&amp; less(a[j], a[j-1]); j--)
                each(a, j, j-1);
        }
    }
}
</code></pre>

<p>对于 1 到 N-1 之间每一个 i，将 a[i] 与 a[0] 到 a[i-1] 中比它小的所有元素依次有序地交换。在索引 i 由左到右的过程中，它左侧的元素总是有序的，所以当 i 到达数组的右端时排序就完成了。</p>

<p>一般情况下数组是<strong>部分有序</strong>的。倒置指的是数组中两个顺序颠倒的元素，例如 EXAMPLE 中有 11 对倒置：E-A、X-A、X-M等。如果数组中倒置的数量小于数组大小的某个倍数，这个数组是部分有序的。</p>

<p>下面是几种典型的部分有序的数组：</p>

<ul>
<li>数组中每个元素距离它的最终位置都不远</li>
<li>一个有序的大数组接一个小数组</li>
<li>数组中只有几个元素的位置不正确</li>
</ul>

<p>插入排序对这种数组很有效，选择排序则不然。事实上，当倒置的数量很少时，插入排序可能比其他任何算法都要快。</p>

<p>要大幅提高插入排序的速度并不难，只需要在内循环中将较大的元素都向右移动而不总是交换两个元素（这样访问数组的次数就能减半）</p>

<h4 id="toc_3">希尔排序</h4>

<p>希尔排序基于插入排序，对于大规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点点地从数组一端移动到另一端。</p>

<p>希尔排序的思想是使数组中任意间隔为 h 的元素都是有序的。这样的数组被称为 <strong>h 有序数组</strong>。一个 h 有序数组就是 h 个互相独立的有序数组编织在一起组成的一个数组。在进行排序时，如果 h 很大，我们就能将元素移动到很远的地方，为实现更小的 h 有序创造方便。用这种方式，对于任意以 1 结尾的 h 序列，都能将数组排序，这就是希尔排序。排序的实现使用了序列 1/2（3^k-1）,从 <i>N/3</i> 开始递减至 1。这个序列称之为<strong>递增序列</strong>，希尔排序实时计算了它的递增序列，另一种方式是将递增序列存储在一个数组中。</p>

<p>实现希尔排序的一种方法时对于每个 h ，用插入排序将 h 个子数组独立地排序。但因为子数组是相对独立地，一个简单地方法时在 h- 子数组中将每个元素交换到比它大地元素之前去（将比它大地元素向右移动一格）。只需要在插入排序地代码中将移动元素的距离由 1 改为 h 即可。这样希尔排序的实现就转化为了一个类似插入排序但使用不同增量的过程。</p>

<p>希尔排序更高效的原因是它权衡了子数组的规模和有效性。排序之初，各个子数组都很短，排序后子数组都是部分有序的。这两种情况都很适合插入排序。子数组部分有序的程度取决于递增序列的选择。透彻理解希尔排序的性能较难</p>

<pre><code class="java">public class Shell {
    
    public static void sort(Comparable[] a) {
        // 将 a[] 升序排序
        int N = a.length;
        int h = 1;
        
        while (h &lt; N/3)
            h = 3*h + 1;    // 1, 4, 13, 40, 121,364, 1093...
        
        while (h &gt;= 1) {
            // 将数组变为 h 有序
            for (int i = h; i &lt; N; i++) {
                // 将 a[i] 插入到 a[i-h]、a[i-2*h]、a[i-3*h]...之中
                for (int j = 1; j &gt;= h &amp;&amp; less(a[j], a[j-h]); j -= h)
                    each(a, j, j-h);
            }
            h = h/3;
        }
    }
}
</code></pre>

<p>如果在插入排序中加入一个外循环来将 h 按照递增序列递减，就得到了这个简洁的希尔排序。增幅 h 的初始值是数组长度乘以一个常数因子，最小为 1.</p>

<h4 id="toc_4">如何选择递增序列</h4>

<p>算法的性能不仅取决于 h，还取决于 h 之间的数学性质，比如它们的公因子等</p>

<p>和选择以及插入排序相比，希尔排序可用于大型数组。它对任意排序（不一定是随机的）的数组表现也很好。实际上，队医一个给定的递增序列，构造一个使希尔排序进行缓慢的数组并不容易。</p>

<p>通过 <code>SortCompare</code> 可以看到，希尔排序比插入排序和选择排序要快的多，并且数组越大，优势越大。</p>

<p>有些程序员有时会选择希尔排序，因为对于中等大小的数组它的运行时间是可以接受的。它的代码量很小，且不需要使用额外的内存空间。接下来会有更高效的算法，但除了对于很大的 <i>N</i> ，它们可能只会比希尔排序快两倍（可能还达不到），而且更复杂。如果你需要解决一个排序问题而又没有系统排序函数可用（例如直接接触硬件或运行于嵌入式系统中的代码），可以先使用希尔排序，然后再考虑是否值得将它替换为更加复杂的排序算法。</p>
