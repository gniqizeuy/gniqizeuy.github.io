java_primitive
Java Primitive
java 


<h3 id="toc_0">基本类型优于装箱基本类型</h3>

<p>Java 中有一个类型系统由两部分组成，基本类型（primitive）以及引用类型（reference type）。每个基本类型都有一个对位的引用类型，称作装箱基本类型（boxed primitive）。</p>

<p>自动装箱（autoboxing）和自动拆箱（auto-unboxing）模糊了但并没有完全抹去基本类型和装箱基本类型之间的区别。</p>

<p>两者有三个主要区别：</p>

<ol>
<li>基本类型只有值，而装箱基本类型则具有与它们的值不同的同一性。即两个装箱基本类型可以具有相同的值和不同的同一性。</li>
<li>基本类型<strong>只有函数值</strong>，而每个装箱基本类型则<strong>都有一个非函数值</strong>，除了它对应的基本类型的所有函数值之外，还有个null。</li>
<li>基本类型通常比装箱基本类型更节省时间和空间。</li>
</ol>

<h4 id="toc_1">问题一：比较</h4>

<p>以下示例被用来表示 Integer 值的递增数字顺序。</p>

<pre><code class="java">Comparator&lt;Integer&gt; naturalOrder = (i, j) -&gt; (i &lt; j) ? -1: (i == j ? 0 ： 1);
</code></pre>

<p>上述比较器有严重的缺陷，打印 naturalOrder.Compare(new Integer(42), new Integer(42)) 时，实际输出的是 1 不是 0，表明第一个Integer值大于第二个</p>

<p>原因在于对表达式 i &lt; j 执行计算会导致 i 和 j 引用的 Integer 实例被自动拆箱；从而对值进行比较，但在执行表达式 i == j 时，执行的其实是*同一性比较*（identity comparision）。</p>

<p>对代码修改实现如下：(先拆箱再比较)</p>

<pre><code class="java">Comparator&lt;Integer&gt; naturalOrder = (iBoxed, jBoxedBoxed) -&gt; {
    int i = iBoxed, j = jBoxed;
    return i &lt; j ? -1 : (i == j ? 0 : 1);
}
</code></pre>

<p>如果需要比较器描述一个类型的自然顺序，使用 Comparator.naturalOrder() 即可，自己编写比较器，则应该使用比较器构造方法，或者在基本类型上使用静态比较方法。</p>

<p>以下小程序会导致 <em>NullPointerException</em> 异常</p>

<pre><code class="java">public Class Unbelievable {
    static Integer i;
    
    public static void main(String[] args) {
        if (i == 42)
            System.out.println(&quot;Unbelievable&quot;);
    }
}
</code></pre>

<p>i 是个 Integer 与所有的对象引用域一样，它的初始值为 null。当程序计算表达式 (i == 42) 时，他会将 Integer 与 int 进行比较，混用基本类型和装箱基本类型时，<strong>装箱基本类型会自动拆箱</strong>。如果 null 对象引用被自动拆箱，就会抛出一个 <em>NullPointerException</em> 异常。</p>

<h4 id="toc_2">问题二：性能</h4>

<pre><code class="java">public static void main(String[] args) {
    long sum = 0L;
    for (long i = 0; i &lt; Integer.MAX_VALUE; i++)
        sum += 1;
    System.out.println(sum);
}
</code></pre>

<p>此程序运行起来与预计的要慢一些，因为它将一个局部变量（sum）声明为时装箱类型 Long，而不是基本类型 long。程序编译起来没有错误或警告，变量被反复地拆箱和装箱，导致明显的性能下降。</p>

<h4 id="toc_3">什么时候应该使用装箱基本类型：</h4>

<ol>
<li>作为集合中得元素、键和值。集合中不能存放基本类型，因此必须使用装箱基本类型。</li>
<li>在参数化类型和方法中，必须使用装箱基本类型作为类型参数，因为 Java 不允许使用基本类型。例 ThreadLocal&lt;Integer&gt;</li>
<li>在进行反射得方法调用时，必须使用装箱基本类型。</li>
</ol>

<p>当可以选择的时候，基本类型要优于装箱基本类型。基本类型更加简单，也更加快速。使用装箱基本类型时，要特别小心，<strong>自动装箱减少了使用装箱基本类型的烦琐性，但是并没有减少它的风险</strong>。当程序用 == 操作符比较两个装箱基本类型时，它做了统一性比较，这也许并不是你想要的。当程序进行设计装箱和拆箱基本类型的混合类型计算时，它会进行拆箱，当程序进行拆箱时，会抛出 <em>NullPointerException</em> 异常。最后，当程序装箱了基本类型值时，会导致较高的资源消耗和不必要的对象创建。</p>
