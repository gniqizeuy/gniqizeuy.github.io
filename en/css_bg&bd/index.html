css_bg&amp;bd
CSS background border
css 


<h3 id="toc_0">半透明边框（RGBA/HSLA 颜色）</h3>

<p>给容器一个白色背景和一道半透明的白色边框</p>

<pre><code class="css">border: 10px solid hsla(0.0%,100%,.5);
background: white;
</code></pre>

<p>上述 css 并不会达到需求，背景的白色会透过边框显示出来</p>

<pre><code class="css">border: 10px solid hsla(0.0%,100%,.5);
background: white;
background-clip: padding-box;
</code></pre>

<p>css3 中 使用 background-clip（初始值为 border-clip 意味背景会被元素的 border box 边框的外延框裁切掉。）如果不想背景侵入边框所在的范围，即把值设为</p>

<p>padding-box，这样浏览器就会用内边距的外延来把背景裁切掉。</p>

<h3 id="toc_1">多重边框（box-shadow）</h3>

<p>box-shadow 可接收第四个参数（称作扩张半径）,通过指定正负值，可让<strong>投影面积加大</strong>或<strong>减小</strong>。一个正值的扩张半径加上两个为零的偏移量以及为零的模糊值，得到的投影其实就像一道实线边框</p>

<pre><code class="css">background: yellowgreen;
box-shadow: 0 0 0 10px #655;
</code></pre>

<p>border 属性可生产完全一致的效果。不过 box-shadow 好处在于，<strong>它支持逗号分割法，我们可以创建任意数量的投影</strong>，因此，上例中可非常轻松的加上一道 deeppink 颜色的边框。</p>

<pre><code class="css">background: yellowgreen;
box-shadow: 0 0 0 10px #655, 0 0 0 15px deeppink;
</code></pre>

<p>唯一需要注意的是，box-shadow 是层层叠加的，第一层投影位于最顶层，依次类推。因此。需要按此规律调整扩张半径。比如说，在前面代码中还想在外圈再加一道 5px 的外框吗，那就需指定扩张半径的值为 15px（10px + 5px）还可以在这些边框的底下再加一层常规的投影</p>

<pre><code class="css">background: yellowgreen;
box-shadow: 0 0 0 10px #655,
            0 0 0 15px deeppink,
            0 2px 5px 15px rgba(0,0,0,.6)
</code></pre>

<p>多重投影解决方案在大多数场合下可以很好工作，但有一些注意事项：</p>

<ul>
<li><p>投影的行为和边框不完全一致，因为它不影响布局，而且也不会受到box-sizing 属性的影响。不过，可以通过内边距或外边距（取决于投影是内嵌还是外扩的）来额外模拟出边框所需要占据的空间</p></li>

<li><p>上述方法创建出的假边框出现在元素的<strong>外圈</strong>。它们并不会影响鼠标事件，比如悬停或点击。如果这一点非常重要，你可以给 box-shadow 属性加上 inset 关键字，来使投影绘制在元素的<strong>内圈</strong>。注意，此时需要你增加额外的内边距来腾出足够的空隙。</p></li>
</ul>

<h4 id="toc_2">outline 方案</h4>

<p>某些情况下，<strong>可能只需要两层边框</strong>，那就可以先设置一层常规边框，再加上outline（描边）属性来产生外层的边框。这样做边框样式十分灵活，不像上面的 box-shadow 方案只能模拟实线边框（box-shadow 无法模拟虚线边框）下例实现双层边框</p>

<pre><code class="css">background: yellowgreen;
border: 10px solid #655;
outline: 5px solid deeppink;
</code></pre>

<p>描边的另一个好处在于，可以通过 outline-offset 属性来控制它跟元素边缘之间的间距，这个属性可以接收负值。</p>

<p>这个方案同样存在一些注意点：</p>

<ul>
<li>如上所述，它只适用于双层“边框”的场景，因为 outline 并不能接受用逗号分隔的多个值。如果需要更多层的边框，只能采取前一种方案。</li>
<li>边框不一定会贴合 border-radius 属性产生的圆角，因此如果元素是圆角的，他的描边可能还是直角的。注意，此行为被 CSS 工作组认为是一个 bug，因此未来可能会改为整合 border-radius 圆角。</li>
<li>根据 CSS 基本 UI 特征（第三版规范）所述。“描边可以不是矩形”。尽管在绝大多数情况下，描边都是矩形，但如果你想使用这个方法，请切记：最好在不同浏览器中完整地测试最终效果。</li>
</ul>
