abstract_factory
Abstract Factory
design 


<p>###　（Abstract Factory）抽象工厂模式——对象创建型模式</p>

<h4 id="toc_0">１.　意图：</h4>

<p>提供一个接口以创建一系列相关或相互依赖的对象，而无需指定它们具体的类</p>

<h4 id="toc_1">2.  别名</h4>

<p>Kit</p>

<h4 id="toc_2">3. 动机</h4>

<p>考虑一个支持多种视感（look-and-feel）标准的用户界面工具包，例如 Motif 和 Presentation Manager。不同的视感风格诸如滚动条、窗口和按钮等用户界面“窗口组件”定义不同的外观和行为。为保证视感风格标准之间的可移植性，一个应用不应该为一个特定的视感外观硬编码它的窗口组件。在整个应用中实例化特定视感风格的窗口组件类将使得以后很难改变视感风格。</p>

<p>为解决这一问题，可以定义一个抽象的 WidgeFactory 类，这个类声明一个用来创建每一类的基本窗口组件的接口。每一个窗口组件都有一个抽象类，而具体子类则实现了窗口组件的特定视感风格。对于每一个抽象窗口组件类，WidgeFactory  接口都有一个返回新窗口组件对象的操作。客户调用这些操作以获得窗口组件实例，但客户并不知道其正在使用的是哪些具体类。这样客户就不依赖于一般的视感风格，如下图所示。</p>

<h4 id="toc_3">4. 适用性</h4>

<p>在以下情况下使用 Abstract Factory 模式</p>

<ul>
<li>一个系统要独立于它的产品的创建、组合和表示</li>
<li>一个系统要由多个产品系列中的一个来配置</li>
<li>要强调一系列相关的产品对象的设计以便进行联合使用</li>
<li>提供一个产品类库，但只想现实它们的接口而不是实现。</li>
</ul>

<h4 id="toc_4">5. 结构</h4>

<h4 id="toc_5">6. 参与者</h4>

<ul>
<li>AbstractFactory （WidgetFactory）</li>
</ul>

<p>— 声明一个创建抽象产品对象的操作接口</p>

<ul>
<li>ConcreteFactory （MotifWidgetFactory、PMWidgetFactory）</li>
</ul>

<p>— 实现创建具体产品对象的组件</p>

<ul>
<li>AbstractProduct （Window、ScrollBar）</li>
</ul>

<p>— 为一类产品对象声明一个接口</p>

<ul>
<li>ConcreteProduct（MotifWindow、MotifScrollBar）</li>
</ul>

<p>— 定义一个将被相应的具体工厂创建的产品对象。</p>

<p>— 实现 AbstractProduct 接口。</p>

<ul>
<li>Client</li>
</ul>

<p>— 仅使用由 AbstractFactory 和 AbstractProduct 类声明的接口。</p>

<h4 id="toc_6">7. 协作</h4>

<p>通常在运行时创建一个 ConcreteFactory 类的实例。这一具体的工厂创建具有特定实现的产品对象。为创建不同的产品对象，客户应使用不同的具体工厂。</p>

<p>AbstractFactory 将产品对象的创建延迟到它的 ConcreteFactory 子类。</p>

<h4 id="toc_7">8. 效果</h4>

<p>AbstractFactory 模式有以下优点和缺点：</p>

<p>1）<strong>它分离了具体的类</strong>　Abstract Factory 模式帮助你控制一个应用创建的对象的类。因为一个工厂封装创建产品对象的责任和过程，他将客户与类的实现分离。客户通过它们的抽象接口操纵实例。产品的类名也在具体工厂的实现中被隔离，即它们不出现在客户代码中。</p>

<p>2）<strong>它是的易于交换产品系列</strong>　一个具体工厂类在一个应用中仅出现一次——在它初始化的时候。这使得该百年一个应用的具体工厂变得很容易。只需要该百年具体的工厂即可使用不同的产品配置。这是因为一个抽象工厂创建了一个完整的产品系列，所以整个产品系列会立刻改变。在用户界面的例子中，仅需转换到相应的工厂对象并重新从创建接口，就可实现从 Motif 窗口组件转换为 Presentation Manager 窗组件。</p>

<p>3）<strong>它有利于产品的一致性</strong>　当一个系列中的产品对象被设计成一起工作时吗，一个应用一次只能使用同一个系列中的对象，这一点很重要，而 AbstractFactory 很容易做到这一点</p>

<p>4）<strong>难以支持新种类的产品</strong>　难以扩产抽象工厂以生产新种类的产品。这是因为 AbstractFactory 接口确定了可以被创建的产品集合。支持新种类的产品就需要扩展该工厂接口，这将涉及 AbstractFactory 和及其所有子类的改变。在实现一节中会讨论这个问题的一个解决办法。</p>

<h4 id="toc_8">9. 实现</h4>

<p>下面是实现 Abstract Factor 模式的一些有用技术：</p>

<p>1）<strong>将工厂作为单件</strong></p>

<p>一个应用中每个产品系列只需要一个 ConcreteFactory 的实例。因此工厂通常最好实现为一个 Singleton（）</p>

<p>2）<strong>创建产品</strong></p>

<p>Abstract Factory 仅声明一个创建产品的接口，真正创建产品是由 ConcreteFactory  子类实现的。最通常的方法是为每一个产品定义一个工厂方法。一个具体的工厂将为每个产品重定义该工厂方法以指定产品。虽然这样的实现很简单，但他要求每个产品系列都要有一个新的具体工厂子类，即使这些产品系列的差别很小。</p>

<p>如果有多个可能的产品系列，具体工厂也可以使用 Prototype 模式来实现。具体工厂使用产品系列中每一个产品的原型实例来初始化，且它通过复制它的原型来创建新的产品。基于原型的的方法使得并非每个新的产品系列都需要一个新的具体工厂类。</p>

<p>此处是 Smalltalk 中实现一个基于原型的工厂的方法。具体工厂在一个被称为 partCatalog 的字典中存储将被赋值的原型。方法 make：检索该原型并复制它。</p>

<pre><code class="c++">make : partName
     ^ (partCatalog at : partName) copy
</code></pre>

<p>具体工厂有一个方法用来向该目录中增加部件。</p>

<pre><code class="c++">addPart : partTemplate named : partNum
    partCatalog at : partName put : partTemplate
</code></pre>

<p>原型用一个符号标记它们，从而被增加到工厂中：</p>

<pre><code class="c++">aFactory addPart : aPrototype named : #ACMEWidget
</code></pre>

<p>在将类作为第一类对象的语言中，这个基于原型的方法可能有所变化。你可以将这些语言中的类堪称是退化的工厂，它仅创建一种产品。你可以将类存储在一个具体工厂中，这个具体工厂在变量中创建了新的实例。你可以通过使用产品的类还不是子类初始化一个具体工厂实例来定义一个新的具体工厂。这一方法利用了语言的特点，而纯基于原型的方法是与语言无关的。</p>

<h4 id="toc_9">10. 代码示例</h4>

<p>使用 Abstract Factor 模式创建迷宫。</p>

<p>类 MazeFactory 可以创建迷宫的构建。它构造房间、墙壁和房间之间的们。它可以用于从一个文件中读取迷宫说明图并建造相应迷宫的程序，或者用于一个随机建造迷宫的程序。建造迷宫的程序将 MazeFactory 作为一个参数，这样程序员就能指定要创建的房间、墙壁和门等类。</p>

<pre><code class="c++">class MazeFactory {
public:
    MazeFactory();
    
    virtual Maze* MakeMaze() const {
        return new Maze;
    }
    
    virtual Wall* MakeWall() const {
        return new Wall;
    }
    
    virtual Room* MakeRoom(int n) const {
        return new Room(n);
    }
    
    virtual Door* MakeDoor(Room* r1, Room* r2) const {
        return new Door(r1, r2);
    }
}
</code></pre>
