spring_validator
Spring Validator
spring 


<h4 id="toc_0">内置的 Hibernate-validator</h4>

<p>Hibernate-validator 可实现数据的验证，它是对 JSR（Java Specification Requests）标准的实现。在 Web 开发中，不需要额外为验证再导入其他依赖，只需要添加 Web 依赖即可。Web 依赖不只集成了 Hibernate-validator ，还有如下子依赖：</p>

<ul>
<li>spring-boot-starter</li>
<li>spring-boot-starter-json</li>
<li>spring-boot-starter-tomcat</li>
<li>Hibernate-validator</li>
<li>spring-web</li>
<li>spring-webmvc</li>
</ul>

<p>常用注解见下表</p>

<table>
<thead>
<tr>
<td>注解</td>
<td>作用类型</td>
<td>说明</td>
</tr>
</thead>

<tbody>
<tr>
<td>@NotBlank(message=)</td>
<td>字符串</td>
<td>验证字符串非 null ，且长度必须大于 0</td>
</tr>

<tr>
<td>@Email</td>
<td>字符串</td>
<td>被注释的元素必须是带脑子邮箱地址</td>
</tr>

<tr>
<td>@Length(min=, max=)</td>
<td>字符串</td>
<td>被注释的字符串大小必须在指定的范围内</td>
</tr>

<tr>
<td>@NotEmpty</td>
<td>字符串</td>
<td>被注释的字符串必须非空</td>
</tr>

<tr>
<td>@NotEmptyPattern</td>
<td>字符串</td>
<td>在字符串不为空的情况下，是否匹配正则表达式</td>
</tr>

<tr>
<td>@DateValidator</td>
<td>字符串</td>
<td>验证日期格式是否满足正则表达式，Local 为英语</td>
</tr>

<tr>
<td>@DateFormatCheckPattern</td>
<td>字符串</td>
<td>验证日期格式是否满足正则表达式，Local是自己手动指定的</td>
</tr>

<tr>
<td>@CreditCardNumber</td>
<td>字符串</td>
<td>验证信用卡号码</td>
</tr>

<tr>
<td>@Range(min=, max=, message=)</td>
<td>数值类型、字符串、字节等</td>
<td>被注释的元素必须在合适的范围内</td>
</tr>

<tr>
<td>@Null</td>
<td>任意</td>
<td>被注释的元素必须为 null</td>
</tr>

<tr>
<td>@NotNull</td>
<td>任意</td>
<td>被注释的元素必须不为 null</td>
</tr>

<tr>
<td>@AssertTrue</td>
<td>布尔值</td>
<td>被注释的元素必须为 true</td>
</tr>

<tr>
<td>@AssertFalse</td>
<td>布尔值</td>
<td>被注释的元素必须为 false</td>
</tr>

<tr>
<td>@Min(value)</td>
<td>数字</td>
<td>被注释的元素必须是一个数字，且大于或等于指定的最小值</td>
</tr>

<tr>
<td>@Max(value)</td>
<td>数字</td>
<td>被注释的元素必须是一个数字，且小于或等于指定的最大值</td>
</tr>

<tr>
<td>@DecimalMin(value)</td>
<td>数字</td>
<td>被注释的元素必须是一个数字，且大于或等于指定的最小值</td>
</tr>

<tr>
<td>@DecimalMax(value)</td>
<td>数字</td>
<td>被注释的元素必须是一个数字，且小于或等于指定的最大值</td>
</tr>

<tr>
<td>@Size(max=, min=)</td>
<td>数字</td>
<td>被注释的元素大小必须在指定的范围内</td>
</tr>

<tr>
<td>@Digits(integer, fraction)</td>
<td>数字</td>
<td>被注释的元素必须是一个数字，且在可接收的范围内</td>
</tr>

<tr>
<td>@Pasl</td>
<td>日期</td>
<td>被注释的元素必须是一个过去的日期</td>
</tr>

<tr>
<td>@Future</td>
<td>日期</td>
<td>被注释的元素必须是一个将来的日期</td>
</tr>

<tr>
<td>@Pattern(regex=, flag=)</td>
<td>正则表达式</td>
<td>被注释的元素必须符合指定的正则表达式</td>
</tr>

<tr>
<td>@ListStringPattern</td>
<td>List&lt;String&gt;</td>
<td>验证集合中的字符串是否满足正则表达式</td>
</tr>
</tbody>
</table>

<h4 id="toc_1">自定义验证功能</h4>

<p>自定义验证功能 需要两个类：自定义注解类，自定义验证业务逻辑类</p>

<p><strong>自定义注解类</strong>，以便在实体 Bean 中使用它</p>

<pre><code class="java">import com.example.MyConstraintValidator;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

//用于指定使用范围，该处限定只能在字段上使用
@Target({ElementType.FIELD})
//表示注解在运行时可以通过反射获取到
@Retention(RetentionPolicy.RUNTIME)
//@Constraint注解，里面传入了一个validatedBy的字段，指定该注解校验逻辑
@Constraint(validatedBy = MyConstraintValidator.class)
public @interface MyConstraint {
    /**
     * @Description: 错误提示
     */
    String message() default &quot;请输入中国政治或者经济中心的城市名&quot;;
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}
</code></pre>

<p><strong>自定义验证业务逻辑类</strong></p>

<p>在自定义验证实现类中需要两个方法（initialize 和 isValid）——初始化验证消息的方法和执行验证的方法</p>

<p>在初始化验证消息的方法中，可以得到配置的注释内容，而验证方法则是用来验证业务逻辑的，它需要继承 ConstraintValidator 接口</p>

<pre><code class="java">import com.example.demo.MyConstraint;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class MyConstraintValidator implements ConstraintValidator&lt;MyConstraint, String&gt; {
    //String为校验的类型
    @Override
    public void initialize(MyConstraint myConstraint) {
        //启动时执行
    }

    /**
     * @Description: 自定义校验逻辑
     */
    @Override
    public boolean isValid(String s, ConstraintValidatorContext validatorContext) {
        if (!(s.equals(&quot;北京&quot;) || s.equals(&quot;上海&quot;))) {
            return false;
        }

        return true;
    }
}
</code></pre>

<p>至此，注解 @MyCustomConstraint 已被成功定义，可以在其他类中调用它来实现验证功能</p>

<h4 id="toc_2">验证表单数据并实现数据的自定义验证</h4>

<h5 id="toc_3">创建实体</h5>

<p>创建实体 Bean ，用于表单验证。这里要特别注意的是，定义的所有字段都需要被验证，否则会出错</p>

<pre><code class="java">import com.example.demo.MyConstraint;
import lombok.Data;
import org.hibernate.validator.constraints.Length;

import javax.validation.constraints.*;
import java.io.Serializable;

@Data
public class User implements Serializable {
    /**
     * 主键ID
     */
    private Long id;

    @NotBlank(message = &quot;用户名不能为空&quot;)
    @Length(min = 5, max = 20, message = &quot;用户名长度为5-20个字符&quot;)
    private String name;

    @NotNull(message = &quot;年龄不能为空&quot;)
    @Min(value = 18 ,message = &quot;最小18岁&quot;)
    @Max(value = 60,message = &quot;最大60岁&quot;)
    private Integer age;

    /*@NotBlank(message = &quot;电话不可以为空&quot;)
    @Length(min = 1, max = 13, message = &quot;电话长度需要在13个字符以内&quot;)
    private String phone;*/

    @Email(message = &quot;请输入邮箱&quot;)
    @NotBlank(message = &quot;邮箱不能为空&quot;)
    private String email;

   /* @NotNull(message = &quot;必须指定用户状态&quot;)
    @Min(value = 0, message = &quot;用户状态不合法&quot;)
    @Max(value = 1, message = &quot;用户状态不合法&quot;)
    private Integer status;*/

    @MyConstraint
    private String answer;

}

</code></pre>

<h5 id="toc_4">编写验证控制器</h5>

<pre><code class="java">import com.example.demo.entity.User;
import org.springframework.stereotype.Controller;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import javax.validation.Valid;

@Controller
public class TestValidator {

    @GetMapping(&quot;/test&quot;)
    public String showForm(User user) {
        return &quot;form&quot;;
    }

    @GetMapping(&quot;/results&quot;)
    public String results() {
        return &quot;results&quot;;
    }

    @PostMapping(&quot;/test&quot;)
    public String checkUser(@Valid User user, BindingResult bindingResult, RedirectAttributes attr) {
        //特别注意实体中的属性必须都验证过了，不然不会成功
        if (bindingResult.hasErrors()) {
            return &quot;form&quot;;
        }
        /**
         * @Description:
         * 1.使用RedirectAttributes的addAttribute方法传递参数会跟随在URL后面 ，如上代码即为?name=long&amp;age=45
         * 2.使用addFlashAttribute不会跟随在URL后面，会把该参数值暂时保存于session，待重定向url获取该参数后从session中移除，
         * 这里的redirect必须是方法映射路径。你会发现redirect后的值只会出现一次，刷新后不会出现了,对于重复提交可以使用此来完成。
         */
        attr.addFlashAttribute(&quot;user&quot;, user);
        return &quot;redirect:/results&quot;;

    }
}
</code></pre>

<p>代码解释如下：</p>

<ul>
<li><code>addAttribute</code>：用 RedirectAttributes 的 addAttribute 方法传递参数，参数应跟在 URL 后面</li>
<li><code>addFlashAttribute</code>：参数不会跟在 URL 后面，会被暂存在 session 中</li>
<li><code>redirect</code>：必须是方法的映射路径。redirect 后的值只会出现一次，刷新后不会出现，可以使用 redirect 方法来防止重复提交。</li>
</ul>

<h5 id="toc_5">编写视图</h5>

<p>用于提交表单和反馈验证</p>
