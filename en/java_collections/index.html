java_collections
Java collections
java 


<h3 id="toc_0">标准库中的集合与映射</h3>

<h4 id="toc_1">关于 Set 接口</h4>

<p>Set 接口代表不允许重复元的 Collection。由接口 SortedSet 给出的一种特殊类型的 Set 保证其中的各项处于有序的状态。因为一个Set IS-A Collection，所以用于访问继承 Collection 的 List 的项的方法也对 Set 有效。</p>

<p>由 Set 所要求的一些特殊的操作是一些插入，删除以及（有效地）执行基本查找的能力。对于 Set，add 方法返回 true 或 false。</p>

<p>保持各项以有序状态的 Set 的实现是 TreeSet。TreeSet 类的基本操作花费对数最坏情形时间。</p>

<p>默认情况下，排序假设 TreeSet 中的项实现 Comparable 接口。另一种排序可以通过用 Comparator 实例化 TreeSet 来确定。例如，可以创建一个存储 String 对象的 TreeSet，通过使用 CaseInsensitiveCompare 函数对象忽略大小写。下面代码中，Set s 大小为1。</p>

<pre><code class="java">Class CaseInsensitiveCompare implements Comparator&lt;String&gt; {
    public int compare(String lhs, String rhs) {
        return lhs.compareToIgnoreCase(rhs);
    }
}

Set&lt;String&gt; s = new TreeSet&lt;&gt;(new CaseInsensitiveCompare());
s.add(&quot;Hello&quot;);
s.add(&quot;HeLLo&quot;);
System.out.print(&quot;The size is: &quot; + s.size());
</code></pre>

<h4 id="toc_2">关于 Map 接口</h4>

<p>Map 是一个接口，代表由键以及值组成的一些项的集合。键唯一。在 SortedMap 接口中，映射中的关键字保持逻辑上有序状态。</p>

<p>SortedMap 接口的一种实现是 TreeMap 类。Map的基本操作包括诸如 isEmpty、clear、size 等方法，而且最重要的是包含以下方法：</p>

<pre><code class="java">boolean containsKey(keyType key);
ValueType get(keyType key);
ValueType put(KeyType key, ValueType value);
</code></pre>

<p>get 返回与 key 相关的值，key 不存在时返回 null。如果 Map 中不存在 null 值，那么由 get 返回值可以用来确定 key 是否存在 Map 中。然而，如果存在 null，那么必须使用 containsKey。方法 put 把键值对置入 Map 中，或者返回 null，或者返回与key 相联系的值。</p>

<p>迭代 Map 要比 Collection 复杂，因为 Map 不提供迭代器，而是根据 3 种方法，将 Map 对象的视图作为 Collection 对象返回。由于这些视图本身就是 Collection，因此它们可以被迭代。所提供的 3 种方法如下：</p>

<pre><code class="java">Set&lt;KeyType&gt; keySet();
Collection&lt;ValueType&gt; values();
Set&lt;Map.Entry&lt;KeyType, ValueType&gt;&gt; entrySet()
</code></pre>

<p>方法 keySet 和 values 返回简单的集合（键不包含重复元，因此以一个 Set 对象的形式返回）。</p>

<p>entrySet 方法是作为一些项而形成的 Set 对象被返回的（由于键唯一，因此不存在重复项）。每一项均由被嵌套的接口 Map.Entry 表示。对于类型 Map.Entry 的对象，其现有的方法包含访问键、键的值、以及改变键对应的值：</p>

<pre><code class="java">KeyType getKey();
ValueType getValue();
ValueType setValue(ValueType newValue);
</code></pre>

<h4 id="toc_3">遍历 Map</h4>

<h5 id="toc_4">通过 Map.keySet 使用 iterator 遍历</h5>

<pre><code class="java">Iterator&lt;Integer&gt; iterator = map.keySet().iterator();

while (iterator.hasNext()) {
    Integer key = iterator.next();
    String value = map.get(key);
    System.out.println(&quot;key = &quot; + key + &quot;, value = &quot; + value);
}
</code></pre>

<h5 id="toc_5">通过 Map.entrySet 使用 iterator 遍历</h5>

<pre><code class="java">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; entries = map.entrySet().iterator();

while (entries.hasNext()) {
    Map.Entry&lt;Integer, String&gt; entry = entries.next();
    System.out.println(entry);
}
</code></pre>

<h5 id="toc_6">通过 Map.keySet 遍历</h5>

<pre><code class="java">for (Integer key : map.keySet()) {
    System.out.println(&quot;key = &quot; + key + &quot;, value = &quot; + map.get(key));
}
</code></pre>

<h5 id="toc_7">通过 For-Each 迭代 entries，使用 Map.entrySet 遍历</h5>

<pre><code class="java">for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) {
    System.out.println(&quot;key = &quot; + entry.getKey() + &quot;, value = &quot; + entry.getValue());
}
</code></pre>

<h5 id="toc_8">使用 lambda 表达式 forEach 遍历</h5>

<pre><code class="java">map.forEach((k, v) -&gt; System.out.println(&quot;key = &quot; + k + &quot;, value = &quot; + v));
</code></pre>

<p>forEach 源码</p>

<pre><code class="java">default void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
    Objects.requireNonNull(action);
    for (Map.Entry&lt;K, V&gt; entry : entrySet()) {
        K k;
        V v;
        try {
            k = entry.getKey();
            v = entry.getValue();
        } catch(IllegalStateException ise) {
            throw new ConcurrentModificationException(ise);
        }
        action.accept(k, v);
    }
}
</code></pre>

<p><strong>推荐使用 entrySet 遍历 Map 类集合 KV</strong> ，而不是 keySet 方式进行遍历。</p>

<blockquote>
<p>keySet 其实是遍历了 2 次，第一次是转为 Iterator 对象，第二次是从 hashMap 中取出 key 所对应的 value 值。而 entrySet 只是遍历了一次，就把 key 和 value 都放到了 entry 中，效率更高。</p>

<p>values() 返回的是 V 值集合，是一个 list 集合对象；keySet() 返回的是 K 值集合，是一个 Set 集合对象；entrySet() 返回的是 K-V 值组合集合。</p>
</blockquote>

<p><strong>如果是 JDK8，推荐使用Map.forEach 方法</strong>。</p>
