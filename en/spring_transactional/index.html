spring_transactional
Spring transactional
spring 


<h3 id="toc_0">springboot 的事务处理 Transactional</h3>

<h4 id="toc_1">1. springboot事务</h4>

<p>两种处理方式</p>

<ul>
<li><strong>编程式事务管理</strong>，推荐使用<code>TransactionTemplate</code></li>
<li><strong>声明式事务管理</strong>，基于AOP原理的注解<code>@Transactional</code></li>
</ul>

<h4 id="toc_2">2. Transaction 的使用</h4>

<p>对于声明式事务，使用 <code>@Transactional</code> 进行标注，这个注解可以标注在类或方法上，标注在类上时，代表这个类所有公共非静态方法都将启用事务功能。在 @Transaction 中，还允许配置许多属性，如事务的隔离级别和传播行为；又如异常类型，从而确定方法发生什么异常下回滚事务或者发生异常下不回滚事务等。这写配置内容，是在 Spring IoC 容器在加载时就会将这些配置信息解析出来，然后把这些信息存到事务定义器（TransactionDefinition 接口的实现类）里，并且记录哪些类或者方法需要启动事务功能，采用什么策略去执行事务。</p>

<p>Spring 数据库事务机制约定流程如下图所示</p>

<p><img src="../img/spring_trans.png" alt="" />
</p>

<p>当 Spring上下文开始调用 被@Transactional 标注的类或者方法时，Spring 就会产生 AOP 的功能。请注意事务的底层需要启用 AOP 功能，这是 Spring 事务的底层实现，后面我们会看到一些陷阱。那么当它启动事务时，就会根据事务定义器内的配置去设置事务，首先是根据传播行为去确定事务的策略、然后是隔离级别、超时时间、只读等内容的设置，设置事务不需要开发者完成， Spring 事务拦截器会根据 @Transactional 配置的内容来完成。</p>

<p>Spring 数据库事务会很具发生的异常采取不同的策略</p>

<p>未发生异常，Spring 数据库拦截器提交事务。发生异常，就要判断一次事务定义器内的配置，如果事务定义器已经约定了该类型的异常不回滚事务就提交事务，如果没有任何配置或者不是配置不回滚事务的异常，则会回滚事务，并且将异常抛出，这步也是由事务拦截器完成的。</p>

<p>无论是否发生异常，Spring 都会释放事务资源，这样就可以保证数据库连接池正常可用，这也是由 Spring 事务拦截器完成的内容。</p>

<h5 id="toc_3">使用 Spring 数据库事务机制</h5>

<pre><code class="java">public class UserServiceImpl implements UserService {
    @Autowired
    private UserDao userDao = null;
    
    @Override
    @Transactional
    public int insertUser(User user) {
        return userDao.insertUser(user);
    }
}
</code></pre>

<h4 id="toc_4">@Transactional 的配置项</h4>

<p>数据库事务属性可以由 @Transactional 配置，先看下源码</p>

<pre><code class="java">package org.springFramework.transaction.annotation;

@Target(ELementType.METHOD, ELementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Transactional {
    // 通过 bean name 指定事务管理器
    @AliasFOr(&quot;transactionManager&quot;)
    String value() deafult &quot;&quot;;
    
    // 同 value 属性
    @AliasFor(&quot;value&quot;)
    String transactionManager() default &quot;&quot;;
    
    // 指定传播行为
    Propagation propagation() default Propagation.REQUIRED;
    
    // 指定隔离级别
    Isolation isolation() default Isolation.DEFAULT;
    
    // 指定超时时间（单位秒）
    int timeout() default TransactionDefinition.TIMEOUT_DEFAULT;
    
    // 是否只读事务
    boolean readOnly() default false;
    
    // 方法在发生指定异常时回滚，默认时所有异常都回滚
    Class&lt;? extends Throwable&gt;[] rollbackFor() default {};
    
    // 方法在发生指定异常名称时回滚，默认时所有异常都回滚
    String[] rollbackForClassNarne() default {};
    
    // 方法在发生指定异常时不回滚，默认时所有异常都回滚
    Class&lt;? extends Throwable&gt;[] noRollbackFor() default {};
    
    // 方法在发生指定异常名称时不回滚，默认时所有异常都回滚
    String[] noRollbackForClassNarne() default {};
}
</code></pre>

<p>Spring 团队推荐将 ＠Transactional 放在类上，因为放在接口上将使得类基于接口的代理时它才生效。Spring 可以使用 JDK 动态代理，也可以使用 CGLIG 动态代理。如果使用接口， 那么将不能切换为 CGLIB 动态代理，只能使用 JDK 动态代理，并且使用对应的接口去代理类 ，这样才能驱动这个注解，这将大大地限制使用，因此在实现类上使用 ＠Transactional 注解才是最佳的方式</p>

<h4 id="toc_5">Spring 事务管理器</h4>

<p>事务的打开、回滚和提交是由事务管理器来完成的。在 Spring 中，事务管理器的顶层接口为 <code>platformTransactionManager</code> ，Spring 还为此定义了一些列的接口和类，如下图</p>

<p><img src="../img/spring_trans1.png" alt="" />
</p>

<p>引入其他框架时，会有其他的事务管理器的类，比如引入 Hibernate 那么 Spring orm 包会提供 <code>HibernateTransactionManager</code> 与之对应并给我们使用 。最常用到的事务管理器是 DataSourceTransactionManager 。从上图可以看到它也是一个实现了接口 <code>PlatfonnTransactionManager</code> 为此可以看 PlatfonnTransactionManager 接口的源码</p>

<pre><code class="java">package org.springfrarnework.transaction;

public interface PlatforrnTransactionManager {
    // 获取事务 它还会设置数据属性
    TransactionStatus getTransaction(TransactionDefinition definition)
        throws TransactionException;
    // 提交事务
    void commit(TransactionStatus status) throws TransactionException;
    
    // 回滚事务
    void rollback(TransactionStatus status) throws TransactionException;
}
</code></pre>

<p>Spring 事务管理时， 就是将这些方法按照约定织入对应的流程中，其中 getTransaction 方法的参数是一个事务定义器（TransactionDefinition）它是依赖于配置的 ＠Transactional 的配置项生成的，于是通过它就能设置事务的属性，而提交和回滚事务也就可以通过 commit 和 rollback 方法来执行</p>

<p>Spring Boot 中，当依赖于 mybatis-spring-boot-starter 之后 它会自动创建一个 DataSourceTransactionManager 对象，作为事务管理器，如果依赖于 spring-boot-starter-data-jpa ，则它会自动创建 JpaTransactionManager 对象作为事务管理器，所以一般不需要自己创建事务管理器。</p>

<h4 id="toc_6">隔离级别</h4>

<p><strong>第一类丢失更新</strong>：对于一个事务回滚另外一个事务提交而引发的数据不一致的情况</p>

<p><strong>第二类丢失更新</strong>：多个事务都提交引发的丢失更新</p>

<p>为了压制丢失更新，数据库标准提出了 4 类隔离级别，在不同程度上压制丢失更新，分别为 <i>未提交</i>、<i>读写提交</i>、<i>可重复读</i>和串行化。</p>

<h5 id="toc_7">为什么只是在不同程度上压制丢失更新而不是全部消除丢失更新</h5>

<p>两个角度：数据的一致性，性能</p>

<p>数据库现有技术完全可以避免丢失更新。代价就是付出锁的代价，在互联网中，系统不单单要考虑数据的一致性，还要考虑系统的性能。如果在互联网中使用过多的锁 ，一旦出现商品抢购这样的场景，必然会导致大量的线程被挂起和恢复，因为使用锁之后，一个时刻只能由一个线程访问数据，这样真个系统会十分缓慢，当系统被数千甚至数万用户同时访问时，过多的锁会引发宕机，大部分用户线程被挂起，等待持有锁事务的完成，就这样用户的体验十分糟糕，因为用户的等待时间会十分漫长，一般而言，互联网系统响应超过 5 秒，就会让用户觉得很不友好，进而引发用户忠诚度下降的问题。所以先择隔离级别的时候，既要考虑数据的一致性避免脏数据，又要考虑性能的问题，因此数据库规范提出了 4 种隔离级别来在不同程度下压制丢失更新。以下通过商品抢购的场景来讲述 4 种隔离级别的区别</p>

<h5 id="toc_8">1. 未提交级</h5>

<p>未提交级（read uncommitted）是最低的隔离级别，含义是允许一个事务读取另一个事务没有提交的数据。未提交读是一种危险的隔离级别，所以一般在实际开发中应用不广，但是优点在于并发能力高，适合那些对数据一致性没有要求而追求高并发的场景，最大的坏处是出现脏读。</p>

<h5 id="toc_9">2. 读写提交</h5>

<p>读写提交（read committed）指一个事务只能读取另一个事务已经提交的数据，不能读取未提交的数据</p>

<h5 id="toc_10">3. 可重复读</h5>

<p>可重复读的目标是克服读写提交中出现的不可重复度现象，因为在读写提交时，可能出现一些值的变化，影响当前事务的执行</p>

<h5 id="toc_11">4. 串行化</h5>

<p>串行化（Serializable）是数据库最高的隔离级别，要求所有的 SQL 都会按照顺序执行，这样就可以克服上述隔离级别出现的各种问题，所以能完全保证数据的一致性</p>

<h5 id="toc_12">使用合理的隔离级别</h5>

<p>如下表所示</p>

<p>在开发高并发业务时需要时刻记住隔离级别可能发生的各种概念和相关的现象，这是数据库事务的核心内容之一，追求更高的隔离级别，它能更好地保证数据的一致性，但是也要付出锁的代价。有了锁，意味着性能的丢失，而且隔离级别越高，性能也直线下降，所以要进行双重考虑。</p>

<p>一般而言，隔离级别会以读写提交为主，它能防止脏读，而不能避免不可重复读和幻读。为了克服数据不一致和性能问题，开发者设计了乐观锁，甚至使用其他手段，如：使用 Redis 作为数据载体。不同的数据库对隔离级别的支持也不一样，例如：Oracle 只支持读写提交和串行化，MySQL 支持 4 种，MySQL 默认的隔离级别为读写提交，MySQL 为可重复读</p>

<h5 id="toc_13">使用隔离级别</h5>

<p>在 <code>@Transactional</code> 配置对应即可</p>

<pre><code class="java">@Transactional(isolation = Isolation.SERIALIZABLE)
public int insertUser(User user) {
    return userDao.insertUser(user);
}
</code></pre>

<p>上面代码采用序列化的隔离级别来保证数据的一致性，可以阻塞其他事务进行并发，所以只能运用于低并发又需要保证数据一致性的场景下</p>

<p>Spring Boot 可以通过配置文件指定默认隔离级别</p>

<pre><code class="properties"># 隔离级别数字配置的含义：
# -1 数据库默认隔离级别
# 1 未提交级
# 2 读写提交
# 4 可重复读
# 8 串行化
# tomcat 数据源默认隔离级别
spring.datasource.tomcat.default-transaction-isolation=2
# dbcp2 数据库连接池默认隔离级别
spring.datasource.dbcp2.default-transaction-isolation=2
</code></pre>

<h4 id="toc_14">传播行为</h4>

<p>传播行为是方法之间调用事务采取的策略问题。绝大部分的情况下，数据库事务要么成功，要么全部失败。但也有例外：执行一个批量程序，它会处理很多交易，绝大部分交易时可以顺利完成的，但也有极少数的交易因为特殊原因不能完成而发生异常，这是不应该因为少数的交易不能完成而回滚批量任务调用的其他交易，此时，真实的需求时，在一个批量任务执行的过程中，调用多个交易，如果有一些交易发生异常，只是回滚那些出现异常的交易，而不是整个批量任务。</p>

<p>Spring 中，当一个方法调用另一个方法时，可以让事务采取不同的策略工作，如新建事务或者挂起当前事务等，这便是事务的传播行为。</p>

<h5 id="toc_15">传播行为的定义</h5>

<p>Spring 事务机制中对数据库存在 7 种传播行为，它是通过枚举类 <code>Propagation</code> 定义的。源码如下</p>

<pre><code class="java">package org springframework.transaction.annotation;

public enum Propagation {
    /**
    * 常用
    * 需要事务，它是默认传播行为，如果存在事务，就沿用当前事务
    * 否则新建一个事务运行子方法
    */
    REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),
    
    /**
    * 支持事务，如果存在事务，就沿用当前事务
    * 如果不存在，则继续采用无事务的方式运行子方法
    */
    SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),
    
    /**
    * 必须使用事务，如果当前没有事务，则会抛出异常
    * 如果存在事务，就沿用当前事务
    */
    MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),
    
    /**
    * 常用
    * 无论当前事务是否存在，都会创建新事务运行方法
    * 这样新事务就可以拥有新的锁和隔离级别等特性，与当前事务相互独立
    */
    REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),

    /**
    * 不支持事务，当前事务时，将挂起事务，运行方法
    */
    NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),
    
    /**
    * 不支持事务，如果当前方法存在事务，则抛出异常，否则继续使用无事务机制运行
    */
    NEVER(TransactionDefinition.PROPAGATION_NEVER),
    
    /**
    * 常用
    * 在当前方法调用子方法时，如果子方法发生异常
    * 只回滚子方法执行过的 SQL ，而不回滚当前方法的事务
    */
    NESTED(TransactionDefinition.PROPAGATION_NESTED),
    
    private final int value;
    
    Propagation(int value) { this.value = value; }
    
    public int value() { return this.value }
}
</code></pre>

<p>如何使用</p>

<pre><code class="java">@Service 
public class UserBatchServiceimpl implements UserBatchService {
    @Autowired
    private UserService userService = null; 
    
    @Override
    @Transactional(isolation = Isolation.READ_COMMITTED, propagation=Propagation.REQUIRED)
    public int insertUsers(List&lt;User&gt; userList) {
        int count = 0;
        for (User user : userList) {
            // 调用子方法，将使用 ＠Transactional 定义的传播行为
            count+= userService.insertUser(user);
        }
        return count;
    }
}
</code></pre>

<h5 id="toc_16">@Transactional 自调用失效问题</h5>

<p>@Transactional 在某些场景下会失效</p>

<pre><code class="java">@Service 
public class UserBatchServiceimpl implements UserBatchService {
    @Autowired
    private UserDao userDao = null; 
    
    @Override
    @Transactional(isolation = Isolation.READ_COMMITTED, propagation=Propagation.REQUIRED_NEW)
    public int insertUsers(List&lt;User&gt; userList) {
        int count = 0;
        for (User user : userList) {
            // 调用类自身的方法，产生自调用问题
            count += insertUser(user);
        }
        return count;
    }
    
    // 传播行为为 REQUIRED_NEW ，名每次调用产生新事务
    @Override
    @Transactional(isolation = Isolation.READ_COMMITTED, propagation=Propagation.REQUIRED_NEW)
    public int insertUsers(User user) {
        return userDao.insertUser(user);
    }
}
</code></pre>

<p>对于 intsertUse 方法，把传播行为修改为 REQUIRES_NEW，也就是每次调用产生新的事务，而 insertUsers 方法就调用了这个方法。这是一个类自身方法之间的调用，称之为自调用。</p>

<p>查看日志可以发现，Spring 在运行中并没有创建任何新的事务独立地运行 insertUser 方法，即注解 @Transaction 失效了</p>

<p>原因在于：Spring 数据库事务地约定实现原理是 AOP，而 AOP 的原理是动态代理，在自调用过程中，是类自身的调用，而不是代理对象去调用，那么就不会产生 AOP ，这样 Spring 就不能把代码织入到约定的流程中，于是产生了失败的现象</p>

<p>可以用 Service 调用另一个 Service 解决这个问题，这就是代理对象的调用，Spring 会将代码织入事务流程中；</p>

<p>也可以从 Spring IoC 容器中获取代理对象去启用 AOP ，例如</p>

<pre><code class="java">@Service 
public class UserBatchServiceimpl implements UserBatchService, ApplicationContextAware {
    @Autowired
    private UserDao userDao = null;
    
    private ApplicationContextAware applicationContextAware = null;
    
    // 实现生命周期方法，设置 IoC 容器
    @Override
    public void setApplicationContext (ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext; 
    }
    
    
    @Override
    @Transactional(isolation = Isolation.READ_COMMITTED, propagation=Propagation.REQUIRED_NEW)
    public int insertUsers(List&lt;User&gt; userList) {
        int count = 0;
        
        // 从 IoC 容器中取出代理对象
        UserService userService = applicationContext.getBean(UserService.class);
        
        for (User user : userList) {
            // 使用代理对象调用方法插入用户，此时会织入 Spring 数据库事务流程中
            count += userService.insertUser(user);
        }
        return count;
    }
    
    // 传播行为为 REQUIRED_NEW ，名每次调用产生新事务
    @Override
    @Transactional(isolation = Isolation.READ_COMMITTED, propagation=Propagation.REQUIRED_NEW)
    public int insertUsers(User user) {
        return userDao.insertUser(user);
    }
}
</code></pre>

<p>注意这将是一个代理对象 并且使用它调用了传播行为为 REQUIRES_NEW 的 insertUser 方法，这样才可以运行成功。只是这样代码需要依赖于 Spring 的 API，会造成代码侵入，使用一个类调用另一个类方法则不会有依赖，只是相对麻烦一些。</p>
