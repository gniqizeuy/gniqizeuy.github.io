mybatis_cursor
Mybatis Cursor
mybatis 


<h3 id="toc_0">MyBatis 流式查询</h3>

<p><strong>流式查询</strong> 指的是查询成功后不是返回一个集合而是返回一个迭代器，应用每次从迭代器取一条查询结果。流式查询的好处是能够降低内存使用。</p>

<p>如果没有流式查询，我们想要从数据库取 1000 万条记录而又没有足够的内存时，就不得不分页查询，而分页查询效率取决于表设计，如果设计的不好，就无法执行高效的分页查询。因此流式查询是一个数据库访问框架必须具备的功能。</p>

<p>流式查询的过程当中，数据库连接是保持打开状态的，因此要注意的是：执行一个流式查询后，数据库访问框架就不负责关闭数据库连接了，需要应用在取完数据后自己关闭。</p>

<h4 id="toc_1">Mybatis 流式查询接口</h4>

<p>MyBatis 提供了一个叫 <code>org.apache.ibatis.cursor.Cursor</code> 的接口类用于流式查询，这个接口继承了 <code>java.io.Closeable</code> 和 <code>java.lang.Iterable</code> 接口，由此可知：</p>

<ol>
<li>Cursor 是可<strong>关闭</strong>的；</li>
<li>Cursor 是可<strong>遍历</strong>的。</li>
</ol>

<p>除此之外，Cursor 还提供了三个方法：</p>

<ol>
<li><code>isOpen()</code>：用于在取数据之前判断 Cursor 对象是否是打开状态。只有当打开时 Cursor 才能取数据；</li>
<li><code>isConsumed()</code>：用于判断查询结果是否全部取完。</li>
<li><code>getCurrentIndex()</code>：返回已经获取了多少条数据</li>
</ol>

<p>因为 Cursor 实现了迭代器接口，因此在实际使用当中，从 Cursor 取数据非常简单：</p>

<pre><code class="java">cursor.forEach(rowObject -&gt; {...});
</code></pre>

<h4 id="toc_2">构建 Cursor</h4>

<pre><code class="java">@Mapper
public interface FooMapper {
    @Select(&quot;select * from foo limit #{limit}&quot;)
    Cursor&lt;Foo&gt; scan(@Param(&quot;limit&quot;) int limit);
}
</code></pre>

<p>方法 scan() 是一个非常简单的查询。通过指定 Mapper 方法的返回值为 Cursor 类型，MyBatis 就知道这个查询方法一个流式查询。</p>

<p>然后我们再写一个 SpringMVC Controller 方法来调用 Mapper：</p>

<pre><code class="java">@GetMapping(&quot;foo/scan/0/{limit}&quot;)
public void scanFoo0(@PathVariable(&quot;limit&quot;) int limit) throws Exception {
    try (Cursor&lt;Foo&gt; cursor = fooMapper.scan(limit)) {  // 1
        cursor.forEach(foo -&gt; {});                      // 2
    }
}
</code></pre>

<p>上面的代码中，fooMapper 是 @Autowired 进来的。注释 1 处调用 scan 方法，得到 Cursor 对象并保证它能最后关闭；2 处则是从 cursor 中取数据。</p>

<p>上面的代码看上去没什么问题，但是执行 scanFoo0() 时会报错：</p>

<pre><code class="tex">java.lang.IllegalStateException: A Cursor is already closed.
</code></pre>

<p>这是因为在取数据过程中需要保持数据库连接，而 Mapper 方法通常在执行完后连接就关闭了，因此 Cusor 也一并关闭了。</p>

<p>所以，解决这个问题只需保持数据库连接打开即可。有以下三种方案可选。</p>

<h5 id="toc_3">SqlSessionFactory</h5>

<p>可以用 SqlSessionFactory 来手工打开数据库连接，将 Controller 方法修改如下：</p>

<pre><code class="java">@GetMapping(&quot;foo/scan/1/{limit}&quot;)
public void scanFoo1(@PathVariable(&quot;limit&quot;) int limit) throws Exception {
    try (
        SqlSession sqlSession = sqlSessionFactory.openSession();  // 1
        Cursor&lt;Foo&gt; cursor = sqlSession.getMapper(FooMapper.class).scan(limit)   // 2
    ) {
        cursor.forEach(foo -&gt; { });
    }
}
</code></pre>

<p>上面的代码中，1 处开启了一个 SqlSession （实际上也代表了一个数据库连接），并保证它最后能关闭；2 处使用 SqlSession 来获得 Mapper 对象。这样才能保证得到的 Cursor 对象是打开状态。</p>

<h5 id="toc_4">TransactionTemplate</h5>

<p>在 Spring 中，可以用 TransactionTemplate 来执行一个数据库事务，这个过程中数据库连接同样是打开的。代码如下：</p>

<pre><code class="java">@GetMapping(&quot;foo/scan/2/{limit}&quot;)
public void scanFoo2(@PathVariable(&quot;limit&quot;) int limit) throws Exception {
    TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager);  // 1

    transactionTemplate.execute(status -&gt; {               // 2
        try (Cursor&lt;Foo&gt; cursor = fooMapper.scan(limit)) {
            cursor.forEach(foo -&gt; { });
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    });
}
</code></pre>

<p>上面的代码中，1 处创建了一个 TransactionTemplate 对象，2 处执行数据库事务，而数据库事务的内容则是调用 Mapper 对象的流式查询。注意这里的 Mapper 对象无需通过 SqlSession 创建。</p>

<h5 id="toc_5">@Transactional 注解</h5>

<p>本质上与 TransactionTemplate 一致</p>

<pre><code class="java">@GetMapping(&quot;foo/scan/3/{limit}&quot;)
@Transactional
public void scanFoo3(@PathVariable(&quot;limit&quot;) int limit) throws Exception {
    try (Cursor&lt;Foo&gt; cursor = fooMapper.scan(limit)) {
        cursor.forEach(foo -&gt; { });
    }
}
</code></pre>

<p>它仅仅是在原来方法上面加了个 <code>@Transactional</code> 注解。此方案看上去最简洁，但请注意 Spring 框架当中注解使用的坑：<strong>只在外部调用时生效</strong> 。在当前类中调用这个方法，依旧会报错。</p>
