spring_security
Spring Security
spring 


<h3 id="toc_0">认识 Spring Security</h3>

<p>Spring Security 提供了声明式的安全访问控制解决方案（仅支持 Spring 的应用程序），对访问权限进行认证和授权，它基于 Spring Aop 和 Servlet 过滤器，提供了安全性方面的全面解决方案。</p>

<p>除常规的认证和授权外，它还提供了 ACls、LDAP、JAAS、CAS 等高级特性以满足复杂环境下的安全需求。</p>

<h4 id="toc_1">1. 核心概念</h4>

<ul>
<li>Principle：代表用户的对象 Principle（User），不仅指用户，还包括一切可以用于验证的设备。</li>
<li>Authority：代表用户的角色 Authority（Role），每个用户都应该有一种角色，如管理员或是会员。</li>
<li>Permission：代表授权，复杂的应用环境需要对角色的权限进行表述。</li>
</ul>

<p>在 Spring Security 中，Authority 和 Permission 是两个完全独立的概念，两者并没有必然的联系，它们之间需要通过配置进行关联，可以是自己定义的各种关系。</p>

<h4 id="toc_2">2. 认证和授权</h4>

<p>安全主要分为验证（authentication）和授权（authorization）两个部分</p>

<h5 id="toc_3">1）验证（authentication）</h5>

<p>验证指的是，建立系统使用者信息（principal）的过程。使用者可以是一个用户、设备、和可以在应该程序种执行某些操作的其他系统。</p>

<p>用过户认证一般要求用户提供用户名和密码，系统通过校验用户名和密码的正确性来完成认证的通过或拒绝过程。</p>

<p>Spring Security 支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要验证、OPenID 和 LDAP 等。</p>

<p>Spring Security 进行验证的步骤如下：</p>

<ol>
<li>用户使用用户名和密码登录</li>
<li>过滤器（UsernamePasswordAuthenticationFilter）获取到用户名、密码、然后封装成 Authentication。</li>
<li>AuthenticationManager 认证 token（Authentication的实现类传递）。</li>
<li>AuthenticationManager 认证成功，返回一个封装了用户权限信息的 Authentication 对象，用户的上下文信息（角色列表等）。</li>
<li>Authentication 对象赋值给当前的 SecurityContext，建立这个用户的安全上下文（通过调用 SecurityContextHolder.getContext().setAuthentication()）。</li>
<li>用户进行一些收到访问控制机制保护的操作，访问控制机制会依据当前安全上下文信息检查这个操作所需的权限。</li>
</ol>

<p>除利用提供的认证外，还可以编写自己的 Filter ，提供与那些不是基于 Spring Security 的验证系统的操作。</p>

<h5 id="toc_4">2）授权（authorization</h5>

<p>在一个系统中，不同用户具有的权限是不同的。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。</p>

<p>它判断某个 Principal 在应用程序中是否允许执行某个操作。在进行授权判断之前，要求其所要使用到的规则必须在验证过程中已经建立好了。</p>

<p>对 Web 资源的保护，最好的办法是使用过滤器。对方法调用的保护，最好的办法是使用 AOP。</p>

<p>Spring Security 在进行用户认证及授权时，也是通过各种拦截器和 AOP 来控制权限访问的，从而实现安全。</p>

<h4 id="toc_5">3. 模块</h4>

<ul>
<li>核心模块—spring security core.jar：包含核心验证和访问控制类和接口，以及支持远程配置的基本 API</li>
<li>远程调用—spring security remote.jar：提供与 Spring Remote 集成</li>
<li>网页—spring security web.jar：包括网站安全的模块，提供网站认证服务和基于 URL 访问控制</li>
<li>配置—spring security config.jar：包含安全命令空间解析代码</li>
<li>LDAP—spring security ldap.jar：LDAP 验证和配置</li>
<li>ACL—spring security acl.jar：对 ACL 访问控制表的实现</li>
<li>CAS—spring security cas.jar：对 CAS 客户端的安全实现</li>
<li>OpenID—spring security openid.jar：对 OpenID 网页验证的支持</li>
<li>Test—spring security test.jar：对 spring security 的测试的支持</li>
</ul>

<h3 id="toc_6">核心类</h3>

<h4 id="toc_7">1. SecurityContext</h4>

<p>SecurityContext 中包含当前正在访问系统的用户的详细信息，它只有以下两者方法：</p>

<ul>
<li><code>getAuthentication()</code>：获取当前经过身份验证的主体或身份验证的请求令牌</li>
<li><code>setAuthentication()</code>：更改或删除当前已验证的主体身份验证信息</li>
</ul>

<h4 id="toc_8">2. SecurityContextHolder</h4>

<p>SecurityContextHolder 用来保存 SecurityContext。最常用的是 <code>getContext()</code> 方法，用来获得当前 SecurityContext</p>

<p>SecurityContextHolder 中定义了一系列的静态方法，而这些静态方法的内部逻辑是通过 SecurityContextHolder 持有的 SecurityContextHolderStrategy 来实现的，如 <code>clearContext()</code>、<code>getContext()</code>、<code>setContext()</code>、<code>createEmptyContext()</code>。SecurityContextHolderStrategy 接口的关键代码如下：</p>

<pre><code class="java">public interface SecurityContextHolderStrategy {
    void clearContext();
    SecurityContext getContext();
    void setContext(SecurityContext context);
    SecurityContext createEmptyContext();
}
</code></pre>

<h5 id="toc_9">1)  strategy 实现</h5>

<p>默认使用的 strategy 就是基于 ThreadLocal 的 ThreadLocalSecurityContextHolderStrategy 来实现的</p>

<p>除了上述提到的，Spring Security 还提供了 3 中类型的 strategy 来实现</p>

<ul>
<li><code>ClobalSecurityContextHolderStrategy</code>：表示全局使用一个 SecurityContext，如 C/S 结构的客户端</li>
<li><code>InheritablThreadLocalSecurityContextHolderStrategy</code>：使用 InheritablThreadLocal 来存放 SecurityContext，即子线程可以使用父线程中存放的变量</li>
<li><code>ThreadLocalSecurityContextHolderStrategy</code>：使用 ThreadLocal 来存放 SecurityContext</li>
</ul>

<p>一般情况下，使用默认的 Strategy 即可。但是，如果改变默认的 strategy，Spring Security 提供了两者方法来改变 &ldquo;StrategyName&rdquo;</p>

<p>SecurityContextHolder 类中有 3 中不同类型的 strategy，分别为 MODE_THREADLOCAL、MODE_INHERITABLETHREADLOCAL 和 MODE_GLOBAL，关键代码如下：</p>

<pre><code class="java">public static final String MODE_THREADLOCAL=&quot;MODE_THREADLOCAL&quot;;
public static final String MODE_INHERITABLETHREADLOCAL = &quot;MODE_INHERITABLETHREADLOCAL&quot;;
public static final String MODE_GLOBAL = &quot;MODE_GLOBAL&quot;;
public static final String SYSTEM_PROPERTY = &quot;spring.security.strategy&quot;;
private static String strategyName = System.getProperty(SYSTEM_PROPERTY);
private static SecurtyContextStrategy strategy;
</code></pre>

<p>MODE_THREADLOCAL 是默认的方法</p>

<p>如果改变 strategy ，则有以下两种方法：</p>

<ul>
<li>通过 SecurityContextHolder 的静态方法 <code>setStrategyName(java.lanng.String strategyName)</code> 来改变需要使用的 strategy</li>
<li>通过系统属性（SYSTEM_PROPERTY）进行指定，其中属性名默认为 ”spring.security.strategy“，属性值为对应 strategy 的名称</li>
</ul>

<h5 id="toc_10">2）获取当前用户的 SecurityContext</h5>
