css_center
CSS Center
css 


<h4 id="toc_0">垂直居中</h4>

<p>CSS 中对元素进行<strong>水平居中</strong>是非常简单的；如果它是一个行内元素，就对它的父元素应用 <code>text-align: center</code>；如果它是一个块级元素，就对它自身应用 <code>margin: auto</code>。然而如果对一个元素进行<strong>垂直居中</strong>则十分麻烦</p>

<p>有几种技巧十分流行，但这里并不会深入探讨，原因如下</p>

<ul>
<li><strong>表格布局法</strong>：（利用表格的显示模式）需要用到一些冗余的 HTML 元素，因此不多介绍。</li>
<li><strong>行内块法</strong>：也不做讨论，hack 味道很浓</li>
</ul>

<p>以下 html 元素示例</p>

<pre><code class="html">&lt;main&gt;
    &lt;h1&gt;Am I centered yet?&lt;/h1&gt;
    &lt;p&gt;Center me, please!&lt;/p&gt;
&lt;/main&gt;
</code></pre>

<div style="background: orange; color: #fff;height: 25vh;width:40vh">
    <main style="width: 50%;background: gray;margin: auto">
        <h1 style="margin:unset;font-size: 2em;">Am I centered yet?</h1>
        <p>Center me, please!</p>
    </main>
</div>

<h5 id="toc_1">基于绝对定位的解决方法</h5>

<p>我们先看一个早期的垂直居中方法，它要求元素具有固定的高度：</p>

<pre><code class="css">main {
    position: absolute;
    top: 50%;
    left: 50%;
    margin-top: -3em; /* 6/2 = 3 */
    margin-left: -9em; /* 18/2 = 9 */
    width: 18em;
    height: 6em
}
</code></pre>

<p>这段代码在本质上做了这样几件事情：先把这个元素的左上角放置在视口（或最近的、具有定位属性的祖先元素）的正中心，然后再利用负外边距把它向左、向上移动（移动距离相当于它自身高的一般），从而把元素的正中心放置在视口的正中心。借助强大的 <code>calc()</code> 函数，这段代码可以省掉两行声明：</p>

<pre><code class="css">main {
    position: absolute;
    top: calc(50% - 3em);
    left: calc(50% - 9em);
    width: 18em;
    height: 6em
}
</code></pre>

<p>显然，这个方法最大的局限在于它要求元素的高宽是固定的。在通常情况下，对哪些需要居中的元素来说，其尺寸往往是其内容来决定的。如果能找到一个属性的百分比值以元素自身的高宽作为解析基准，那我们的难题就迎刃而解了！遗憾的是，对于绝大多数 CSS 属性（包括 margin）来说，百分比都是以其父元素的尺寸为基准进行解析的。</p>

<p>CSS 领域中有一个很常见的现象，真正的解决方案往往来自于我们最意想不到的地方。在这个例子中，答案来自于 CSS 变形属性。当我们在 <code>translate()</code> 变形函数中使用百分比值时，是以这个元素自身的宽度和高度为基准进行换算和移动的，而这正是我们所需要的。接下来，只要换用基于百分比的 CSS 变形来对元素进行偏移，就不需要在偏移量中把元素的尺寸给写死了。这样我们就可以彻底解决对固定尺寸的依赖：</p>

<pre><code class="css">main {
    position: absolute;
    top: 50%;
    left: 50%;
    tansform: translate(-50%, -50%);
}
</code></pre>

<p>当然没有任何技巧是十全十美的，上面这个方法也有一些需要注意的地方。</p>

<ul>
<li>有时不能选用绝对定位，因为它对整个布局的影响太过激烈。</li>
<li>如果需要居中的元素已经在高度上超过了视口，那它的顶部会被视口裁切掉。有一些办法可以绕过这个问题，但 hack 味道过浓。</li>
<li>在某些浏览器中，这个方法可能会导致元素的显示有一些模糊，因为元素可能被防止在半个像素上。这个问题可以用 <code>transform-style: preserve-3d</code> 来修复，不过这个修复手段也可以认为是一个 hack，而且很难保证它在未来不会出现问题。</li>
</ul>

<h5 id="toc_2">基于视口单位的解决方法</h5>

<p>假如我们不想使用绝对定位，仍然可以采用 translate() 技巧来把这个元素以其自身宽高的一半为距离进行移动；但是在缺少 left 和 top 的情况下，如何把这个元素的左上角放置在容器的正中心？</p>

<p>使用 margin 属性的百分比值来实现会产生十分离谱的结果，原因在于 <strong>margin 的百分比值是以父元素的宽度作为解析基准的</strong>。没错，即使对于 margin-top 和 margin-bottom 来说也是如此！</p>

<pre><code class="css">main {
    width: 18em;
    padding: 1em 1.5em;
    margin: 50% auto 0;
    tansform: translate(-50%, -50%);
}
</code></pre>

<p>不过幸运的是，如果只是想把元素相对于视口进行居中吗，仍然是有希望的。CSS 值与单位（第三版）定义了一套新的单位，称为视口相关的长度单位。</p>

<ul>
<li>vw 是与<strong>视口宽度</strong>相关的。与常人的直觉不符的是，1 vw 实际上表示视口宽度的 1%，而不是 100%</li>
<li>与 vw 类似，1vh 表示<strong>视口高度</strong>的 1%</li>
<li>当视口宽度小于高度时，1vmin 等于 1vw，否则等于 1vh</li>
<li>当视口宽度大于高度时，1vmax等于 1vw，否则等于 1vh</li>
</ul>

<p>在此例中，适用于外边距的是 vh 单位：</p>

<pre><code class="css">main {
    width: 18em;
    padding: 1em 1.5em;
    margin: 50vh auto 0;
    tansform: translate(-50%, -50%);
}
</code></pre>

<p>这个技巧的实用性是相当有限的，因为它只适用于在视口中居中的场景。</p>

<h5 id="toc_3">基于 Flexbox  的解决方案</h5>

<p>这是毋庸置疑的最佳解决方案，因为 <strong>Flexbox （伸缩盒）</strong>是专门针对这类需求所设计的。之所以讨论其他方案，仅仅是因为那些方案在浏览器的支持程度上稍微好一些而已。</p>

<p>只需要写两行声明即可：先给这个待居中元素的父元素设置 <code>display: flex</code>，再给这个元素设置 <code>margin:auto</code>：</p>

<pre><code class="css">body {
    display:flex;
    min-height: 100vh;
    maigin: 0;
}

main {
    margin: auto;
}
</code></pre>

<p>请注意，在使用 Flexbox 时，margin: auto 不仅在水平方向上将元素居中，垂直方向上也是如此，还有一点，我们甚至不需要指定任何宽度；这个居中元素分配到的宽度等于 max-content。</p>

<p>Flexbox 的另一个好处在于，它可以将匿名容器（即没有被标签包裹的文本节点）垂直居中</p>

<pre><code class="html">&lt;main&gt;Center me, please!&lt;/main&gt;
</code></pre>

<p>我们先给这个 main 元素指定一个固定的尺寸，然后借助 Flexbox 规范所引入的 aligin-items 和 justify-content 属性，我们可以让它的内部的文本也实现居中</p>

<pre><code class="css">main {
    display: flex;
    aligin-item: center;
    justify-content: center;
    width: 18em;
    height: 10em;
}
</code></pre>

<p>根据盒对齐模型（第三版）的计划，在未来吗，对于简单的垂直居中需求，我们安全不需要动用特殊的布局模式了。因为只需要下面这行代码就可以搞定：</p>

<pre><code class="css">align-selg: center;
</code></pre>

<p>不管这个元素上还应用了其他什么属性，这样写就够了。（期待尽快实现）</p>
