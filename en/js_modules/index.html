js_module
Js Module
js 


<h3 id="toc_0">使用ES6模块</h3>

<p>ES6 最大的一个改进就是引入模块规范，这个规范全方位简化了之前出现的模块加载器，原生浏览器都支持意味着加载器及其他预处理都不再必要。从很多方面看，ES6 模块系统是集 AMD 和 CommonJS 之大成者。</p>

<h4 id="toc_1">模块标签及定义</h4>

<p>ECMAScript 6 模块是作为一整块 JavaScript 代码而存在的。带有 type=&ldquo;module&rdquo; 属性的 &lt;script&gt; 标签会告诉浏览器相关代码应该作为模块执行，而不是作为传统的脚本执行。模块可以嵌入在网页中，也可以作为外部文件引入：</p>

<pre><code class="javascript">&lt;script type=&quot;module&quot;&gt;
  // 模块代码
&lt;/script&gt;

&lt;script type=&quot;module&quot; src=&quot;path/to/myModule.js&quot;&gt;&lt;/script&gt;
</code></pre>

<p>即使与常规的 JavaScript 文件处理方式不同，Javascript 模块文件也没有专门的内容类型。</p>

<p>与传统脚本不同，所有模块都会像 &lt;script defer&gt; 加载的脚本一样按顺序执行。解析到 &lt;script type=&ldquo;module&rdquo;&gt; 标签后会立即下载模块文件，但执行会延迟到文档解析完成。无论对嵌入的模块代码，还是引入的外部模块文件，都是这样。&lt;script type=&ldquo;module&rdquo;&gt; 在页面中出现的顺序就是它们的执行顺序。与 &lt;script defer&gt; 一样，修改模块标签的位置，无论是在 &lt;head&gt; 还是在 &lt;body&gt; 中，只会影响文件什么时候加载，而不会影响模块什么时候加载。</p>

<p>下面演示了嵌入模块代码的执行顺序：</p>

<pre><code class="javascript">&lt;!-- 第二个执行 --&gt;
&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;

&lt;!-- 第三个执行 --&gt;
&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;

&lt;!-- 第一个执行 --&gt;
&lt;script&gt;&lt;/script&gt;
</code></pre>

<p>另外，可以改为外部 JS 模块定义：</p>

<pre><code class="javascript">&lt;!-- 第二个执行 --&gt;
&lt;script type=&quot;module&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;

&lt;!-- 第三个执行 --&gt;
&lt;script type=&quot;module&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;

&lt;!-- 第一个执行 --&gt;
&lt;script&gt;&lt;/script&gt;
</code></pre>

<p>也可以给模块标签添加 async 属性。这样影响就是双重的；不仅模块执行顺序不在与 &lt;script&gt; 标签在页面中的顺序绑定，模块也不会等待文档完成解析才执行。不过，入口模块仍必须等待其他依赖加载完成。</p>

<p>与 &lt;script type=&ldquo;module&rdquo;&gt; 标签关联的 ES6 模块被认为是模块图中的入口模块。一个页面上有多少个入口模块没有限制，吃哦宁国府加载同一个模块也没有限制。同一个模块无论在一个页面中被加载多少次，也不管它是如何加载的，实际上都只会加载一次。</p>

<pre><code class="javascript">&lt;-- moduleA 在这个页面只会被加载一次 --&gt;

&lt;script type=&quot;module&quot;&gt;
  improt './moduleA.js'
&lt;/script&gt;
&lt;script type=&quot;module&quot;&gt;
  improt './moduleA.js'
&lt;/script&gt;
&lt;script type=&quot;module&quot; src=&quot;./moduleA.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;module&quot; src=&quot;./moduleA.js&quot;&gt;&lt;/script&gt;
</code></pre>

<p>嵌入的模块定义代码不能使用 import 加载到其他模块。只有通过外部文件加载的模块才可以使用 import 加载。因此，嵌入模块只适合作为入口模块。</p>

<h4 id="toc_2">模块加载</h4>

<p>ESMAScript6 模块的独特之处在于，既可以通过浏览器原生加载，也可以与第三方加载器和构建工具一起加载。有点浏览器还没有原生支持 ES6 模块，因此可能还需要第三方工具。事实上，很多时候使用第三方工具可能会更方便。</p>

<p>完全支持 ESMAScript6 模块的浏览器可以从顶级模块加载整个依赖图，且是异步完成的。浏览器会解析入口模块。确定依赖。并发送对依赖模块的请求，这些文件通过网络返回后，浏览器就会解析它们的内容、确定它们的依赖、如果这些耳机依赖还没有加载，则会发送更多请求。这个异步递归加载过程会持续到整个应用程序的依赖图都解析完成。解析完依赖图，应用程序就可以正式加载模块了。</p>

<h3 id="toc_3">模块行为</h3>

<p>ESMAScript6 模块借用了 CommanJS 和 AMD 的很多优秀特征。下面简单列举一些</p>

<ul>
<li>模块代码只在加载后执行。</li>
<li>模块只能加载一次。</li>
<li>模块是单例。</li>
<li>模块可以定义公共接口，其他模块可以基于这个公共接口观察和交互。</li>
<li>模块可以请求加载其他模块。</li>
<li>支持循环依赖。</li>
</ul>

<p>ES6 模块系统也增加了一些新行为。</p>

<ul>
<li>ES6 模块默认在严格模式下执行。</li>
<li>ES6 模块不共享命名空间。</li>
<li>模块顶级 this 的值是 undefined（常规脚本中是 window）。</li>
<li>模块中的 var 声明不会添加到 window 对象。</li>
<li>ES6 模块是异步加载和执行的。</li>
</ul>

<p>浏览器运行时在知道应该把某个文件当成模块，会有条件地按照 ESMAScript6 模块行为来施加限制。与&lt;script type=&ldquo;module&rdquo;&gt;关联或者通过 import 语句加载的 JavaStript 文件会被认定为模块。</p>

<h3 id="toc_4">模块导出</h3>

<p>ES6 模块的公共导出系统与 CommonJS 非常相似。控制模块的哪些行为对外部可见的是 export 关键字。ES6 模块支持两种导出：命名导出和默认导出。不同的导出方式对应不同的导入方式。</p>

<p>export 关键字用于声明一个值为命名导出。导出语句必须在模块顶级，不能嵌套在某个块中：</p>

<pre><code class="javascript">// 允许
export ...

// 不允许
if (condition) {
    export ...
}
</code></pre>

<p>导出值对模块内部 JavaScript 的执行没有直接影响，因此 export 语句与导出值的相对位置或者 export 关键字在模块中出现的顺序没有限制。export 语句甚至可以出现在它要导出的值之前：</p>

<pre><code class="javascript">// 允许
const foo = 'foo'
export { foo }

// 允许
export const foo = 'foo'

// 允许，但应该避免
export { foo }
const foo = 'foo'
</code></pre>

<p>命名导出（named export）就好像模块是被导出值得容器。行内命名导出，即可以在同一行执行变量声明。下面展示了一个声明变量同时又导出变量得例子。外部模块可以导入这个模块，而 foo 将称为这个导入模块的一个属性</p>

<pre><code class="javascript">export const foo = 'foo'
</code></pre>

<p>变量声明跟导出可以不在同一行。可以在 export 子句中执行声明并将标识符导出到模块的其他地方：</p>

<pre><code class="javascript">export { foo }
const foo = 'foo'
</code></pre>

<p>导出时也可以提供别名，别名必须在 export 子句的大括号语法中指定。因此，声明值、导出值和为导出值提供别名不能在一行完成。在下面例子中，导入这个模块的外部模块可以使用 myFoo 访问导出的值：</p>

<pre><code class="javascript">const foo = 'foo'
export { foo as myFoo }
</code></pre>

<p>因为 ES6 命名导出可以将模块做为容器，所以可以在一个模块中声明多个命名导出。导出的值可以在导出语句中声明，也可以在导出之前声明：</p>

<pre><code class="javascript">export const foo = 'foo'
export const bar = 'bar'
export const baz = 'baz'
</code></pre>

<p>ES6 模块也支持对导出声明分组，可以同时为部分或全部导出值指定别名：</p>

<pre><code class="javascript">const foo = 'foo'
const bar = 'bar'
const baz = 'baz'
export { foo, bar as myBar, baz}
</code></pre>

<p><strong>默认导出</strong>（default export）就好像模块与被导出的值时一回事。默认导出使用 default 关键字将一个值声明为默认导出，每个模块只能有一个默认导出。重复的默认导出会导致 SyntaxError</p>

<p>下面定义一个默认导出，外部模块可以导入这个模块，而这个模块本身就是 foo 的值：</p>

<pre><code class="javascript">const foo = 'foo'
export default foo
</code></pre>

<p>另外，ES6 模块会识别作为别名提供的 default 关键字。此时，虽然对应的值是使用命名语句导出的，实际上则会成为默认导出：</p>

<pre><code class="javascript">const foo = 'foo'

// 等同于 export default foo
export { foo as default }
</code></pre>

<p>因为命名导出和默认导出不会冲突，所以 ES6 支持在一个模块中同时定义这两种导出：</p>

<pre><code class="javascript">const foo = 'foo'
const bar = 'bar'

export { bar }
export default foo
</code></pre>

<p>这连个 export 语句可以组合为一行：</p>

<pre><code class="javascript">const foo = 'foo'
const bar = 'bar'

export { foo as default, bar }
</code></pre>

<p>ES6 规范对不同形式的 export 语句中可以使用什么不可以使用什么规范了限制。某些形式允许声明和赋值，某些形式只允许表达式，而某些形式则只允许简单标识符。注意，有的形式使用了分号，有的则没有：</p>

<pre><code class="javascript">// 命名行内导出
export const baz = 'baz'
export const foo = 'foo', bar = 'bar'
export function foo() {}
export function* foo() {}
export class Foo {}

// 命名子句导出
export { foo }
export { foo, bar }
export { foo as myFoo, bar }

// 默认导出
export default 'baz'
export default { foo: 'foo'}
export default { foo, bar as default }
export default foo
export default function() {}
export default function foo() {}
export default function*() {}
export default class {}

// 会导致错误的不同形式：

// 行内默认导出中不能出现变量声明
export default const foo = 'bar'

// 只有标识符可以出现在 export 子句中出现
export { 123 as foo }

// 别名只能在 export 子句中出现
export const foo = 'foo' as myFoo
</code></pre>

<p>注意：什么可以或不可以与 export 关键字出现在同一行可能很难记住。一般来说，声明、赋值和导出标识符最好分开。这样就不容易搞错了，同时也可以让 export 语句集中在一起。</p>

<h3 id="toc_5">模块导入</h3>

<p>模块可以通过使用 import 关键字使用其他模块导出的值。与 export 类似，import 必须出现在模块的顶级：</p>

<pre><code class="javascript">// 允许
import ...

// 不允许
if (condition) {
    import ...
}
</code></pre>

<p>import 语句被提升到模块顶部。因此，与 export 关键字类似，import 语句与使用导入值得语句的相对位置并不重要。不过，还是推荐把导入语句放在模块顶部</p>

<pre><code class="javascript">// 允许
import { foo } from './fooModule,js'
console.log(foo) // 'foo'

// 允许，但应该避免
console.log(foo) // foo
import { foo } from './fooModule,js'
</code></pre>

<p>模块标识符可以是相对于当前模块的相对路径，也可以是指向模块文件的绝对路径。它必须是纯字符串，不能是动态计算的结果。例如：不能是拼接的字符串。</p>

<p>如果在浏览器中通过标识符原生加载模块，则文件必须带有 .js 扩展名，不然可能无法正确解析。不过，如果是通过构建工具或第三方模块加载器打包或解析的 ES6 模块，则可能不需要包含文件扩展名。</p>

<pre><code class="javascript">// 解析为 /components/bar.js
import ... from './bar.js'

// 解析为 /bar.js
import ... from '../bar.js'

// 解析为 /bar.js
import ... from '/bar.js'
</code></pre>

<p>不是必须通过导出的成员才能导入模块。如果不需要模块的特定导出，但仍想加载和执行模块以利用其副作用，可以只通过路径加载它：</p>

<pre><code class="javascript">import './foo.js'
</code></pre>

<p>导入对模块而言是只读的，实际上相当于 const 声明的变量。</p>
