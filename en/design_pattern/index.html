design_pattern
Design Pattern
design 


<h2 id="toc_0">设计模式怎么解决设计问题</h2>

<h4 id="toc_1">寻找合适的对象</h4>

<p>面向对象程序由对象组成，对象包括数据和对数据操作的过程，过程通常称为方法或操作。对象在收到客户的请求或消息后，执行相应的操作。</p>

<p>客户请求是使对象<strong>执行操作的唯一方法</strong>，操作由是对象<strong>改变内部数据的唯一方法</strong>。由于这些限制，对象的内部状态是封装的，它不能被直接访问，它的表示对于对象外部是不可见的。</p>

<p>面向对象设计最困难的部分是<strong>将系统分解成对象集合</strong>。因为要考虑许多因素：封装、粒度、依赖关系、灵活性、性能、演化、复用等。他们都影响着系统的分解，并且这些因素通常还是互相冲突的。</p>

<p>面向对象设计方法学支持多种设计方法。你可以写出一个问题描述，挑出名词和动词，进而创建相应的类和操作；或者，你可以关注系统的协作和职责关系；或者，你可以对现实世界建模，再将分析时发现的对象转化至设计中，至于哪一种方法最好，并无定论。</p>

<p>设计的许多对象来源于现实世界的分析模型。但是，设计结果所得到的类通常在现实世界中并不存在，有些是像数组之类的低层类，而另一些则层次较高，例如，Composite 模式引入了统一对待现实世界中并不存在的对象的抽象方法。严格反应当前现实世界的模型并不能产生也能反映将来世界的系统。<strong>设计中的抽象对于产生灵活的设计是至关重要的</strong>。</p>

<p>设计模式帮你<strong>确定并不明显的抽象和描述这些抽象的对象</strong>。例如，描述过程或算法的对象现实中并不存在，但他们确实设计的关键部分。Strategy 模式描述了怎么实现可互换的算法族。State 模式将实体的每一个状态描述为一个对象。这些对象在分析阶段，甚至在设计阶段的早期并不存在，后来为使设计更加灵活、复用性更好才将他们发掘出来。</p>

<h3 id="toc_2">决定对象的粒度</h3>

<p>对象在大小和数目上变化极大。它们能表示下至硬件或上至整个应用的任何事物。设计模式很好的讲述了怎么决定一个对象应该是什么，Facade（外观）模式描述了怎么用对象表示完整的子系统，Flyweight（享元）模式描述了如何支持大量的最小粒度的对象。其他一些设计模式描述了将一个对象分解成许多小对象的特定方法。Abstract Factory（抽象工厂）和 Builder（生成器）产生那些专门负责生产其他对象的对象。Visitor（访问者）和 Command（命令）模式生产的对象专门负责实现对其他对象或者对象组的请求。</p>

<h3 id="toc_3">指明对象接口</h3>

<p>对象声明的每一个操作都指定操作名、作为参数的对象和返回值，这就是所谓的操作的<strong>型构</strong>（signature）。对象操作所定义的所有操作型构的集合被称作该对象的<strong>接口</strong>（interface）。对象接口描述了该对象所能接受的全部请求的集合，任何匹配对象接口中型构的请求都可以发送给对象。</p>

<h3 id="toc_4">描述对象的实现</h3>

<h3 id="toc_5">运用复用机制</h3>

<p><strong>继承和组合的比较</strong></p>

<p>面向对象系统中功能复用的两种最常用技术是类继承和<strong>对象组合</strong>。类继承允许你根据其他类的实现来定义一个类的实现。这种通过生产子类的复用通常被称为<strong>白箱复用</strong>（white-box reuse）。“白箱”是相对可视性而言的：在继承方式中，父类的内部细节对子类可见。</p>

<p>对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为<strong>黑箱复用</strong>（black-box resue），因为对象的内部细节是不可见的。对象只以“黑箱”的形似出现。</p>

<p>继承和组合各有优缺点。类继承是编译时静态定义的，且可直接使用，因为程序设计语言支持类继承。类继承可以较方便地改变被复用的实现。当一个子类重定义一些而不是全部操作时，它也能影响它所继承地操作，只要在这些操作中调用了被重定义地操作。</p>

<p>但是类继承也有一些不足之处。首先，因为继承在编译时就定义了，所以无法在运行时改变从父类继承的实现。更糟的是，父类通常至少定义了部分子类的具体表示。因为继承对子类揭示了其父类的实现细节，所以继承常被认为“破坏了封闭性”。子类中的实现与它的父类有如此紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。</p>

<h3 id="toc_6">关联运行时和编译时的结构</h3>

<p>一个面向对象程序运行时的结构通常与它的代码结构相差较大。代码结构在编译时就被确定下来了，它由继承关系固定的类组成。而程序的运行时结构是由快速变化的通信对象网络组成的。事实上两个结构是彼此独立的，试图由一个去理解另一个就好像试图从静态的动植物去理解活生生的生态系统的动态性一样。反之亦然。</p>

<p>考虑对象<strong>聚合</strong>（aggregation）和<strong>相识</strong>（acquaintance）的差别以及它们在编译时和运行时的表示时多么不同。聚合意味着一个对象拥有另一个对象或对另一个对象负责。一般我们称一个对象<strong>包含</strong>另一个对象或者另一个对象的一部分。聚合意味着聚合对象和其所有者具有相同的生命周期</p>

<p>相识意味着一个对象仅仅知道另一个对象。有时相识也被称为“关联”或“引用”关系。相识的对象可能请求彼此的操作，但是它们不为对方负责。相识是一种比聚合更弱的关系，它只标识了对象间较松散的耦合关系。</p>

<h3 id="toc_7">设计应支持变化</h3>

<p>获取最大限度复用的关键在于对新需求和已有需求发生变化时的预见性，要求你的系统设计能够相应地改进。</p>

<p>为了设计适应这种变化且具有健壮性的系统，你必须考虑系统在它的生命周期内会发生怎样的变化。一个不考虑系统变化的设计在将来就有可能需要重新设计。这些变化可能是类的重新定义和实现，修改客户和重新测试。重新设计会影响软件系统的许多方面，并且未曾料到的变化总是代价巨大的。</p>

<p>设计模式可以确保系统以特定方式变化，从而帮助你避免重新设计系统。每一个设计模式允许系统结构的某个方便的变化独立于其他方面，这样产生的系统对于某种特定变化将更健壮。</p>

<p>下面阐述了一些导致重新设计的一般原因，以及解决问题的设计模式：</p>

<p>1）<strong>通过显式地指定一个类来创建对象</strong> 在创建对象时指定类名将使你受特定实现的约束而不是特定接口的约束。这会使未来的变化更复杂。要避免这种情况，应该间接地创建对象。</p>

<p>*设计模式*：Abstract Factory，Factory Method，Prototype。</p>

<p>2）<strong>对特定操作地依赖</strong> 当你为请求指定一个特殊的操作时，完成该请求地方式就固定下来了。为避免将请求代码写死，你将可以在编译时或运行时很方便地改变响应请求地方法。</p>

<p>*设计模式*：Chain of Resposibility，Command。</p>

<p>3）<strong>对硬件和软件平台的依赖</strong> 外部的操作系统接口和应用编程接口（API）在不同的软硬件平台上是不同的。依赖于特定平台的软件很难移植到其他平台上，甚至很难跟上本地平台的更新。所以设计系统时限制平台相关性就很重要了。</p>

<p>*设计模式*：Abstract Factory，Bridge。</p>

<p>4) <strong>对对象表示或实现的依赖</strong> 知道对象怎样表示、保存、定位或实现的客户在对象发生变化时可能也需要变化。对客户隐藏这些信息能阻止连锁变化。</p>

<p>*设计模式*：Abstract Factory，Bridge，Memento，Proxy。</p>
